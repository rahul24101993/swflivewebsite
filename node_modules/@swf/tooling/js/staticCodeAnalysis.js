/* eslint-disable max-lines */
// Copyright (c) 2021 Siemens
/* eslint-disable complexity */
/* eslint-disable no-multi-assign */
/* eslint-disable no-useless-escape */
/* eslint-disable require-jsdoc */
/* eslint-disable valid-jsdoc */
/* eslint-disable class-methods-use-this */

const _ = require( 'lodash' );
const Ajv = require( 'ajv' );
const { existsSync, readdirSync, readFileSync, readJsonSync, statSync } = require( 'fs-extra' );
const htmlParser = require( 'html-parser' );
const { basename, dirname, join, parse, sep } = require( 'path' );
const pathParse = require( 'path-parse' );
const through = require( 'through2' );
const xml2js = require( 'xml2js' );
const path = require('path');
const logger = require( './logger' );
const { merge, normalizePath, shortenPath, getLineNumber } = require( './util' );
const { mergeCustomActionTemplateWithApolloActionTemplate } = require( './mergeCustomActionSchema' );
const { strict } = require( 'yargs' );
const {
    ensureViewModelI18nUsage,
    processViewModelI18nUsage,
    processSecondaryWorkareaTabsJsonI18nUsage,
    processStatesJsonI18nUsage,
    processJavaScriptI18nUsage,
    processViewI18nUsage,
    setI18NGlobalVars
} = require( './i18n/i18nStaticCode' );

const trace = logger.createTrace( __filename );

const ajv = Ajv( { allErrors: true, extendRefs: true } ); // eslint-disable-line new-cap
ajv.addMetaSchema( require( 'ajv/lib/refs/json-schema-draft-06.json' ) );

let mergedCVMSchema;
let mergedVMSchema;
let mergedSyncStrategySchema;
// Flag indicating if we are in 'strict' mode or not.
// In internal development, this is true; otherwise false;
let _strictMode = false;

/**
 * Similar to gulp-changed but instead compares hash files instead.  If no files have changed it will remove all files from the stream.
 *
 * @param {String} name - module name
 * @param {Object} cache - Parsed JSON Tree from the out/cache.json file (plus properties added by preAuditPrep.js)
 * @return {Stream} stream of files if changes detected
 */
module.exports = function staticCodeAnalysis( name, cache ) {
    const scaCache = module.exports.buildCache( cache );
    setI18NGlobalVars( scaCache, cache, _strictMode );

    const localVars = {
        MSG_PREFIX: `audit/${logger.nameColor( name )}: `,
        name: name,
        stream: null,
        file2issues: {},
        featureNames: [],
        modulePropertyName2IPropertyNames: {},
        kernelPropertyName2IPropertyNames: {},
        propertyPolicyFile2unusedProperties: {}
    };

    const objProviders = 'dataProviders';
    const objActions = 'actions';
    const attrAction = 'action';
    const attrProp = 'prop';
    const attrCaption = 'caption';
    const attrProvider = 'dataprovider';
    const objImport = 'imports';
    const thirdPartyLibList = [ 'lodash' ];
    const objLifecycleHooks = 'lifecycleHooks';
    const objOnEvent = 'onEvent';
    const supportedHooks = [ 'onInit', 'onMount', 'onUnmount' ];
    const deprecatedEvents = [ { '.contentLoaded': 'lifecycleHooks:onMount' }, { '.contentUnloaded': 'lifecycleHooks:onUnmount' } ];
    const isApollo = existsSync( `${process.cwd()}/package.json` ) ? require( `${process.cwd()}/package.json` ).name === 'afx' : false;

    // Log Build Module issues
    if( name.length > 0 && name !== 'nonModule' && cache && cache.name2moduleJson ) {
        const moduleName = localVars.name;
        const moduleJson = cache.name2moduleJson[ moduleName ];

        const issues = {
            errors: [],
            warnings: []
        };

        // Check for duplicate module names
        if( cache.audit.moduleNames.includes( moduleName ) ) {
            issues.errors.push( 'Duplicate modules named: ' + moduleName );
        } else {
            cache.audit.moduleNames.push( moduleName );
        }

        // Check for modules that are referenced by multiple kits or not included in any kit
        if( moduleJson.audit ) {
            const kitList = moduleJson.audit.kits;
            if( kitList.length > 1 ) {
                let msg = 'Referenced by more than one kit\n';
                _.forEach( kitList, kit => {
                    msg += '    kit: ' + kit.name + '\n';
                } );
                if( scaCache.ExclusionListForModulesInMultipleKits && scaCache.ExclusionListForModulesInMultipleKits.includes( moduleJson.name ) ) {
                    // FIXME temporarily whitelist until these are fixed
                    issues.warnings.push( msg );
                } else {
                    issues.errors.push( msg );
                }
            } else if( kitList.length === 0 &&
                !/^(cucumbertests)$/.test( moduleJson.name ) &&
                scaCache.moduleNotInKitWhiteList && !scaCache.moduleNotInKitWhiteList.includes( moduleJson.name ) ) {
                // TODO Add flag in module.json that indicates 'notKitted'; covers cucumbertests
                issues.errors.push( 'Module is not included in any kit' );
            }

            // Lookup tables used to find duplicate require and NG module names
            const foundModules = [];
            const foundNgModules = [];

            _.forEach( moduleJson.audit.filePath2FileInfo, fileInfo => {
                // Check for duplicate module names
                if( !fileInfo.test ) {
                    const fileInfo2 = foundModules[ fileInfo.name ];
                    if( fileInfo2 ) {
                        const msg = 'Duplicate ES6 module name "' + fileInfo.name + '" found in the following two files\n' +
                            'file1: ' + fileInfo.filePath + '\n' +
                            'file2: ' + fileInfo2.filePath;
                        issues.errors.push( msg );
                    } else {
                        foundModules[ fileInfo.name ] = fileInfo;
                    }
                }

                // Check for duplicate NG module names
                _.forEach( fileInfo.ngModules, ngModule => {
                    if( ngModule.name && !fileInfo.test &&
                        !/\/solutions\/showcase\//.test( fileInfo.filePath ) ) {
                        const fileInfo2 = foundNgModules[ ngModule.name ];
                        if( fileInfo2 ) {
                            const msg = 'Duplicate NG module name "' + ngModule.name + '" found in the following two files\n' +
                                'file1: ' + fileInfo.filePath + '\n' +
                                'file2: ' + fileInfo2.filePath;
                            issues.errors.push( msg );
                        } else {
                            foundNgModules[ ngModule.name ] = fileInfo;
                        }
                    }
                } );
            } );
        } else {
            issues.warnings.push( 'Module is not included in any kit' );
        }

        if( issues.errors.length > 0 || issues.warnings.length > 0 ) {
            // A dummy file path is used for module issues
            // ROOT and /src/ are stripped before reporting
            const dummyFilePath = 'src/Module(' + moduleName + ')';
            localVars.file2issues[ dummyFilePath ] = issues;
        }
    }

    /**
     * Method to parse html files.
     *
     * @param {String} contents - the file contents
     * @param {Array} elem - elements in the file.
     * @param {Array} attr - the attributes in the file
     * @param {Array} val - the value of the attributes in the file
     * @param {Array} eleValue - the value of the text which is word
     */
    function parseFile( contents, elem, attr, val, eleValue ) {
        const elementText = 'aw-i18n';
        htmlParser.parse( contents, {
            openElement: name2 => {
                elem.push( name2 );
            },
            attribute: ( name2, value ) => {
                attr.push( name2 );
                val.push( value );
            },
            text: value => {
                if( elem.length > 0 &&
                    elem[ elem.length - 1 ].search( elementText ) > -1 &&
                    value.search( '[a-z0-9A-Z]' ) > -1 ) {
                    eleValue.push( value );
                }
            }
        } );
    }

    /**
     * Transform each file in the stream before flush function is called.
     *
     * @param {File} file - stream file
     * @param {Function} cbTransform - callback to be call after transform is complete
     */
    function transform( file, ignore, cbTransform ) {
        const contents = file.contents.toString();
        const issues = {
            errors: [],
            warnings: []
        };
        _.forEach( scaCache.required, ( conditions, fileExt ) => {
            if( file.path.search( fileExt ) > -1 ) {
                _.forEach( conditions, ( msg, pattern ) => {
                    if( contents.search( pattern ) === -1 ) {
                        // add issue into map (file -> issues) for better reporting
                        issues.errors.push( msg );
                    }
                } );
            }
        } );
        _.forEach( scaCache.antiPatterns, ( conditions, fileExt ) => {
            if( file.path.search( fileExt ) > -1 ) {
                _.forEach( conditions, ( msg, pattern ) => {
                    const patternFound = contents.search( pattern );
                    if( patternFound > -1 ) {
                        // Check if there are exceptions specified for the anti pattern.
                        let message = '';
                        let relativeFilePath = '';
                        if( msg.exceptions ) {
                            message = msg.message;
                            const cwd = normalizePath( file._cwd );
                            const fullPath = normalizePath( file.path );
                            relativeFilePath = fullPath.substr( cwd.length + 1 );
                        } else {
                            message = msg;
                        }
                        // Get the full line which contains the anti pattern.
                        // search for the new line character backwards and forwards
                        // to get the begining and the end of the line.
                        const bolIdx = contents.lastIndexOf( '\n', patternFound );
                        const eolIdx = contents.indexOf( '\n', patternFound );
                        if( bolIdx > -1 && eolIdx > -1 && eolIdx > bolIdx ) {
                            const line = contents.substring( bolIdx, eolIdx );
                            if( !/^(#|\*|\/\/)/.test( line.trim() ) ) { // ignore comments
                                if( msg.exceptions && msg.exceptions.includes( relativeFilePath ) ) {
                                    issues.warnings.push( message + '\n\t\t' + line );
                                } else {
                                    issues.errors.push( message + '\n\t\t' + line );
                                }
                            }
                        } else {
                            // add issue into map (file -> issues) for better reporting
                            if( msg.exceptions && msg.exceptions.includes( relativeFilePath ) ) {
                                issues.warnings.push( message );
                            } else {
                                issues.errors.push( message );
                            }
                        }
                    }
                } );
            }
        } );

        _.forEach( scaCache.localeServiceI18n, ( conditions, fileExt ) => {
            if( file.path.search( fileExt ) > -1 ) {
                _.forEach( conditions, ( msg, pattern ) => {
                    const patternFound = contents.search( pattern );
                    if( patternFound > -1 && isApollo ) {
                        // Get the full line which contains the anti pattern.
                        // search for the new line character backwards and forwards
                        // to get the begining and the end of the line.
                        const bolIdx = contents.lastIndexOf( '\n', patternFound );
                        const eolIdx = contents.indexOf( '\n', patternFound );
                        if( bolIdx > -1 && eolIdx > -1 && eolIdx > bolIdx ) {
                            const line = contents.substring( bolIdx, eolIdx );
                            if( !/^(#|\*|\/\/)/.test( line.trim() ) ) { // ignore comments
                                if( _strictMode ) {
                                    issues.errors.push( msg + '\n\t\t' + line );
                                } else {
                                    issues.warnings.push( msg + '\n\t\t' + line );
                                }
                            }
                        } else {
                            // add issue into map (file -> issues) for better reporting
                            if( _strictMode ) {
                                issues.errors.push( msg );
                            } else {
                                issues.warnings.push( msg );
                            }
                        }
                    }
                } );
            }
        } );

        //Do deprecated soa validations
        if( file.path.search( /\.(js|json)$/ ) ) {
            _.forEach( scaCache.deprecatedSOAList, ( soaInfo ) => {
                let patternFound = false;
                if( file.extname === '.js' ) {
                    var regex = new RegExp( `\\b${soaInfo.serviceName}\\b.*\\b${soaInfo.method}\\b`, 'm' );
                    patternFound = regex.test( contents );
                } else if( file.extname === '.json' ) {
                    const json = JSON.parse( contents );
                    _.forEach( json.actions, ( action ) => {
                        if( action.actionType === 'TcSoaService' &&
                            action.serviceName === soaInfo.serviceName &&
                            action.method === soaInfo.method ) {
                            patternFound = true;
                        }
                    } );
                }
                if( patternFound ) {
                    let message = '';
                    let relativeFilePath = '';
                    message = soaInfo.serviceName + '/' + soaInfo.method + ' is a deprecated SOA' + ', instead use ' + soaInfo.replacedWith;
                    if( soaInfo.exceptions ) {
                        const cwd = normalizePath( file._cwd );
                        const fullPath = normalizePath( file.path );
                        relativeFilePath = fullPath.substr( cwd.length + 1 );
                    }
                    // Get the full line which contains the soa name.
                    // search for the new line character backwards and forwards
                    // to get the begining and the end of the line.
                    const bolIdx = contents.lastIndexOf( '\n', patternFound );
                    const eolIdx = contents.indexOf( '\n', patternFound );
                    if( bolIdx > -1 && eolIdx > -1 && eolIdx > bolIdx ) {
                        const line = contents.substring( bolIdx, eolIdx );
                        if( !/^(#|\*|\/\/)/.test( line.trim() ) ) { // ignore comments
                            if( soaInfo.exceptions && soaInfo.exceptions.includes( relativeFilePath ) ) {
                                issues.warnings.push( message + '\n\t\t' + line );
                            } else {
                                issues.errors.push( message + '\n\t\t' + line );
                            }
                        }
                    } else {
                        // add issue into map (file -> issues) for better reporting
                        if( soaInfo.exceptions && soaInfo.exceptions.includes( relativeFilePath ) ) {
                            issues.warnings.push( message );
                        } else {
                            issues.errors.push( message );
                        }
                    }
                }
            } );
        }

        //Do beyond angular validations
        const filePattern = '(\\\\|/)[\\s\\S]*\\.js$';
        if( file.path.search( filePattern ) > -1 ) {
            //Check for app.getInjector
            //If the file is service or unit test
            const filePath = file.path;
            if( /app\.(factory|service)/.test( contents ) ||
                /[\s\S]*Test\.js$/.test( filePath ) ) {
                if( ( !scaCache.getInjectionUsageWhiteListWhiteList ||
                        !_.find( scaCache.getInjectionUsageWhiteList, fileName => filePath.includes( fileName ) ) ) &&
                    /app\.getInjector\(\)/.test( contents ) ) {
                    issues.errors.push( 'Dont use app.getInjector (), Use ES6 import instead' );
                }

                if( /[\s\S]*Test\.js$/.test( filePath ) ) {
                    //Check inject
                    if( ( !scaCache.injectUsageWhiteList ||
                            !_.find( scaCache.injectUsageWhiteList, fileName => filePath.includes( fileName ) ) ) &&
                        /\binject\b\(/.test( contents ) ) {
                        issues.errors.push( 'Dont use inject in test, Use ES6 import instead' );
                    }

                    //Check module
                    if( ( !scaCache.moduleUsageWhiteList ||
                            !_.find( scaCache.moduleUsageWhiteList, fileName => filePath.includes( fileName ) ) ) &&
                        /module\([\s]*function\([\s\S]*\)/.test( contents ) ) {
                        issues.errors.push( 'Dont use module in test, use spyOn instead' );
                    }
                }
            }
        }

        // only check copyright header for Siemens PLM developers and not for kitted environment
        if( scaCache.copyright &&
            /\.(css|java|scss|xml)$/.test( file.path ) ) {
            if( !scaCache.copyrightRegExp ) {
                scaCache.copyrightRegExp = [];
                for( const copyright of scaCache.copyright ) {
                    scaCache.copyrightRegExp.push( new RegExp( copyright ) );
                }
            }
            let found = false;
            for( const copyright of scaCache.copyrightRegExp ) {
                if( copyright.test( contents ) ) {
                    found = true;
                    break;
                }
            }
            if( !found ) {
                // Failed to find the preferred copyright header, check "old style"
                let msg = 'Copyright header missing! Expected ';
                const year = new Date().getFullYear();
                if( /\.(css|scss)$/.test( file.path ) ) {
                    msg += `/* Copyright (c) ${year} Siemens */`;
                } else {
                    msg += `// Copyright (c) ${year} Siemens`;
                }
                issues.errors.push( msg );
            }
        }

        if( /\.directive\.js$/.test( file.path ) ) {
            // find all those directive file which doesn't have a schema file to it
            const schemaFilePath = join( dirname( dirname( file.path ) ), 'schema', basename( file.path, '.directive.js' ) + '.xsd' );
            if( !existsSync( schemaFilePath ) ) {
                var elementName = basename( file.path, '.directive.js' );
                if( !isApollo ) {
                    issues.warnings.push( 'Schema not found for ' + shortenPath( normalizePath( file.path ) ) );
                } else {
                    if( scaCache.elementWithoutSchemaDefWhiteList &&
                        scaCache.elementWithoutSchemaDefWhiteList.includes( elementName ) ) {
                        issues.warnings.push( 'Schema not found for ' + shortenPath( normalizePath( file.path ) ) );
                    } else {
                        issues.errors.push( 'Schema not found for ' + shortenPath( normalizePath( file.path ) ) );
                    }
                }
            }
        }

        if( /\.java$/.test( file.path ) ) {
            processJava( file, contents, issues );
        } else if( /\.js$/.test( file.path ) ) {
            if( cache && cache.audit && cache.audit.filePath2fileInfo ) {
                const filePath = normalizePath( file.path );
                const fileInfo = cache.audit.filePath2fileInfo[ filePath ];
                processJavaScript( file, fileInfo, issues );
                processDynamicCompoundProperties( file, contents, issues );
                if( /test(\/|\\)\S*Test\.js$/.test( file.path ) ) {
                    //processUnitTestsDescribe( file, fileInfo, issues );
                } else {
                    processJavaScriptI18nUsage( file, fileInfo, issues, cache.audit.i18n );
                }
            }
        } else if( /\bcommandsViewModel\b\.json$/.test( file.path ) ) {
            mergedCVMSchema = parseCmdAndSyncViewModel( file, contents, issues, 'declarativeCommandsViewModelSchema', mergedCVMSchema );
            parseBatchActionViewModel( file, contents, issues );
            processViewModelJsFunctionActions( file.path, issues );
            processCommandsViewModel( contents, issues );
            ensureViewModelI18nUsage( file, contents, issues, cache.audit.i18n );
            processViewModelI18nUsage( file, contents, issues, cache.audit.i18n );
        } else if( /\bsyncStrategy\b\.json$/.test( file.path ) ) {
            mergedSyncStrategySchema = parseCmdAndSyncViewModel( file, contents, issues, 'declarativeSyncStrategySchema', mergedSyncStrategySchema );
            processSyncStrategyViewModel( contents, issues );
            parseBatchActionViewModel( file, contents, issues );
            processViewModelJsFunctionActions( file.path, issues );
        } else if( /MockViewModel\.json$/.test( file.path ) ) {
            parseMockViewModel( file, contents, issues );
            processMockViewModelJson( file, contents, issues );
        } else if( /ViewModel\.json$/.test( file.path ) ) {
            parseViewModel( file, contents, issues );
            parseViewModelSPLMTable( file, contents, issues );
            processViewModelJson( file, contents, issues );
            parseBatchActionViewModel( file, contents, issues );
            processViewModelJsFunctionActions( file.path, issues );
            ensureViewModelI18nUsage( file, contents, issues, cache.audit.i18n );
            processViewModelI18nUsage( file, contents, issues, cache.audit.i18n );
        } else if( /\bworkspace_.*\b\.json$/.test( file.path ) && !/\bworkspace_contribution_.*\b\.json$/.test( file.path ) ) {
            parseWorkspace( file, contents, issues );
        } else if( /\bpaste\b\.json$/.test( file.path ) ) {
            validateConfigSchema( file, contents, issues, 'declarativePasteSchema' );
            processPasteViewModel( contents, issues );
            ensureViewModelI18nUsage( file, contents, issues, cache.audit.i18n );
        } else if( /\bdragAndDrop\b\.json$/.test( file.path ) ) {
            validateConfigSchema( file, contents, issues, 'declarativeDragAndDropSchema' );
            processDragAndDropJson( file, contents, issues );
            processViewModelJsFunctionActions( file.path, issues );
        } else if( /\bworkspace_contribution_.*\b\.json$/.test( file.path ) ) {
            parseWorkspaceContribution( file, contents, issues );
        } else if( /\bpropertyRendererTemplates\b\.json$/.test( file.path ) ) {
            parsePropertyRendererTemplates( file, contents, issues );
        } else if( /\bstates\b\.json$/.test( file.path ) ) {
            processStatesJsonI18nUsage( file, contents, issues, cache.audit.i18n );
        } else if( /\bsecondaryWorkareaTabs\b\.json$/.test( file.path ) ) {
            processSecondaryWorkareaTabsJsonI18nUsage( file, contents, issues, cache.audit.i18n );
        } else if( /\bdecorators\b\.json$/.test( file.path ) ) {
            processStatesJsonI18nUsage( file, contents, issues, cache.audit.i18n );
        }

        if( /\.(js|java)$/.test( file.path ) ) {
            processPropertyPolicyRegistrations( file, contents, issues );
        }

        if( /\.(css|scss|html|gif|jpg|jpeg|ai|bmp|svg)$/i.test( file.path ) ) {
            processForImageHandling( file, contents, issues );
        }

        if( /\bkit\b\.json$/.test( file.path ) ) {
            const jsonObject = JSON.parse( contents );
            if( jsonObject.solutionDef ) {
                processForViewAndViewModelRepoConfiguration( jsonObject, issues );
                validateImageRepositoryConfiguration( jsonObject, issues );
                validateDefaultPasteHandlerConfiguration( jsonObject, issues );
                validateDefaultDragAndDropHandlers( jsonObject, issues );
            }
        }

        if( _strictMode && /\.(js|html)$/.test( file.path ) ) {
            processUiGridUsage( file, contents, issues );
            processPLTableInDirectiveUsage( file, contents, issues );
        }

        if( /\.html/.test( file.path ) ) {
            processFilesHaveHTMLSelfClosedTag( file, contents, issues );
            processHTMLFilesForIdUsage( file, contents, issues );
            processHTMLFilesForImageAltAttributeUsage( file, contents, issues );
        }

        if( /View.html$/.test( file.path ) ) {
            processViewHTML( file, contents, issues ).then( () => {
                localVars.file2issues[ file.path ] = issues;
                cbTransform();
            } ).catch( logger.pipeErrorHandler );
        } else {
            localVars.file2issues[ file.path ] = issues;
            cbTransform();
        }
    }

    /**
     * Method to find if the attribute value which fit the regular expression exists in the view model.
     *
     * @param {expression} reg - regular expression.
     * @param {Array} value - the value of the attributes in the file.
     * @param {Object} jsonContent - the file contents
     * @param {String} viewModelName - the file name
     * @param {Object} issues - issues
     * @param {String} htmlContents - HTML contents
     */
    function testAttribute( reg, value, jsonContent, viewModelName, issues, htmlContents ) {
        if( reg.test( value ) ) {
            const elemValue = value.split( '.' );
            let isSubPanelContext = elemValue[ 0 ] === 'subPanelContext';
            if( isSubPanelContext ) {
                return true;
            }
            const elemObjectVal = elemValue[ elemValue.length - 1 ];
            const elemObject = elemValue[ elemValue.length - 2 ];
            for( const contentJson in jsonContent ) {
                if( contentJson === elemObject ) {
                    let flagElem = false;
                    for( const contentElem in jsonContent[ contentJson ] ) {
                        if( contentElem === elemObjectVal ) {
                            flagElem = true;
                            break;
                        }
                    }
                    if( flagElem ) {
                        break;
                    } else {
                        const lineNumber = getLineNumber( htmlContents, value, 0 );
                        issues.warnings.push(
                            'Attribute \"' +
                            value + '\"' + ' at line number ' + lineNumber +
                            ', doesn\'t exist in the ' + '\"' +
                            elemObject + '\"' + ' section of the file ' + viewModelName +
                            '\n'
                        );
                    }
                }
            }
        }
    }

    /**
     * @param {Object} json - json Object
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processForViewAndViewModelRepoConfiguration( json, issues ) {
        let error = null;
        if( json.viewAndViewModelRepoConfiguration && json.viewAndViewModelRepoConfiguration.actionType ) {
            const viewAndViewModelRepoConfiguration = json.viewAndViewModelRepoConfiguration;
            if( viewAndViewModelRepoConfiguration.actionType === 'GET' ||
                viewAndViewModelRepoConfiguration.actionType === 'RESTService' ||
                viewAndViewModelRepoConfiguration.actionType === 'TcSoaService' ) {
                if( viewAndViewModelRepoConfiguration.actionType === 'GET' ) {
                    if( viewAndViewModelRepoConfiguration.viewUrl === undefined || viewAndViewModelRepoConfiguration.viewUrl === null ||
                        viewAndViewModelRepoConfiguration.viewModelUrl === undefined || viewAndViewModelRepoConfiguration.viewModelUrl === null ) {
                        error = 'The mandatory attributes \'viewUrl\' and/or \'viewModelUrl\' are not specified in configuration \'viewAndViewModelRepoConfiguration\' in solution JSON';
                    }
                } else {
                    if( viewAndViewModelRepoConfiguration.inputData === undefined || viewAndViewModelRepoConfiguration.inputData === null ) {
                        error = 'The mandatory attribute \'inputData\' is not specified in configuration \'viewAndViewModelRepoConfiguration\' in solution JSON';
                    } else if( viewAndViewModelRepoConfiguration.inputData.panelId === undefined || viewAndViewModelRepoConfiguration.inputData.panelId === null ) {
                        error = 'The mandatory attribute \'panelId\' is not specified in \'inputData\' section of configuration \'viewAndViewModelRepoConfiguration\' in solution JSON';
                    } else if( viewAndViewModelRepoConfiguration.outputData === undefined || viewAndViewModelRepoConfiguration.outputData === null ) {
                        error = 'The mandatory attribute \'outputData\' is not specified in configuration \'viewAndViewModelRepoConfiguration\' in solution JSON';
                    } else if( viewAndViewModelRepoConfiguration.actionType === 'RESTService' && ( viewAndViewModelRepoConfiguration.url === undefined || viewAndViewModelRepoConfiguration.url ===
                            null ) ) {
                        error = 'The mandatory attribute \'url\' is not specified in configuration \'viewAndViewModelRepoConfiguration\' in solution JSON';
                    } else if( viewAndViewModelRepoConfiguration.actionType === 'TcSoaService' && ( viewAndViewModelRepoConfiguration.serviceName === undefined || viewAndViewModelRepoConfiguration
                        .serviceName === null ) ) {
                        error = 'The mandatory attribute \'service\' is not specified in configuration \'viewAndViewModelRepoConfiguration\' in solution JSON';
                    } else if( viewAndViewModelRepoConfiguration.actionType === 'TcSoaService' && ( viewAndViewModelRepoConfiguration.method === undefined || viewAndViewModelRepoConfiguration.method ===
                            null ) ) {
                        error = 'The mandatory attribute \'method\' is not specified in configuration \'viewAndViewModelRepoConfiguration\' in solution JSON';
                    }
                }
            } else {
                error = 'Invalid value for attribute \'actionType\' in configuration \'viewAndViewModelRepoConfiguration\' in solution JSON';
            }
        }

        if( error !== null ) {
            issues.errors.push( error );
        }
    }

    /**
     * Validate image repository configuration provided in solution kit.
     *
     * @param {Object} json - the json object
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function validateImageRepositoryConfiguration( json, issues ) {
        let error = '';
        if( !json.imageRepositoryConfiguration ) {
            error =
                'Missing mandatory configuration \'imageRepositoryConfiguration\' in solution configuration. It should have below format: \n "imageRepositoryConfiguration":{\n\t\t "actionType":"GET",\n\t\t "url":"<url>"\n\t\t }';
        } else {
            if( !json.imageRepositoryConfiguration.actionType ) {
                error = 'Missing mandatory attribute \'actionType\' of \'imageRepositoryConfiguration\' in solution JSON. ';
            } else if( json.imageRepositoryConfiguration.actionType !== 'GET' ) {
                error = 'Invalid value of \'actionType\' in configuration \'imageRepositoryConfiguration\' in solution JSON. \'' + json.imageRepositoryConfiguration.actionType + '\' is not supported. ';
            }
            if( !json.imageRepositoryConfiguration.url ) {
                error = error.concat( 'Missing mandatory attribute \'url\' of \'imageRepositoryConfiguration\' in solution JSON.' );
            }
        }
        if( error.length > 0 ) {
            issues.errors.push( error );
        }
    }

    /**
     * Validate default PasteHandler Configuration provided in solution kit.
     *
     * @param {Object} json - the json object
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function validateDefaultPasteHandlerConfiguration( json, issues ) {
        let error = '';
        if( json.defaultPasteHandlerConfiguration ) {
            if( !json.defaultPasteHandlerConfiguration.bestTargetFitFinder ) {
                error = 'Missing mandatory attribute \'bestTargetFitFinder\' of \'defaultPasteHandlerConfiguration\' in solution JSON. ';
            }
            if( !json.defaultPasteHandlerConfiguration.bestSourceFitFinder ) {
                error = 'Missing mandatory attribute \'bestSourceFitFinder\' of \'defaultPasteHandlerConfiguration\' in solution JSON. ';
            }
            if( !json.defaultPasteHandlerConfiguration.pasteHandler ) {
                error = 'Missing mandatory attribute \'pasteHandler\' of \'defaultPasteHandlerConfiguration\' in solution JSON. ';
            }
            if( !json.defaultPasteHandlerConfiguration.deps ) {
                error = error.concat( 'Missing mandatory attribute \'deps\' of \'defaultPasteHandlerConfiguration\' in solution JSON.' );
            }
        }
        if( error.length > 0 ) {
            issues.errors.push( error );
        }
    }

    /**
     * Validate default drag and drop Configuration provided in solution kit.
     *
     * @param {Object} json - the json object
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function validateDefaultDragAndDropHandlers( json, issues ) {
        let error = '';
        if( json.defaultDragAndDropHandlers ) {
            if( !json.defaultDragAndDropHandlers.dragHandler ) {
                error = 'Missing mandatory attribute \'dragHandler\' of \'defaultDragAndDropHandlers\' in solution JSON. ';
            }
            if( !json.defaultDragAndDropHandlers.dropHandler ) {
                error = 'Missing mandatory attribute \'dropHandler\' of \'defaultDragAndDropHandlers\' in solution JSON. ';
            }
        }
        if( error.length > 0 ) {
            issues.errors.push( error );
        }
    }

    /**
     * Method to process *MockViewModel.json files.
     *
     * @param {File} file - the json file
     * @param {String} contents - the file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processMockViewModelJson( file, contents, issues ) {
        if( !dirname( file.path ).endsWith( 'viewmodel' + sep + 'mocks' ) ) {
            issues.errors.push( '*MockViewModel.json files must reside in "viewmodel' + sep + 'mocks" directory (case sensitve)' );
        }
        const viewModelName = basename( file.path, 'MockViewModel.json' );
        const regularViewModel = dirname( file.path ).replace( /mocks/g, '' ) + viewModelName + 'ViewModel.json';
        if( !existsSync( regularViewModel ) ) {
            issues.errors.push( 'there is no corresponding "' + viewModelName + 'ViewModel.json" file for ' +
                parse( file.path ).name );
        } else {
            const mockViewModelContents = JSON.parse( contents );
            const regularViewModelContents = readJsonSync( regularViewModel );
            // Check dataProvider names are same in both xxxViewModel.json and xxxMockViewModel.json
            Object.keys( mockViewModelContents.mock.dataProviders ).forEach( function( dpName ) {
                if( !regularViewModelContents.dataProviders[ dpName ] ) {
                    issues.errors.push( 'there is no corresponding dataProvider with name "' + dpName + '" in your regular ViewModel "' + viewModelName + 'ViewModel.json" file' );
                }
            } );
            if( mockViewModelContents.mock.columnProviders ) {
                // Check columnProvider names are same in both xxxViewModel.json and xxxMockViewModel.json
                Object.keys( mockViewModelContents.mock.columnProviders ).forEach( function( colProviderName ) {
                    if( !regularViewModelContents.columnProviders[ colProviderName ] ) {
                        issues.errors.push( 'there is no corresponding columnProvider with name "' + colProviderName + '" in your regular ViewModel "' + viewModelName + 'ViewModel.json" file' );
                    }
                } );
            }
        }
    }

    /**
     * Method to process *ViewModel.json files.
     *
     * @param {File} file - the json file
     * @param {String} contents - the file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processViewModelJson( file, contents, issues ) {
        if( !dirname( file.path ).endsWith( 'viewmodel' ) ) {
            issues.errors.push( '*ViewModel.json files must reside in a "viewmodel" directory (case sensitve)' );
        }
        const jsonContents = JSON.parse( contents );
        const filePath = dirname( dirname( file.path ) ); // find the path of src/
        const fileName = shortenPath( normalizePath( file.path ) );
        const viewPath = filePath + '/' + 'html';

        if( !jsonContents.lifecycleHooks?.render  ) {
            try {
                const stats = statSync( normalizePath( viewPath ) );
                if( stats.isDirectory() ) {
                    const childrenView = readdirSync( viewPath );
                    let viewHtml = null;
                    let viewName = null;
                    for( const childFile of childrenView ) {
                        const tmp = parse( file.path ).name;
                        const nameIndex = tmp.search( childFile.substring( 0, childFile.length - 5 ) );
                        if( nameIndex === 0 ) {
                            viewHtml = viewPath + '/' + childFile;
                            viewName = childFile;
                        }
                    }
                    if( viewName ) {
                        const htmlContents = readFileSync( viewHtml ).toString();
                        const elemH = [];
                        const attrH = [];
                        const valH = [];
                        const textValue = [];
                        parseFile( htmlContents, elemH, attrH, valH, textValue );
                        let jsonAction = null; // used to store 'actions' object
                        let jsonProvider = null; // used to store 'dataProviders' object
                        let jsonLifecycleHooks = null; // used to store 'lifecycleHooks' object
                        let jsonOnEvent = null;
                        const actionArr = []; // used to store the action names from the viewmodel file
                        let vmBaseName = basename( file.path, 'ViewModel.json' );
                        for( const obJson in jsonContents ) {
                            if( obJson === objImport ) {
                                const jsonImport = jsonContents[ obJson ];
                                for( let impNx = 0; impNx < jsonImport.length; impNx++ ) {
                                    for( let eleNx = 0; eleNx < elemH.length; eleNx++ ) {
                                        if( jsonImport[ impNx ].includes( elemH[ eleNx ] ) ) {
                                            break;
                                        } else if( !jsonImport[ impNx ].includes( elemH[ eleNx ] ) && eleNx === elemH.length - 1 ) {
                                            for( let arrNx = 0; arrNx < attrH.length; arrNx++ ) {
                                                if( jsonImport[ impNx ].includes( attrH[ arrNx ] ) ) {
                                                    break;
                                                } else if( !jsonImport[ impNx ].includes( attrH[ arrNx ] ) && arrNx === attrH.length - 1 ) {
                                                    const lineNumber = getLineNumber( contents, jsonImport[ impNx ], 0 );
                                                    issues.warnings.push( 'Unnecessary import \'' + jsonImport[ impNx ] + '\' at line ' + lineNumber );
                                                }
                                            }
                                        }
                                    }
                                }
                            } else if( obJson === objActions ) {
                                jsonAction = jsonContents[ obJson ];
                            } else if( obJson === objProviders ) {
                                jsonProvider = jsonContents[ obJson ];
                            } else if( obJson === objLifecycleHooks ) {
                                jsonLifecycleHooks = jsonContents[ obJson ];
                                for( const jsonHook in jsonLifecycleHooks ) {
                                    if( supportedHooks.includes( jsonHook ) ) {
                                        actionArr.push( jsonLifecycleHooks[ jsonHook ] );
                                    }
                                }
                            } else if( obJson === objOnEvent ) {
                                jsonOnEvent = jsonContents[ obJson ];
                                for( const jsonEvent in jsonOnEvent ) {
                                    let eventId = jsonOnEvent[ jsonEvent ].eventId;
                                    for( const depEvent in deprecatedEvents ) {
                                        if( eventId === vmBaseName + Object.keys( deprecatedEvents[ depEvent ] )[ 0 ] ) {
                                            issues.warnings.push(
                                                eventId +
                                            ' : \n@deprecated SWF4.1, The <viewName>' + Object.keys( deprecatedEvents[ depEvent ] )[ 0 ] +
                                            ' event is deprecated. \n@alternative ViewModel Construct - ' + Object.values( deprecatedEvents[ depEvent ] )[ 0 ] +
                                            '. Refer to “ViewModel Lifecycle Hooks” API documentation for details. \n@obsoleteIn SWF5.0'
                                            );
                                        }
                                    }
                                }
                            } else {
                                const jsonAttr = jsonContents[ obJson ];
                                for( const jsonNx in jsonAttr ) {
                                    const jsonAttrTmp = jsonAttr[ jsonNx ];
                                    for( const jsonAttrNx in jsonAttrTmp ) {
                                        if( jsonAttrNx === attrAction ) {
                                            actionArr.push( jsonAttrTmp[ jsonAttrNx ] );
                                        }
                                    }
                                }
                            }
                        }
                        for( let i = 0; i < actionArr.length; i++ ) {
                            let jsonActionFlag = false;
                            // actions in the viewModel can in the actions section and dataProviders section
                            for( let actionObj in jsonAction ) {
                                if( actionObj === actionArr[ i ] ) {
                                    jsonActionFlag = true;
                                    break;
                                }
                            }
                            for( const providerObj in jsonProvider ) {
                                if( providerObj === actionArr[ i ] ) {
                                    jsonActionFlag = true;
                                    break;
                                }
                            }
                            if( !jsonActionFlag ) { // don't find the action name in the "acions" object in view model file
                                const lineNumber = getLineNumber( htmlContents, actionArr[ i ], 0 );
                                issues.warnings.push(
                                    'the action : \"' + actionArr[ i ] + '\" at line number ' + lineNumber +
                                ' doesn\'t exists in the \"' + 'actions\"' + ' object of the file : ' + parse( fileName ).name
                                );
                            }
                        }
                    } else {
                        issues.warnings.push( 'there is no corresponding html file for ' + parse( fileName ).name );
                    }
                }
            } catch ( e ) {
                // throw err;
                issues.warnings.push( 'there is no corresponding html file directory ' +  normalizePath( viewPath ) + ' for ' + parse( fileName ).name );
            }
        }
    }

    /**
     * Method to process JS Function dependencies found in *ViewModel.json files.
     *
     * @param {String} contents - contents of the View Model file being processed
     * @param {Object} fileInfo - see pre_audit_prep
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processViewModelJsFunctionActions( filePath, issues ) {
        if( /\/solutions\/showcase\//.test( filePath ) ) {
            return;
        }

        const dependencyFound = ( jsFileInfo, method ) => {
            if( jsFileInfo.returnExportsFound && jsFileInfo.exportedJsMethods &&
                jsFileInfo.exportedJsMethods.includes( method ) ) {
                return true;
            }

            if( jsFileInfo.publishedJsMethods && jsFileInfo.publishedJsMethods.includes( method ) ) {
                return true;
            }

            if( jsFileInfo.asyncJSMethods && jsFileInfo.asyncJSMethods.includes( method ) ) {
                return true;
            }

            return false;
        };

        if( cache && cache.audit && cache.audit.filePath2fileInfo ) {
            const fileInfo = cache.audit.filePath2fileInfo[ normalizePath( filePath ) ];
            if( fileInfo && fileInfo.jsFunctions && fileInfo.jsFunctions.length > 0 ) {
                _.forEach( fileInfo.jsFunctions, jsFunc => {
                    const actionName = jsFunc.actionName;
                    const method = jsFunc.method;
                    const moduleName = jsFunc.moduleName;
                    const jsFileInfos = cache.audit.dep2fileInfo[ moduleName ];

                    const errMsg = jsFunc.actionType === 'ctxParser' ? 'Derived state parser "' + actionName + '"\n' :
                        'Action "' + actionName + '" of type "' + jsFunc.actionType + '"\n';


                    if( jsFileInfos ) {
                        let found = false;
                        for( const jsFileInfo of jsFileInfos ) {
                            if( dependencyFound( jsFileInfo, method ) ) {
                                found = true;
                                break;
                            }
                        }
                        if( !found ) {
                            let msg = errMsg + '  calls method "' + method + '" which is not exposed by \"' + moduleName + '"\n';
                            if( scaCache.actionInJSWhitelist && scaCache.actionInJSWhitelist[ moduleName ] && scaCache.actionInJSWhitelist[ moduleName ].includes( method ) ) {
                                issues.warnings.push( msg );
                            } else {
                                issues.errors.push( msg );
                            }
                        }
                    } else if( !thirdPartyLibList.includes( moduleName ) ) {
                        let msg = errMsg + '  references module "' + moduleName + '" that does not exist.\n';
                        issues.errors.push( msg );
                    }
                } );
            } else {
                trace( 'Either fileInfo or fileInfo.jsFunctions not populated in cache for', filePath );
            }
        }
    }

    /**
     * Method to process *View.html files.
     *
     * @param {File} file - the html file
     * @param {String} contents - the file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     * @return {Promise} promise
     */
    function processViewHTML( file, contents, issues ) {
        const awListArray = [];
        const cssClassArray = [];
        const ngDirectiveArray = [];
        const oldUsageOfCommandArray = [];

        for( const line of logger.extractLines( contents ) ) {
            if( line.match( '<aw-list ' ) ) {
                awListArray.push( line );
            }

            if( /\sstyle\s*=/i.test( line ) ) {
                cssClassArray.push( line );
            }
            const searchNgPattern = /(?:^|[ ])ng-([a-zA-Z]+)/gm;
            if( searchNgPattern.test( line ) ) {
                ngDirectiveArray.push( line );
            }
        }

        _.forEach( awListArray, ( listLine, index ) => {
            // Please be aware that if multiple lists are used in View HTML file,
            // then only one list can be set to fixed-cell-height and it must be the bottom most list.
            // If a use-virtual usage is found report an error.
            if( index !== awListArray.length - 1 &&
                listLine.match( 'fixed-cell-height' ) ) {
                issues.errors.push( 'Using aw-list incorrectly in ' + file.path + '. fixed-cell-height should be on the last line.' );
            }
            if( listLine.match( 'use-virtual' ) ) {
                issues.errors.push( 'Using aw-list incorrectly in ' + file.path + '. use-virtual should no longer be used.' );
            }
        } );

        const fileName = file.path.split( '\\' ).pop().split( '/' ).pop();
        const oldUsageOfCommandPattern = /<aw-command[^>]*\scommands\s?=\s?/gm;
        const oldUsageOfCmdPatternPopup = /<aw-popup[^>]*\scommands\s?=\s?/gm;
        if( oldUsageOfCommandPattern.test( contents ) || oldUsageOfCmdPatternPopup.test( contents ) ) {
            oldUsageOfCommandArray.push( fileName );
        }
        _.forEach( oldUsageOfCommandArray, fileName2 => {
            const msg1 = `Old pattern of command is used in ${fileName2} Please use zero compile commands. \n`;
            if( scaCache.disallowOldUsageOfCommandReferences ) {
                issues.errors.push( msg1 );
            } else {
                issues.warnings.push( msg1 );
            }
        } );

        _.forEach( cssClassArray, listLine => {
            const lineNumber = getLineNumber( contents, listLine, 0 );
            const msg1 = 'Use of CSS style attribute in ' + fileName + ' (line:' + lineNumber + ')\n    ' +
                listLine.trim() + ')\n  ' +
                'No CSS style attribute is allowed in Declarative View html. \n';

            if( scaCache.viewFileWhiteList &&
                scaCache.viewFileWhiteList.cssReferences &&
                scaCache.viewFileWhiteList.cssReferences.includes( fileName ) ) {
                // In white list, issue warning
                issues.warnings.push( msg1 );
            } else {
                // Not in white list, issue error if in strict mode, warning otherwise
                if( _strictMode ) {
                    issues.errors.push( msg1 );
                } else {
                    issues.warnings.push( msg1 );
                }
            }
        } );

        _.forEach( ngDirectiveArray, listLine => {
            const lineNumber = getLineNumber( contents, listLine, 0 );
            const msg1 = 'Use of Angular-ism in ' + fileName + ' (line:' + lineNumber + ')\n    ' +
                listLine.trim() + '\n  ' +
                'No reference to Angular is allowed in Declarative View html.\n';

            if( scaCache.viewFileWhiteList &&
                scaCache.viewFileWhiteList.ngDirectiveReferences &&
                scaCache.viewFileWhiteList.ngDirectiveReferences.includes( fileName ) ) {
                // In white list, issue warning
                issues.warnings.push( msg1 );
            } else {
                // Not in white list, issue error if in strict mode, warning otherwise
                if( _strictMode ) {
                    issues.errors.push( msg1 );
                } else {
                    issues.warnings.push( msg1 );
                }
            }
        } );

        // const fileName = shortenPath( normalizePath( file.path ) );
        const viewModelPath = join( dirname( dirname( file.path ) ), 'viewmodel' ); // find the path of src/
        const elem = [];
        const attr = [];
        const val = [];
        const text = [];
        let flagText = false;
        parseFile( contents, elem, attr, val, text );
        // find the corresponding viewModel
        const childrenViewModel = readdirSync( viewModelPath );
        // returns the array of filenames
        let viewModel = null;
        let viewModelName = null;
        const viewFileName = parse( file.path ).name;
        for( let ii = 0; ii < childrenViewModel.length; ii++ ) {
            if( childrenViewModel[ ii ].search( viewFileName ) > -1 ) {
                viewModel = viewModelPath + '/' + childrenViewModel[ ii ];
                // find the corresponding view model file
                viewModelName = childrenViewModel[ ii ];
            }
        }
        if( viewModel === null ) {
            // if don't have the same name view model, then raise an error.
            issues.warnings.push( 'Doesn\'t have the corresponding viewmodel: ' +
                viewModelName + ', the viewmodel name don\'t fit the standard' );
        } else {
            const viewModelContents = readFileSync( normalizePath( viewModel ) ).toString();
            const jsonContent = JSON.parse( viewModelContents );
            for( let j = 0; j < elem.length; j++ ) {
                // validate if the text in aw-i18n is exists and localized
                if( elem[ j ].search( 'aw-i18n' ) > -1 && text && !flagText ) { // has the aw-i18n element
                    for( let txtInx = 0; txtInx < text.length; txtInx++ ) {
                        processViewI18nUsage( text, txtInx, contents, elem, j, viewFileName, issues );
                        testAttribute( /^\w*\.+\w*\.*\w*$/, text[ txtInx ], jsonContent, viewModelName, issues, contents );
                    }
                    flagText = true;
                }
            }
            // find if the attribute is "action"
            for( let attInx = 0; attInx < attr.length; attInx++ ) {
                if( attr[ attInx ].search( attrAction ) > -1 ) {
                    let flagAction = false;
                    for( const attrJson in jsonContent ) {
                        // the action supports 'actions' and 'dataProviders' to set the value
                        if( attrJson === objActions || attrJson === objProviders ) {
                            if( attrJson === objActions ) {
                                for( const actionNdx in jsonContent.actions ) {
                                    if( actionNdx === val[ attInx ] ) {
                                        flagAction = true;
                                        break;
                                    }
                                }
                            } else if( attrJson === objProviders ) {
                                for( const provNdx in jsonContent.dataProviders ) {
                                    if( provNdx === val[ attInx ] ) {
                                        flagAction = true;
                                        break;
                                    }
                                }
                            }
                            if( flagAction ) {
                                break;
                            }
                        }
                    }
                    if( !flagAction ) {
                        // throw new Error
                        const lineNumber = getLineNumber( contents, val[ attInx ], 0 );
                        issues.warnings.push( 'Action \"' + val[ attInx ] + '\" at line number ' + lineNumber +
                            ' not found in the file : ' + viewModelName );
                    }
                } else if( attr[ attInx ].search( attrProp ) > -1 ||
                    attr[ attInx ].search( attrCaption ) > -1 ||
                    attr[ attInx ].search( attrProvider ) > -1 ) {
                    // find if the attribute is one of "prop","caption","visible-when","dataprovider"
                    testAttribute( /^\w*\.+\w*\.*\w*$/, val[ attInx ], jsonContent, viewModelName, issues, contents );
                }
            }
        }

        if( !_strictMode ) {
            scaCache.attributeAllowdInElements.complete.push( 'style' );
            scaCache.attributeAllowdInElements.complete.push( 'title' );
        }

        try {
            new XMLValidator( contents, issues ).validateXML();
        } catch ( err ) {
            issues.warnings.push( `xml2js parsing error:\n  ${err.toString()}` );
        }

        return Promise.resolve();
    }

    class XMLValidator {
        /**
         * @param {String} contents - XML file contents
         * @param {Object} issues - issues
         */
        constructor( contents, issues ) {
            this.trace = logger.createTrace( 'staticCodeAnalysis:XMLValidator' );

            this.xsdRef = {
                'declUI:schema': {
                    attr: [
                        'xmlns:declUI',
                        'elementFormDefault',
                        'attributeFormDefault',
                        'xmlns:xsB'
                    ],
                    children: [
                        'declUI:import',
                        'declUI:complexType',
                        'declUI:element'
                    ]
                },
                'declUI:import': {
                    attr: [
                        'namespace',
                        'schemaLocation'
                    ],
                    children: [],
                    func: ( state, schemaName, schema ) => {
                        state.imports.push( state.xsd[ schema.$.namespace ] );
                    }
                },
                'declUI:restriction': {
                    attr: [
                        'id',
                        'base'
                    ],
                    children: [],
                    func: ( state, schemaName, schema ) => {
                        if( schema.$ && schema.$.base ) {
                            const restriction = schema;
                            if( restriction.$.base === 'declUI:string' ) {
                                if( !_.isString( state.attrValue ) ) {
                                    this.trace( 'restriction', restriction );
                                    throw new Error( `Invalid attribute type ${restriction.$.type} for ${state.attrName} = ${state.attrValue}` );
                                }
                            } else {
                                this.trace( 'restriction', restriction );
                                throw new Error( `Unexpected restricted attribute type ${restriction.$.type} for ${state.attrName}` );
                            }
                        }
                    }
                },
                'declUI:simpleType': {
                    attr: [
                        'id',
                        'name'
                    ],
                    children: [
                        'declUI:restriction'
                    ]
                },
                'declUI:complexType': {
                    attr: [
                        'id',
                        'name',
                        'abstract',
                        'mixed',
                        'block',
                        'final'
                    ],
                    children: [
                        'declUI:anyAttribute',
                        'declUI:attribute',
                        'declUI:attributeGroup',
                        'declUI:complexContent',
                        'declUI:group'
                    ]
                },
                'declUI:element': {
                    attr: [
                        'id',
                        'name',
                        'ref',
                        'type',
                        'substitutionGroup',
                        'default',
                        'fixed',
                        'form',
                        'maxOccurs',
                        'minOccurs',
                        'nillable',
                        'abstract',
                        'block',
                        'final'
                    ],
                    children: [
                        'declUI:anyAttribute',
                        'declUI:attribute',
                        'declUI:attributeGroup',
                        'declUI:complexContent',
                        'declUI:complexType',
                        'declUI:group'
                    ],
                    func: ( state, schemaName, schema ) => {
                        if( schema.$ && schema.$.type ) {
                            let typeName = schema.$.type;
                            if( /:/.test( typeName ) ) {
                                typeName = typeName.split( ':' )[ 1 ];
                            }
                            let found = false;
                            if( state.schema[ 'declUI:complexType' ] ) {
                                for( const complexType of state.schema[ 'declUI:complexType' ] ) {
                                    if( typeName === complexType.$.name ) {
                                        this.validateAttribute( state, 'declUI:complexType', complexType );
                                        found = true;
                                    }
                                }
                            }
                            for( const importXsd of state.imports ) {
                                if( importXsd[ 'declUI:complexType' ] ) {
                                    for( const complexType of importXsd[ 'declUI:complexType' ] ) {
                                        if( typeName === complexType.$.name ) {
                                            this.validateAttribute( state, 'declUI:complexType', complexType );
                                            found = true;
                                        }
                                    }
                                }
                            }
                            if( !found ) {
                                throw new Error( `Unexpected type ${typeName} for ${state.attrName}` );
                            }
                        }
                    }
                },
                'declUI:group': {
                    attr: [
                        'id',
                        'name',
                        'ref',
                        'maxOccurs',
                        'minOccurs'
                    ],
                    children: [
                        'declUI:sequence'
                    ],
                    func: ( state, schemaName, schema ) => {
                        if( schema.$ && schema.$.ref ) {
                            const xx = schema.$.ref.split( ':' );
                            const subSchema = state.xsd[ state.schema.$[ 'xmlns:' + xx[ 0 ] ] ];
                            const groupName = xx[ 1 ];
                            if( subSchema[ schemaName ] ) {
                                for( const group2 of subSchema[ schemaName ] ) {
                                    if( group2.$.name === groupName &&
                                        this.validateAttribute( state, schemaName, group2 ) ) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                },
                'declUI:attribute': {
                    attr: [
                        'default',
                        'fixed',
                        'form',
                        'id',
                        'name',
                        'ref',
                        'type',
                        'use'
                    ],
                    children: [],
                    func: ( state, schemaName, schema ) => {
                        if( schema.$ && schema.$.name ) {
                            const attribute = schema;
                            if( !state.attributes.includes( attribute.$.name ) ) { state.attributes.push( attribute.$.name ); }
                            if( state.attrName === attribute.$.name ) {
                                if( attribute.$.use === 'prohibited' ) {
                                    this.trace( 'attribute', attribute );
                                    throw new Error( `Use of prohibited attribute ${attribute.$.name}` );
                                }
                                if( attribute.$.type ) {
                                    switch ( attribute.$.type ) {
                                        case 'declUI:string':
                                        case 'declUI:boolean':
                                            if( !_.isString( state.attrValue ) ) {
                                                this.trace( 'attribute', attribute );
                                                throw new Error( `Invalid attribute type ${attribute.$.type} for ${state.attrName} = ${state.attrValue}` );
                                            }
                                            break;
                                        default:
                                            this.trace( 'attribute', attribute );
                                            throw new Error( `Unexpected attribute type ${attribute.$.type} for ${state.attrName}` );
                                    }
                                }
                            }

                            // required?
                            if( attribute.$.use === 'required' &&
                                !state.requiredAttributes.includes( attribute.$.name ) ) {
                                state.requiredAttributes.push( attribute.$.name );
                            }
                        }
                    }
                },
                'declUI:attributeGroup': {
                    attr: [
                        'id',
                        'name',
                        'ref'
                    ],
                    children: [
                        'declUI:attribute'
                    ]
                },
                'declUI:complexContent': {
                    attr: [
                        'id',
                        'mixed'
                    ],
                    children: [
                        'declUI:extension'
                    ]
                },
                'declUI:extension': {
                    attr: [
                        'id',
                        'base'
                    ],
                    children: [
                        'declUI:sequence'
                    ],
                    func: ( state, schemaName, schema ) => {
                        if( schema.$ && schema.$.base ) {
                            let baseName = schema.$.base;
                            if( /:/.test( baseName ) ) {
                                baseName = baseName.split( ':' )[ 1 ];
                            }
                            let found = false;
                            if( state.schema[ 'declUI:complexType' ] ) {
                                for( const complexType of state.schema[ 'declUI:complexType' ] ) {
                                    if( baseName === complexType.$.name ) {
                                        this.validateAttribute( state, 'declUI:complexType', complexType );
                                        found = true;
                                    }
                                }
                            }
                            for( const importXsd of state.imports ) {
                                if( importXsd[ 'declUI:complexType' ] ) {
                                    for( const complexType of importXsd[ 'declUI:complexType' ] ) {
                                        if( baseName === complexType.$.name ) {
                                            this.validateAttribute( state, 'declUI:complexType', complexType );
                                            found = true;
                                        }
                                    }
                                }
                            }
                            if( !found ) {
                                throw new Error( `Unexpected base ${baseName} for ${state.attrName}` );
                            }
                        }
                    }
                },
                'declUI:sequence': {
                    attr: [
                        'id',
                        'maxOccurs',
                        'minOccurs'
                    ],
                    children: [
                        'declUI:any'
                    ]
                },
                'declUI:anyAttribute': {
                    attr: [
                        'id',
                        'namespace',
                        'processContents'
                    ],
                    children: [],
                    func: ( state, schemaName, schema ) => {
                        if( schema.$ && schema.$.processContents === 'lax' ) {
                            state.anyAttributeLax = true;
                        }
                    }
                },
                'declUI:any': {
                    attr: [
                        'id',
                        'maxOccurs',
                        'minOccurs',
                        'namespace',
                        'processContents'
                    ],
                    children: [],
                    func: ( state, schemaName, schema ) => {
                        if( schema.$ && schema.$.processContents === 'lax' ) {
                            state.anyLax = true;
                        }
                    }
                }
            };

            this.issues = issues;
            const parser = new xml2js.Parser();
            parser.parseString( '<div>' + contents.replace( /(&&|&nbsp;)/g, '' ) + '</div>', ( err, results ) => {
                if( err ) {
                    throw err;
                }
                this.xml = results;
            } );
        }

        validateXML() {
            for( const [ elementName, element ] of Object.entries( this.xml ) ) {
                this.processSchemaChild( elementName, element );
            }
        }

        processSchemaChild( elementName, element ) {
            const schema = cache.audit.xsd[ elementName ];
            if( !schema ) {
                if( elementName?.charAt( 0 ) === elementName?.charAt( 0 ).toUpperCase() ) {
                    this.issues.warnings.push( `No schema found for ${elementName}` );
                }
            } else {
                for( const [ name2, value2 ] of Object.entries( element ) ) {
                    if( name2 === '$' ) {
                        const requiredAttributes = [];
                        const processedAttributes = [];
                        for( const [ attrName, attrValue ] of Object.entries( value2 ) ) {
                            const state = {
                                attrName: attrName,
                                attrValue: attrValue,
                                anyLax: false,
                                anyAttributeLax: false,
                                imports: [],
                                attributes: [],
                                requiredAttributes: requiredAttributes,
                                schema: schema,
                                xsd: cache.audit.xsd
                            };
                            if( !this.validateAttribute( state, 'declUI:schema', schema ) &&
                                // !state.anyAttributeLax &&
                                !( state.anyAttributeLax || state.anyLax ) &&
                                !this.isAllowedAttribute( attrName ) ) {
                                trace( elementName, 'elementName' );
                                trace( state, 'state' );
                                this.issues.errors.push( `Invalid attribute ${attrName} for ${elementName}` );
                            }
                            processedAttributes.push( attrName );
                        }
                        for( const requiredAttribute of requiredAttributes ) {
                            if( !processedAttributes.includes( requiredAttribute ) ) {
                                this.issues.errors.push( `Required attribute ${requiredAttribute} for ${elementName} missing` );
                            }
                        }
                    } else if( _.isArray( value2 ) ) {
                        for( const value3 of value2 ) {
                            if( !_.isString( value3 ) ) {
                                this.processSchemaChild( name2, value3 );
                            }
                        }
                    } else if( name2 !== '_' ) {
                        this.processSchemaChild( name2, value2 );
                    }
                }
            }
        }

        isAllowedAttribute( attrName ) {
            if( scaCache.attributeAllowdInElements.complete.includes( attrName ) ) { return true; }
            for( const prefix of scaCache.attributeAllowdInElements.startsWith ) {
                if( attrName.startsWith( prefix ) ) { return true; }
            }
        }

        checkForUnexpectedElements( expected, keys ) {
            for( const key of keys ) {
                if( !expected.includes( key ) ) {
                    this.trace( expected, keys );
                    throw new Error( `Unexpected key ${key}` );
                }
            }
        }

        validateAttribute( state, schemaName, schema ) {
            let xsdRef = this.xsdRef[ schemaName ];
            if( !xsdRef ) {
                xsdRef = this.xsdRef[ `declUI:${schemaName}` ];
            }
            if( schema.$ ) { this.checkForUnexpectedElements( xsdRef.attr, Object.keys( schema.$ ) ); }
            this.checkForUnexpectedElements( xsdRef.children.concat( [ '$' ] ), Object.keys( schema ) );

            if( xsdRef.func && xsdRef.func( state, schemaName, schema ) ) {
                return true;
            }

            for( const childName of xsdRef.children ) {
                if( schema[ childName ] ) {
                    if( _.isArray( schema[ childName ] ) ) {
                        for( const child of schema[ childName ] ) {
                            if( this.validateAttribute( state, childName, child ) ) { return true; }
                        }
                    } else {
                        if( this.validateAttribute( state, childName, schema[ childName ] ) ) { return true; }
                    }
                }
            }
        }
    }

    /**
     * check if the customer schema is mergeable
     *
     * @param {Object} customerSchema - the customer's viewModel schema file content
     * @param {Object} schema - framework's viewModel schema file content
     */
    function isCustomSchemaMergeable( customerSchema, schema ) {
        let isMergeable = true;
        if( customerSchema && schema ) {
            // check if it has the same data object's structure as schema
            _.forIn( schema, ( value, key ) => {
                const prop = [ '$schema', 'type', 'properties' ];
                if( prop.includes( key ) && !customerSchema.hasOwnProperty( key ) ) {
                    isMergeable = false;
                    return false;
                }
            } );
            // check if the schema version is the same
            if( customerSchema.schemaVersion && schema.schemaVersion && customerSchema.schemaVersion !== schema.schemaVersion ) {
                isMergeable = false;
                return false;
            }
            // check if customer's schema contains the same properties as framework
            const customProp = customerSchema.properties;
            if( customProp && schema.properties ) {
                _.forIn( customProp, ( value, key ) => {
                    if( schema.properties.hasOwnProperty( key ) ) {
                        isMergeable = false;
                        return false; // break
                    }
                } );
            }
            return isMergeable;
        }
    }

    /**
     * Validate the file over schema
     *
     * @param {Object} schema - schema object
     * @param {File} jsonFilePath - The file object
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     * @param {Boolean} whiteListed - Whether the file is whitelisted or not
     */
    function validateSchema( schema, jsonFilePath, issues, whiteListed ) {
        if( !ajv.validate( schema, jsonFilePath ) ) {
            let msgSet = new Set();
            ajv.errors.forEach( error => {
                if( error.keyword === 'false schema' && error.dataPath.slice( 1 ).includes( 'actions' ) ) {
                    let loc = error.dataPath.length !== 0 ? 'at ' + error.dataPath.slice( 1 ) : '';
                    let errorMsg =
                        `Schema validation failed ${loc}.\nAction definition should match oneOf actiondef defined in declarativeViewModelSchema.\nSchema definition for custom action should be defined if you are using custom action.`;
                    msgSet.add( errorMsg );
                } else {
                    let errorLoc = error.dataPath.length !== 0 ? 'at ' + error.dataPath.slice( 1 ) : '';
                    if( !errorLoc.includes( 'actions' ) ) {
                        let msg = error.message;
                        let errorParam = '';
                        Object.keys( error.params ).forEach( e => {
                            errorParam += ' ' + `${e} : ${error.params[e]}` + ' ';
                        } );
                        msg += '.' + errorParam + errorLoc;
                        msgSet.add( msg );
                    }
                }
            } );
            msgSet.forEach( entry => {
                if( whiteListed ) {
                    issues.warnings.push( entry );
                } else {
                    issues.errors.push( entry );
                }
            } );
        }
    }

    /**
     * This methods validate if description is provided for commands in commandsViewModel.json
     *
     * @param {String} contents - The file contents
     * @param {Object} issues - The issues
     */
    function processCommandsViewModel( contents, issues ) {
        const json = JSON.parse( contents );
        if( json && json.commands ) {
            for( const [ cmdId, command ] of Object.entries( json.commands ) ) {
                if( !command.iconId ) {
                    issues.warnings.push( `Command [${cmdId}] no iconId provided` );
                }
                if( !( command.description || command.extendedTooltip ) ) {
                    issues.warnings.push( `Command [${cmdId}] description or extendedTooltip not provided` );
                }
                if( command.description && command.extendedTooltip ) {
                    issues.warnings.push( `Command [${cmdId}] description ignored if extendedTooltip provided` );
                }
                if( _strictMode && command.extendedTooltip && command.extendedTooltip.view === 'extendedTooltipDefault' ) {
                    issues.warnings.push( `Command [${cmdId}] no longer requires extendedTooltip configuration to display title or description in tooltip.` );
                }
                if( command.selected ) {
                    if( !command.selected.title ) {
                        issues.warnings.push( `Command [${cmdId}] selected.title not provided` );
                    }
                    if( !command.selected.description ) {
                        issues.warnings.push( `Command [${cmdId}] selected.description not provided` );
                    }
                }
            }
        }
        validateDuplicateEntries( json.actions, cache, 'action', issues, 'CommandsViewModel' );
        validateDuplicateEntries( json.conditions, cache, 'condition', issues, 'CommandsViewModel' );
        validateDuplicateEntries( json.commandHandlers, cache, 'commandHandler', issues, 'CommandsViewModel' );
        validateDuplicateEntries( json.commandPlacements, cache, 'commandPlacement', issues, 'CommandsViewModel' );
    }

    function processSyncStrategyViewModel( contents, issues ) {
        const json = JSON.parse( contents );
        validateDuplicateEntries( json.syncStrategies, cache, 'syncStrategies', issues, 'SyncStrategy' );
        validateDuplicateEntries( json.syncStrategyHandlers, cache, 'syncStrategyHandler', issues, 'SyncStrategy' );
        validateDuplicateEntries( json.conditions, cache, 'condition', issues, 'SyncStrategy' );
        validateDuplicateEntries( json.actions, cache, 'action', issues, 'SyncStrategy' );
    }

    function processPasteViewModel( contents, issues ) {
        const json = JSON.parse( contents );
        validateDuplicateEntries( json.actions, cache, 'action', issues, 'Paste' );
        validateDuplicateEntries( json.conditions, cache, 'condition', issues, 'Paste' );
        validateDuplicateEntries( json.pasteHandlers, cache, 'pasteHandler', issues, 'Paste' );
        validateDuplicateEntries( json.defaultPasteHandler, cache, 'defaultPasteHandler', issues, 'Paste' );
        validateDuplicateEntries( json.defaultPasteFileHandler, cache, 'defaultPasteFileHandler', issues, 'Paste' );
    }

    /**
     * @param {Object} file - the json file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function parseBatchActionViewModel( file, contents, issues ) {
        const json = JSON.parse( contents );
        let schemaFile = __dirname + '/../conf/declarativeBatchJobViewModelSchema-1.0.0.json'; // default value if no schemaversion is provided
        if( json.schemaVersion ) {
            schemaFile = __dirname + '/../conf/declarativeBatchJobViewModelSchema-' + json.schemaVersion + '.json';
        }
        if( !existsSync( schemaFile ) ) {
            issues.errors.push( 'No declarativeBatchJobViewModelSchema file found, please check your schemaVersion: ' + json.schemaVersion );
        } else {
            var batchActionObject = { actions: {} };

            const schema = require( schemaFile );
            const viewModel = require( file.path );

            const actions = viewModel.actions;

            _.forOwn( actions, ( value ) => {
                if( value.actionType === 'batchJob' ) {
                    _.forEach( value.steps, step => batchActionObject.actions[ step.action ] = actions[ step.action ] );
                }
            } );

            validateSchema( schema, batchActionObject, issues );
        }
    }

    function validateConfigSchema( file, contents, issues, schemaFilename ) {
        const json = JSON.parse( contents );
        let schemaFile = __dirname + '/../conf/' + schemaFilename + '-1.0.0.json'; // default value if no schemaversion is provided
        if( json.schemaVersion ) {
            schemaFile = __dirname + '/../conf/' + schemaFilename + '-' + json.schemaVersion + '.json';
        }
        if( !existsSync( schemaFile ) ) {
            issues.errors.push( 'No ' + schemaFilename + ' file found, please check your schemaVersion: ' + json.schemaVersion );
        } else {
            const schema = require( schemaFile );
            const configJson = require( file.path );
            validateSchema( schema, configJson, issues );
        }
    }

    /*
     * Verify the actions assigned to dragActions and dropActions
     * have action definition defined.
     */
    function processDragAndDropJson( file, contents, issues ) {
        const json = JSON.parse( contents );
        const dragHandlers = json.dragHandlers;
        const dropHandlers = json.dropHandlers;
        const actions = json.actions;

        const verifyIfActionIsDefined = ( handlers, key ) => {
            _.forEach( handlers, ( handlerDef ) => {
                const handlerActions = Object.values( handlerDef[ key ] );
                handlerActions.forEach( ( actionName ) => {
                    if( !actions[ actionName ] ) {
                        issues.errors.push( 'Action definition is missing for action ' + actionName );
                    }
                } );
            } );
        };

        if( dragHandlers ) {
            verifyIfActionIsDefined( dragHandlers, 'dragActions' );
        }

        if( dropHandlers ) {
            verifyIfActionIsDefined( dropHandlers, 'dropActions' );
        }
        validateDuplicateEntries( json.dragHandlers, cache, 'dragHandler', issues, 'DragAndDrop' );
        validateDuplicateEntries( json.dropHandlers, cache, 'dropHandler', issues, 'DragAndDrop' );
        validateDuplicateEntries( json.actions, cache, 'action', issues, 'DragAndDrop' );
        validateDuplicateEntries( json.conditions, cache, 'condition', issues, 'DragAndDrop' );
    }

    /**
     * @param {File} file - the java file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function parseMockViewModel( file, contents, issues ) {
        const schemaFile = __dirname + '/../conf/declarativeMockViewModelSchema.json';
        if( !existsSync( schemaFile ) ) {
            issues.errors.push( 'No declarativeMockViewModelSchema file found' );
        } else {
            const schema = require( schemaFile );
            const jsonFilePath = require( file.path );
            validateSchema( schema, jsonFilePath, issues );
        }
    }

    /**
     * @param {File} file - the java file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     * @param {String|null} defForValidation - Name of the definition against which contents needs to be validated
     */
    function parseViewModel( file, contents, issues, defForValidation ) {
        let whiteListed = false;
        const filePath = normalizePath( file.path ).substring( process.cwd().length + 5 );
        if( scaCache.schemaValidationWhiteList && scaCache.schemaValidationWhiteList.includes( filePath ) ) {
            whiteListed = true;
        }
        if( mergedVMSchema ) {
            validateSchema( mergedVMSchema, require( file.path ), issues, whiteListed );
            return;
        }

        const json = JSON.parse( contents );
        if( json.schemaVersion ) {
            const schemaFile = __dirname + '/../conf/declarativeViewModelSchema-' + json.schemaVersion + '.json';
            const customActionTemplateSchema = cache && cache.audit ? cache.audit.customSchema : '';

            if( !existsSync( schemaFile ) ) {
                issues.errors.push( 'No declarativeViewModelSchema file found, please check your schemaVersion: ' + json.schemaVersion );
            } else {
                const schema = require( schemaFile );
                const jsonFilePath = require( file.path );
                for( const basePath of [

                    __dirname + '..',
                    process.cwd() + '/build',
                    process.cwd() + '/src/build'
                ] ) {
                    let customSchemaFile = basePath + '/conf/declarativeSchema/declarativeViewModelSchema-1.0.0.json'; // default value if no schemaVersion is provided
                    if( json.schemaVersion ) {
                        customSchemaFile = basePath + '/conf/declarativeSchema/declarativeViewModelSchema-' + json.schemaVersion + '.json';
                    }
                    if( existsSync( customSchemaFile ) ) {
                        const customerSchema = require( customSchemaFile );
                        if( isCustomSchemaMergeable( customerSchema, schema ) ) {
                            _.merge( schema, customerSchema );
                        } else {
                            issues.errors.push( 'Format of the customer schema is not correct' );
                        }
                    }
                }
                const schemaForValidation = defForValidation && schema.definitions[ defForValidation ] ? schema.definitions[ defForValidation ] : schema;
                const mergedSchema = _.isEmpty( customActionTemplateSchema ) ?
                    schemaForValidation :
                    mergeCustomActionTemplateWithApolloActionTemplate( customActionTemplateSchema, schemaForValidation, issues );

                if( mergedSchema ) {
                    validateSchema( mergedSchema, jsonFilePath, issues, whiteListed );
                    mergedVMSchema = mergedSchema;
                } else {
                    issues.errors.push( 'Issue in Declarative Custom Action Template !!' );
                }
            }
        } else {
            issues.errors.push( 'Missing Schema Version !!' );
        }
    }

    /**
     * @param {File} file - the java file
     * @param {String} contents - file contents
     * @param { Object } issues - object containing the array of warnings and issues to add to.
     */
    function parseViewModelSPLMTable( file, contents, issues ) {
        const json = JSON.parse( contents );
        const schemaFile = __dirname + '/../conf/SPLMTableViewModelSchema-1.0.0.json';
        let whiteListed = false;
        const filePath = normalizePath( file.path ).substring( process.cwd().length + 5 );
        if( scaCache.schemaValidationWhiteList && scaCache.schemaValidationWhiteList.includes( filePath ) ) {
            whiteListed = true;
        }
        const schema = require( schemaFile );
        const jsonFilePath = require( file.path );
        if( json.imports && json.imports.includes( 'js/aw-splm-table.directive' ) ) {
            validateSchema( schema, jsonFilePath, issues, whiteListed );
        }
        processPLTableDirectEditOptions( file, json, issues );
    }

    /**
     * @param {Object} file - the json file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function parseCmdAndSyncViewModel( file, contents, issues, type, commonSchema ) {
        let whiteListed = false;
        const filePath = normalizePath( file.path ).substring( process.cwd().length + 5 );
        if( scaCache.schemaValidationWhiteList && scaCache.schemaValidationWhiteList.includes( filePath ) ) {
            whiteListed = true;
        }
        if( commonSchema ) {
            validateSchema( commonSchema, require( file.path ), issues, whiteListed );
            return commonSchema;
        }

        const json = JSON.parse( contents );
        let schemaFile = `${__dirname}/../conf/${type}-1.0.0.json`; // default value if no schemaversion is provided
        const customActionTemplateSchema = cache && cache.audit ? cache.audit.customSchema : '';

        if( json.schemaVersion ) {
            schemaFile = `${__dirname}/../conf/${type}-${json.schemaVersion}.json`;
        }
        if( !existsSync( schemaFile ) ) {
            issues.errors.push( `No ${type} file found, please check your schemaVersion: ${json.schemaVersion}` );
        } else {
            let customSchemaFile = `declarativeSchema/${type}-1.0.0.json`; // default value if no schemaVersion is provided
            if( json.schemaVersion ) {
                customSchemaFile = `declarativeSchema/${type}-${json.schemaVersion}.json`;
            }

            const schema = require( schemaFile );
            const jsonFilePath = require( file.path );

            if( existsSync( customSchemaFile ) ) {
                const customerSchema = require( customSchemaFile );
                if( isCustomSchemaMergeable( customerSchema, schema ) ) {
                    // do schema merge
                    _.merge( schema, customerSchema );
                    const mergedSchema = _.isEmpty( customActionTemplateSchema ) ? schema : mergeCustomActionTemplateWithApolloActionTemplate( customActionTemplateSchema, schema, issues );

                    if( mergedSchema ) {
                        validateSchema( mergedSchema, jsonFilePath, issues, whiteListed );
                        commonSchema = mergedSchema;
                    } else {
                        issues.errors.push( 'Issue in Declarative Custom Action Template !!' );
                    }

                    // need to re import schemaFile because we did merge before
                    delete require.cache[ require.resolve( schemaFile ) ];
                } else {
                    issues.errors.push( 'Format of the customer schema is not correct' );
                }
            } else {
                const mergedSchema = _.isEmpty( customActionTemplateSchema ) ? schema : mergeCustomActionTemplateWithApolloActionTemplate( customActionTemplateSchema, schema, issues );

                if( mergedSchema ) {
                    validateSchema( mergedSchema, jsonFilePath, issues, whiteListed );
                    commonSchema = mergedSchema;
                } else {
                    issues.errors.push( 'Issue in Declarative Custom Action Template !!' );
                }
            }
        }

        return commonSchema;
    }

    /**
     * Parse the workspace json file and validate with schema
     * @param {Object} file - the json file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function parseWorkspace( file, contents, issues ) {
        const json = JSON.parse( contents );
        let schemaFile = __dirname + '/../conf/declarativeWorkspaceSchema-1.0.0.json'; // default value if no schemaversion is provided
        if( json.schemaVersion ) {
            schemaFile = __dirname + '/../conf/declarativeWorkspaceSchema-' + json.schemaVersion + '.json';
        }
        if( !existsSync( schemaFile ) ) {
            issues.errors.push( 'No declarativeWorkspaceSchema file found, please check your schemaVersion: ' + json.schemaVersion );
        } else {
            let customSchemaFile = 'declarativeSchema/declarativeWorkspaceSchema-1.0.0.json'; // default value if no schemaVersion is provided
            if( json.schemaVersion ) {
                customSchemaFile = 'declarativeSchema/declarativeWorkspaceSchema-' + json.schemaVersion + '.json';
            }
            const schema = require( schemaFile );
            const jsonFilePath = require( file.path );

            if( existsSync( customSchemaFile ) ) {
                const customerSchema = require( customSchemaFile );
                if( isCustomSchemaMergeable( customerSchema, schema ) ) {
                    // do schema merge
                    _.merge( schema, customerSchema );
                    validateSchema( schema, jsonFilePath, issues );
                    // need to re import schemaFile because we did merge before
                    delete require.cache[ require.resolve( schemaFile ) ];
                } else {
                    issues.errors.push( 'Format of the customer schema is not correct' );
                }
            } else {
                validateSchema( schema, jsonFilePath, issues );
            }
        }
    }
    /**
     * Parse the workspace contribution json file and validate with schema
     * @param {Object} file - the json file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function parseWorkspaceContribution( file, contents, issues ) {
        const json = JSON.parse( contents );
        let schemaFile = __dirname + '/../conf/declarativeWorkspaceContributionSchema-1.0.0.json'; // default value if no schemaversion is provided
        if( json.schemaVersion ) {
            schemaFile = __dirname + '/../conf/declarativeWorkspaceContributionSchema-' + json.schemaVersion + '.json';
        }
        if( !existsSync( schemaFile ) ) {
            issues.errors.push( 'No declarativeWorkspaceContributionSchema file found, please check your schemaVersion: ' + json.schemaVersion );
        } else {
            let customSchemaFile = 'declarativeSchema/declarativeWorkspaceContributionSchema-1.0.0.json'; // default value if no schemaVersion is provided
            if( json.schemaVersion ) {
                customSchemaFile = 'declarativeSchema/declarativeWorkspaceContributionSchema-' + json.schemaVersion + '.json';
            }
            const schema = require( schemaFile );
            const jsonFilePath = require( file.path );

            if( existsSync( customSchemaFile ) ) {
                const customerSchema = require( customSchemaFile );
                if( isCustomSchemaMergeable( customerSchema, schema ) ) {
                    // do schema merge
                    _.merge( schema, customerSchema );
                    validateSchema( schema, jsonFilePath, issues );
                    // need to re import schemaFile because we did merge before
                    delete require.cache[ require.resolve( schemaFile ) ];
                } else {
                    issues.errors.push( 'Format of the customer schema is not correct' );
                }
            } else {
                validateSchema( schema, jsonFilePath, issues );
            }
        }
    }

    /**
     * Parse the propertyRendererTemplates json file and validate with schema
     * @param {Object} file - the json file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function parsePropertyRendererTemplates( file, contents, issues ) {
        const json = JSON.parse( contents );
        let schemaFile = __dirname + '/../conf/declarativePropertyRendererTemplatesSchema-1.0.0.json'; // default value if no schemaversion is provided
        if( json.schemaVersion ) {
            schemaFile = __dirname + '/../conf/declarativePropertyRendererTemplatesSchema-' + json.schemaVersion + '.json';
        }
        if( !existsSync( schemaFile ) ) {
            issues.errors.push( 'No declarativePropertyRendererTemplatesSchema file found, please check your schemaVersion: ' + json.schemaVersion );
        } else {
            let customSchemaFile = 'declarativeSchema/declarativePropertyRendererTemplatesSchema-1.0.0.json'; // default value if no schemaVersion is provided
            if( json.schemaVersion ) {
                customSchemaFile = 'declarativeSchema/declarativePropertyRendererTemplatesSchema-' + json.schemaVersion + '.json';
            }
            const schema = require( schemaFile );
            const jsonFilePath = require( file.path );

            if( existsSync( customSchemaFile ) ) {
                const customerSchema = require( customSchemaFile );
                if( isCustomSchemaMergeable( customerSchema, schema ) ) {
                    // do schema merge
                    _.merge( schema, customerSchema );
                    validateSchema( schema, jsonFilePath, issues );
                    // need to re import schemaFile because we did merge before
                    delete require.cache[ require.resolve( schemaFile ) ];
                } else {
                    issues.errors.push( 'Format of the customer schema is not correct' );
                }
            } else {
                validateSchema( schema, jsonFilePath, issues );
            }
        }
    }

    /**
     * Method to identify and notify
     *
     * 1) Files that registers the property policy and never unregister's it.
     * 2) Command handler files that registers a property policy.
     *
     * @param {File} file - java or js file
     * @param {String} contents - the file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processPropertyPolicyRegistrations( file, contents, issues ) {
        //  counts the number of policy registrations happening in the file.
        let policyRegisterationsCount = 0;
        //  counts the number of policy unregistrations happening in the file.
        let policyUnRegisterationsCount = 0;

        // Remove all the commented lines from content
        contents = '';
        for( const line of logger.extractLines( contents ) ) {
            if( line.indexOf( '//' ) > -1 ) {
                contents += line.substring( 0, line.indexOf( '//' ) ) + '\n';
            } else {
                contents += line + '\n';
            }
        }

        if( file.path.search( '\.js$' ) > -1 && file.path.search( 'propertyPolicyService.js' ) === -1 ) {
            const declarationNames = [ 'soa_kernel_propertyPolicyService', 'soa/kernel/propertyPolicyService' ];
            const inspectChars = [ '[', '(' ];
            let policyManagerName = null;
            const orginalContent = contents;

            // loop to find the property policy variable name
            _.forEach( declarationNames, declaredName => {
                while( contents.indexOf( declaredName ) > -1 && !policyManagerName ) {
                    const inspectPos = contents.lastIndexOf( declaredName );
                    let inspectElement = contents.substring( 0, inspectPos );

                    if( inspectElement.lastIndexOf( inspectChars[ declarationNames.indexOf( declaredName ) ] ) > -1 ) {
                        const hold = inspectElement.substring( inspectElement.lastIndexOf( inspectChars[ declarationNames.indexOf( declaredName ) ] ) );
                        const defPos = hold.split( ',' ).length;
                        inspectElement = contents.substring( inspectPos );

                        if( inspectElement.indexOf( 'function' ) > -1 ) {
                            inspectElement = inspectElement.substring( inspectElement.indexOf( 'function' ) );
                            inspectElement = inspectElement.substring( inspectElement.indexOf( '(' ), inspectElement.indexOf( ')' ) );
                            const variableNames = inspectElement.split( ',' );

                            if( variableNames.length > defPos - 1 ) {
                                policyManagerName = variableNames[ defPos - 1 ].trim();
                            }
                        }
                    }
                    contents = contents.substring( 0, contents.lastIndexOf( declaredName ) );
                }

                // reset the contents
                contents = orginalContent;
            } );

            // Count the policy registrations / un-registrations happening through propert policy manager
            if( policyManagerName ) {
                const policyRegistration = new RegExp( policyManagerName + '\.register\\(', 'g' );
                const policyUnregistration = new RegExp( policyManagerName + '\.unregister\\(', 'g' );
                policyRegisterationsCount += ( contents.match( policyRegistration ) || [] ).length;
                policyUnRegisterationsCount += ( contents.match( policyUnregistration ) || [] ).length;
            }
        }

        // Warn the file that registers a property policy and never unregisters it.
        if( policyRegisterationsCount > 0 && policyUnRegisterationsCount === 0 ) {
            issues.warnings.push( ' Property policy never unregistered in ' + file.path );
        }

        if( policyRegisterationsCount > 0 && file.path.search( 'CommandHandler.java' ) > -1 ) {
            // prevent new command handler files from adding property policy.
            issues.errors.push( ' Command handler should not add any property policy !' );
        }
    }

    /**
     * Processes a JavaScript file for SCA violations
     *
     * @param {File} file - the JavaScript file
     * @param {Object} fileInfo - see pre_audit_prep
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processJavaScript( file, fileInfo, issues ) {
        // NG Module dependencies that do not need resolution by ES6
        // references to the file that defines the dependency
        const ngConstants = [
            'authenticator',
            'filters',
            'imageRepositoryConfiguration', // invalid AW constant
            // Angular
            'ngRepeatDirective',
            'ngClassDirective',
            // bootstrap
            'globalParameters',
            // appWrapper
            'defaultRoutePath',
            'viewAndViewModelRepoConfiguration',
            // UI Grid
            'gridUtil',
            'rowSorter',
            'uiGridConstants'
        ];

        if( !fileInfo ) {
            const filePathInfo = pathParse( file.path );
            if( filePathInfo.base !== 'module.js' ) {
                if( scaCache.fileInfoWhiteList && scaCache.fileInfoWhiteList.includes( filePathInfo.base ) ) {
                    issues.warnings.push( 'Missing File Info for: ' + file.path );
                } else {
                    issues.errors.push( 'Missing File Info for: ' + file.path );
                }
            }
            return;
        }

        // Check if @module name is following the standard naming rules
        if( fileInfo.actualAtModuleName && !/\btest\b/.test( file.path ) ) {
            const targetName = fileInfo.targetAtModuleName;
            const actualName = fileInfo.actualAtModuleName;
            if( actualName === 'Missing@ModuleName' ) {
                issues.errors.push( 'Missing @module \"' + targetName + '\"' );
            } else if( actualName !== targetName &&
                !matchAfterSynonymCheck( targetName, actualName, fileInfo.moduleJson ) ) {
                // If the tails of the module name paths match then only issue a warning
                if( targetName.includes( actualName ) ) {
                    issues.warnings.push( 'Invalid @module name \"' + actualName +
                        '\" root does not match root of standard name \"' + targetName + '\"' );
                } else {
                    issues.errors.push( 'Invalid @module name \"' + actualName +
                        '\" root does not match root of standard name \"' + targetName + '\"' );
                }
            }
        }

        // Check that returned injection object match the defined NG modules
        if( fileInfo.returnFunctionNames ) {
            _.forEach( fileInfo.returnFunctionNames, functionName => {
                let found = false;
                _.forEach( fileInfo.ngModules, ngModule => {
                    if( functionName === ngModule.name ) {
                        found = true;
                        return false; // break
                    }
                } ); // End for all NG modules
                if( !found ) {
                    issues.warnings.push( 'Returned injection for NG module "' + functionName + '" is not defined in the file' );
                }
            } ); // End for each returned function name
        }

        // Check for "exports" being returned by define or factory
        if( fileInfo.exportedJsMethods &&
            fileInfo.exportedJsMethods.length > 0 &&
            !fileInfo.returnExportsFound ) {
            issues.warnings.push( 'List of function \"exports\" is not returned by define or factory' );
        }

        // Check Kit Dependencies
        checkKitDependencies( fileInfo, issues );
    }

    /**
     * Processes the Bootstrap configuration path synonyms for a possible module name match
     *
     * @param {Object} moduleJson - the Module JSON object for the file being processedjava
     * @param {String} targetName - standard ES6 @module name
     * @param {Object} actualName - actual @module name found in the file
     * @return {Boolean} true: match to the actual name was found or false: no match was found
     */
    function matchAfterSynonymCheck( targetName, actualName, moduleJson ) {
        let matchFound = false;
        if( moduleJson && moduleJson.bootstrap &&
            moduleJson.bootstrap.config && moduleJson.bootstrap.config.paths ) {
            const synonyms = moduleJson.bootstrap.config.paths;
            _.forEach( synonyms, ( replacementString, synonym ) => {
                const newString = actualName.replace( synonym, replacementString );
                if( newString === targetName ) {
                    matchFound = true;
                    return false; // break
                }
            } );
        }
        return matchFound;
    }
    function resloveRelativePathModules(dep,filePath){
        let depPath = null;
        try {
            depPath = require.resolve( path.join(path.dirname(filePath),dep) );
        } catch ( error ) {
            logger.debug( `Failed to resolve ${dep} through require.resolve` );
        }
        return depPath 
    }
    /**
     * Check Kit Dependencies
     *
     * @param {Object} fileInfo - see pre_audit_prep
     * @param {Object} issues - object containing the array of warnings and issues to add to
     */
    function checkKitDependencies( fileInfo, issues ) {
        const moduleRefsToIgnore = [
            'js/aw-global-search.directive', // gaps
            'js/aw-xrt-summary.directive', // gaps
            'angularMocks', // used by some karma tests
            'js/angulartemplatecache' // generated
        ];

        // Pull 3rd party path entries from the module bootstraps
        for( const moduleJson of Object.values( cache.filePath2moduleJson ) ) {
            if( moduleJson && moduleJson.bootstrap && moduleJson.bootstrap.config && moduleJson.bootstrap.config.paths ) {
                for( const pathName in moduleJson.bootstrap.config.paths ) {
                    moduleRefsToIgnore.push( pathName );
                }
            }
        }

        // Check ES6 Dependencies -  This file belongs to a JSON module
        // which belongs to a kit.  All ES6 modules used by this file
        // must belong to the same kit or a kit that is included in the kit
        // or one of the descendant kits
        for( const dep of fileInfo.deps ) {
            // Get the file info for the file that defines the dependant ES6 module
            const depFileInfos = cache.audit.dep2fileInfo[ dep ];

            if( !depFileInfos ) {
                if( !moduleRefsToIgnore.includes( dep ) &&
                    !dep.startsWith( 'config' ) && !dep.startsWith( 'viewmodel' ) ) {
                    //try require.resolve
                    let depPath = null;
                    if(dep.includes("./")){
                        depPath = resloveRelativePathModules(dep, fileInfo.filePath)
                    }else{
                    try {
                        depPath = require.resolve( dep );
                    } catch ( error ) {
                        logger.debug( `Failed to resolve ${dep} through require.resolve` );
                    }
                }
                    if( depPath === null ) {
                        issues.warnings.push( 'ES6 dependency for "' + dep + '" is not defined by any module' );
                    }
                }
                continue;
            }

            let found = false;
            let moduleJson;
            let depModuleJson;
            for( const depFileInfo of depFileInfos ) {
                if( !found ) {
                    moduleJson = fileInfo.moduleJson;
                    depModuleJson = depFileInfo.moduleJson;

                    // If this module and the depend ES6 module are in the same
                    // JSON module then they must be in the same kit - so go to next ES6 dependency
                    if( moduleJson.name === depModuleJson.name ) {
                        found = true;
                        continue;
                    }

                    // Search all kits that this module belongs to
                    // There should acually be only one but this handles
                    // error cases where a module is defined in multiple kits

                    if( moduleJson.audit ) {
                        _.forEach( moduleJson.audit.kits, kitJson => {
                            const kitStack = [];
                            found = searchKitsForModule( kitJson, depModuleJson, kitStack, issues );
                            if( found ) { return false; } // break
                        } );
                    }
                }
            }

            if( !found && moduleJson.audit ) {
                let depKitName = '<not in a kit>';
                if( depModuleJson.audit ) {
                    depKitName = depModuleJson.audit.kits[ 0 ].name;
                }
                const msg = 'Invalid dependency on ' + dep + ' defined in ' + depKitName + ':' + depModuleJson.name + ':' + shortenPath( dep );
                /*if( /((aw.default.sublocation|aw-header|aw-secondary-workarea)\.(controller|directive))\.js$/.test( fileInfo.filePath ) ) {
                    // FIXME temporarily whitelist until these are fixed
                    issues.warnings.push( msg );
                } else {*/
                if( !scaCache.invalidDepWhitelist || scaCache.invalidDepWhitelist && scaCache.invalidDepWhitelist.includes( fileInfo.name ) ) {
                    issues.warnings.push( msg );
                } else {
                    issues.errors.push( msg );
                }
            }
        } // End for each ES6 dependency
    }

    /**
     * Recursive method to search for a module name within the kit dependency tree
     *
     * @param {Object} kitJson - kit JSON object for the starting kit
     * @param {String} dependentModuleJson
     * @param {Array} kitStack - list of previously searched kit names
     * @param {Object} issues - object containing the array of warnings and issues to add to
     * @return {boolean} true when the modules is found, false when it is not found
     */
    function searchKitsForModule( kitJson, dependentModuleJson, kitStack, issues ) {
        // Handle when a module is not included in any kit
        if( !dependentModuleJson.audit || dependentModuleJson.audit.kits.length < 1 ) {
            return false;
        }

        const kitName = kitJson.name;
        const kitIndex = kitStack.indexOf( kitName ); // Check for circular kit dependencies

        if( kitIndex > -1 ) {
            let msg = 'Circular dependency found in kit references\n';
            kitStack.push( kitName );
            for( let inx = kitIndex; inx < kitStack.length - 1; ++inx ) {
                msg += '-- kit "' + kitStack[ inx ] + '" depends on kit "' + kitStack[ inx + 1 ] + '"\n';
            }
            issues.errors.push( msg );
            kitStack.pop();
            return false;
        }

        let found = false;
        kitStack.push( kitName );

        // Loop over all kits that the dependant module belong to
        // There should be just one but this handles error case when included in more than on kit

        _.forEach( dependentModuleJson.audit.kits, depKitJson => {
            if( depKitJson.name === kitName ) {
                found = true;
                return false; // break
            }

            // Search all child kits and their decendants
            if( kitJson.kitDeps ) {
                _.forEach( kitJson.kitDeps, childKitName => {
                    const childKitJson = cache.name2kitJson[ childKitName ];
                    found = searchKitsForModule( childKitJson, dependentModuleJson, kitStack, issues );
                    if( found ) {
                        return false; // break
                    }
                } ); // End for all child kits
            }
        } ); // End for all kits containing the dependant module

        kitStack.pop();
        return found;
    }

    /**
     * Processes a java file for SCA violations
     *
     * @param {File} file - the java file
     * @param {String} contents - the file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processJava( file, contents, issues ) {
        // Java 7 Generics
        if( file.path.search( 'ServiceResponseHandler\.java$' ) === -1 ) {
            for( const clazz of [
                'ArrayList',
                'LinkedList',
                'HashMap',
                'TreeMap',
                'HashSet',
                'LinkedHashSet',
                'TreeSet',
                'CellList',
                'Event',
                'GenericViewModelProperty',
                'ListDataProvider',
                'Property',
                'SingleSelectionModelWithNotifications',
                'Tuple'
            ] ) {
                if( contents.search( '= new ' + clazz + '(\\(|<)[^>]' ) > -1 ) {
                    issues.errors.push( 'Use Java 7 Generics: new ' + clazz + '<>(!' );
                }
            }
        }
    }

    /**
     * Processes for image file for SCA violations
     *
     * @param {File} file - the java file
     * @param {String} contents - the file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processForImageHandling( file, contents, issues ) {
        const filePath = file.path.replace( /\\/g, '/' );
        if( /\/src\/test\/.*\.svg$/i.test( filePath ) && !filePath.startsWith( 'src/image/' ) ) {
            issues.warnings.push( 'SVG files should not be contained within the module!' );
        }
        if( /\.(png|gif|jpg|jpeg|bmp|ai)$/i.test( filePath ) ) {
            // TODO This needs to be made into an error condition.
            issues.warnings.push( 'Image files should not be contained within the module!' );
        }
        // @Source
        if( /@Source.*\.(png|gif|jpg|bmp)"/i.test( contents ) ) {
            // TODO This needs to be made into an error condition.
            issues.warnings.push( '@Source of image not allowed!' );
        }
        if( /background-image:.*url/.test( contents ) ) {
            // TODO This needs to be made into an error condition.
            issues.warnings.push( 'Referenced images do not support styling!' );
        }
        if( /src="data:image\//.test( contents ) ) {
            // TODO This needs to be made into an error condition.
            issues.warnings.push( 'Use of data:image/png not allowed!' );
        }
    }

    /**
     * Steam flush function which is called after transform function is called for each file in stream.
     *
     * @param {Function} cbFlush - flush callback when complete
     */
    function flush( cbFlush ) {
        report();

        localVars.stream.emit( 'end' );
        cbFlush();
    }

    function processDynamicCompoundProperties( file, contents, issues ) {
        const fileName = file.path.split( '\\' ).pop().split( '/' ).pop();
        const msg = fileName + 'intermediateObjectUids should not be accessed, use uwPropertyService.js\'s \'getSourceObjectUid\' and \'getRelationObjectUid\' instead.';

        if( scaCache.DCPWhiteList &&
            scaCache.DCPWhiteList.intermediateObjectUids &&
            !scaCache.DCPWhiteList.intermediateObjectUids.includes( fileName ) && // Not in white list
            contents.indexOf( '.intermediateObjectUids' ) !== -1 ) {
            // Contains 'intermediateObjectUids' property access
            issues.errors.push( msg );
        }
    }

    /**
     * Check for uiGrid usage in thinclient/thinclientfx files not on the whitelist.
     *
     * @param {File} file - the feature file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processUiGridUsage( file, contents, issues ) {
        const fileName = file.path.split( '\\' ).pop().split( '/' ).pop();

        if( scaCache.UiGridWhiteList &&
            !scaCache.UiGridWhiteList.includes( fileName ) ) {
            // Not in white list
            if( /(<aw-table | ui-grid=|<aw-matrix )/.test( contents ) ) {
                // Contains 'intermediateObjectUids' property access
                const msg = fileName + ' should not use uiGrid (aw-table or aw-matrix) and instead should use PLTable (aw-splm-table).';
                issues.errors.push( msg );
            }
            if( /(<aw-compare )/.test( contents ) ) {
                // Contains 'intermediateObjectUids' property access
                const msg = fileName + ' should not use aw-compare and instead should use aw-compare2.';
                issues.errors.push( msg );
            }
        }
    }

    /**
     * Check for PL Table usage in directives not on the whitelist.
     *
     * @param {File} file - the feature file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processPLTableInDirectiveUsage( file, contents, issues ) {
        const fileName = file.path.split( '\\' ).pop().split( '/' ).pop();
        const msg = fileName + ' should not use PLTable (aw-splm-table) inside a directive.';

        if( scaCache.PLTableInsideDirectiveWhiteList &&
            !scaCache.PLTableInsideDirectiveWhiteList.includes( fileName ) && // Not in white list
            ( fileName.toLowerCase().endsWith( 'directive.html' ) ||
                fileName.toLowerCase().endsWith( 'directive.js' ) ) &&
            /(<aw-splm-table )/.test( contents ) ) {
            // Contains 'intermediateObjectUids' property access
            issues.errors.push( msg );
        }
    }

    /**
     * Check for PL Table usage where propEditEnabled is disabled or forceAutoSave is enabled.
     *
     * @param {File} file - the feature file
     * @param {String} json - file json object
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processPLTableDirectEditOptions( file, json, issues ) {
        const fileName = file.path.split( '\\' ).pop().split( '/' ).pop();
        const propEditMsg = fileName +
            ' should not disable individual cell editing. If you believe an exception is needed, please contact the framework team. Adding this file to the enablePropEditWhiteList array in staticCodeAnalysis_dev.json will suppress this error.';
        const forceAutoSaveMsg = fileName +
            ' should not force auto save in tables. If you believe an exception is needed, please contact the framework team. Adding this file to the forceAutoSaveWhiteList array in staticCodeAnalysis_dev.json will suppress this error.';

        let propEditDisabled = false;
        if( json.dataProviders ) {
            for( const dataProvider in json.dataProviders ) {
                if( json.dataProviders[ dataProvider ].enablePropEdit === false ) {
                    propEditDisabled = true;
                }
            }
        }

        let forceAutoSaveEnabled = false;
        if( json.grids ) {
            for( const grid in json.grids ) {
                if( json.grids[ grid ].gridOptions && json.grids[ grid ].gridOptions.forceAutoSave === true ) {
                    forceAutoSaveEnabled = true;
                }
            }
        }

        const isInWhiteList = function( whiteList ) {
            let inWhiteList = false;
            // Check if file name is in whitelist
            if( whiteList.includes( fileName ) ) {
                inWhiteList = true;
            }
            // Check if file is in whitelisted path
            for( let i = 0; i < whiteList.length; i++ ) {
                const forwardSlashPath = file.path.replace( /\\|\\\\/g, '/' );
                if( forwardSlashPath.includes( whiteList[ i ] ) ) {
                    inWhiteList = true;
                    break;
                }
            }
            return inWhiteList;
        };

        if( scaCache.forceAutoSaveWhiteList && !isInWhiteList( scaCache.forceAutoSaveWhiteList ) && forceAutoSaveEnabled ) {
            issues.errors.push( forceAutoSaveMsg );
        }
        if( scaCache.enablePropEditWhiteList && !isInWhiteList( scaCache.enablePropEditWhiteList ) && propEditDisabled ) {
            issues.errors.push( propEditMsg );
        }
    }

    function processHTMLFilesForIdUsage( file, contents, issues ) {
        if( scaCache.blackListElementsWithIdAttribUsage ) {
            for( const line of logger.extractLines( contents ) ) {
                for( const elem of scaCache.blackListElementsWithIdAttribUsage ) {
                    let elemPattern = '<' + elem + ' ';
                    if( line.match( elemPattern ) && line.includes( ' id=' ) ) {
                        const msg1 = 'Using ' + elem + ' incorrectly in ' + file.path + '. id attribute should no longer be used. \n';
                        const msg2 = '\n@deprecated SWF4.3 , id attribute with' + elem + ' is deprecated in afx 4.2.\nPlease refer ' + elem + '\'s API documentation for details. + \n';
                        if( scaCache.isUsageOfIdAttribForListedElemsRestricted ) {
                            issues.errors.push( msg1 );
                        } else {
                            issues.warnings.push( msg2 );
                        }
                    }
                }
            }
        }
    }

    function processHTMLFilesForImageAltAttributeUsage( file, contents, issues ) {
        var imgTagArray = [];
        for( const line of logger.extractLines( contents ) ) {
            if( line.match( '<img ' ) ) {
                imgTagArray.push( line );
            }
        }
        _.forEach( imgTagArray, ( imgLine ) => {
            // error in afx if <img> element tag doesn't consists of alt attribute
            // warning in SWF consumers module if <img> element tag doesn't consists of alt attribute.
            if( !imgLine.includes( ' alt=' ) ) {
                var fileName = file.path.split( '\\' ).pop().split( '/' ).pop();
                const msg = fileName + ' contains img tag without alt attribute. Please define "alt" attribute in <img> element tag. \n';
                if( isApollo ) {
                    issues.errors.push( msg );
                } else {
                    issues.warnings.push( msg );
                }
            }
        } );
    }

    const rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi;

    /**
     * Check for files which have HTML self-closing tags, support HTML file and JS file embedded with HTML snippet.
     *
     * @param {File} file - the HTML or JS file
     * @param {String} contents - file contents
     * @param {Object} issues - object containing the array of warnings and issues to add to.
     */
    function processFilesHaveHTMLSelfClosedTag( file, contents, issues ) {
        if( rxhtmlTag.test( contents ) ) {
            var fileName = file.path.split( '\\' ).pop().split( '/' ).pop();
            issues.errors.push( fileName + ' has HTML self-closing tags which is not supported, change to dedicated close tags to fix.' );
        }
    }

    /**
     * Report issues (error and warnings)
     */
    function report() {
        localVars.errorFound = 0;
        _.forEach( localVars.file2issues, ( issues, filePath ) => {
            if( !_.isEmpty( issues.errors ) || !_.isEmpty( issues.warnings ) ) {
                logger.warn( logger.pathColor( filePath.substring( process.cwd().length + 5 ) ), localVars.MSG_PREFIX );
                _.forEach( issues.errors, error => {
                    const errPattern = new RegExp( '[0-9a-z]', 'i' );
                    if( errPattern.test( error ) ) {
                        logger.error( '  ' + error, localVars.MSG_PREFIX );
                        localVars.errorFound++;
                    }
                } );
                _.forEach( issues.warnings, warning => {
                    logger.warn( '  ' + warning, localVars.MSG_PREFIX );
                } );
            }
        } );

        _.forEach( localVars.propertyPolicyFile2unusedProperties, ( unusedProperties, propertyPolicyFile ) => {
            if( !_.isEmpty( unusedProperties ) ) {
                logger.warn( '  Property Policy file ' + propertyPolicyFile + ': Asking for below properties but not used', localVars.MSG_PREFIX );
                _.forEach( unusedProperties, unusedProperty => {
                    logger.warn( '      ' + unusedProperty, localVars.MSG_PREFIX );
                } );
            }
        } );

        if( localVars.errorFound ) {
            localVars.stream.emit( 'error', new Error( 'Failed with ' + localVars.errorFound + ' errors!' ) );
        }
    }

    /**
     * @param {Object} artifacts - artifacts object for which duplicate key's to be reported.
     * @param {Object} cache - Global cache for storing duplicate keys across modules.
     * @param {String} artifactKey - This key is used to report the Error and also to cache the data
     * @param {Object} issues - Erros/Warning will be added to this object
     * @param {String} fileName -  This is used to report the Error and also to cache the data
     */

    let validateDuplicateEntries = ( artifacts, cache, artifactKey, issues, fileName ) => {
        if( artifacts ) {
            for( const artifactID of Object.keys( artifacts ) ) {
                if( cache.audit[ fileName ] && cache.audit[ fileName ][ artifactKey ] && Object.keys( cache.audit[ fileName ][ artifactKey ] ).includes( artifactID ) ) {
                    if( scaCache.duplicateKeysWhiteList && scaCache.duplicateKeysWhiteList[ fileName ] && scaCache.duplicateKeysWhiteList[ fileName ][ artifactKey ] &&
                        scaCache.duplicateKeysWhiteList[ fileName ][ artifactKey ].includes( artifactID ) ) {
                        issues.warnings.push( 'Duplicate key found in ' + fileName + ' for [' + artifactID + '] ' + artifactKey + ' in ' + cache.audit[ fileName ][ artifactKey ][ artifactID ] +
                            ' module.' );
                    } else {
                        issues.errors.push( 'Duplicate key found in ' + fileName + ' for [' + artifactID + '] ' + artifactKey + ' in ' + cache.audit[ fileName ][ artifactKey ][ artifactID ] +
                            ' module.' );
                    }
                } else {
                    cache.audit[ fileName ] ? '' : cache.audit[ fileName ] = {};
                    cache.audit[ fileName ][ artifactKey ] ? '' : cache.audit[ fileName ][ artifactKey ] = {};
                    cache.audit[ fileName ][ artifactKey ][ artifactID ] = name;
                }
            }
        }
    };
    localVars.stream = through.obj( transform, flush );
    return localVars.stream;
};

/**
 * @param {Object|null} cache - Global cache for gulp processing. This can be null.
 */
module.exports.buildCache = cache => {
    if( !cache ) {
        if( global.cache ) {
            cache = global.cache;
        } else {
            cache = global.cache = {};
        }
    }
    if( !cache.sca ) {
        cache.sca = {
            attributeAllowdInElements: {
                complete: [],
                startsWith: []
            }
        };
        // We might consider using gulp.src or others to scan for these files. It would have to be very fast though.
        // We could do this when generating the cache so that it's predetermined here.
        for( const fileName of [
            process.cwd() + '/conf/staticCodeAnalysis_dev.json',
            process.cwd() + '/src/build/conf/staticCodeAnalysis_dev.json',
            __dirname + '/../conf/staticCodeAnalysis_dev.json',
            __dirname + '/../conf/staticCodeAnalysis.json'
        ] ) {
            if( existsSync( fileName ) ) {
                if( !_strictMode && /\_dev\.json$/.test( fileName ) ) {
                    _strictMode = true;
                    trace( 'Found', fileName, '; Setting strict mode ON.' );
                }

                trace( 'Loading', fileName );
                try {
                    merge( cache.sca, require( fileName ) );
                } catch ( e ) {
                    logger.error( 'Problem parsing ' + e );
                }
            }
        }
        trace( 'Strict mode Off.' );
    }
    return cache.sca;
};

/**
 * @param {Object} cache - cache
 * @param {File} file - *.directive.js file to check for missing dependencies
 */
module.exports.checkDepsPrep = ( cache, file ) => {
    const MSG_PREFIX = 'audit/checkDepsPrep: ';

    let acorn = require( 'acorn' );
    var jsx = require( 'acorn-jsx' );
    acorn = acorn.Parser.extend( jsx() );
    const walk = require( 'acorn-walk/dist/walk' );

    try {
        // parse file looking for define/function/app.directive/function/return/retrict
        const ast = acorn.parse( file.contents.toString(), {
            allowReturnOutsideFunction: true,
            sourceType: 'module',
            ecmaVersion: 11
        } );

        let directiveNgName;
        let restrictValue;

        // if 'E', add to elems
        // if 'A', add to attrs
        walk.simple( ast, {
            CallExpression: callNode => {
                // If this statement defines an NG module the name will be captured
                // If this statement only references NG module then only the dependencies are listed
                // This statement may also define an NG module which depends on other modules
                const ngModule = {
                    name: undefined, // NG Module name
                    deps: [], // NG dependency list
                    functionParameters: [] // Module parameter list
                };

                const callee = callNode.callee;
                if( callee.object && callee.property &&
                    callNode.arguments.length === 2 &&
                    // callee.object.name === 'app' && // avoid unnecessary assumption
                    callee.object.type === 'Identifier' &&
                    callee.property.name &&
                    /^directive$/.test( callee.property.name ) ) {
                    ngModule.name = callNode.arguments[ 0 ].value;

                    // handle pattern -- app.directive( 'myNgService', [ 'otherNgService',  function(){} )
                    directiveNgName = callNode.arguments[ 0 ].value;
                }
            },
            ReturnStatement: returnNode => {
                if( returnNode.argument &&
                    returnNode.argument.type === 'ObjectExpression' ) {
                    for( const property of returnNode.argument.properties ) {
                        if( property.key.name === 'restrict' ) {
                            restrictValue = property.value.value;
                        }
                    }
                }
            }
        }, {
            ...walk.base,
            JSXElement: () => {}
        } ); // End AST Walk

        if( directiveNgName ) {
            let filename = basename( file.path, '.directive.js' );
            if( !restrictValue ) {
                cache.audit.elems.push( filename );
                cache.audit.elems.push( directiveNgName );
                cache.audit.attrs.push( filename );
                cache.audit.attrs.push( directiveNgName );
            } else {
                if( /E/.test( restrictValue ) ) {
                    cache.audit.elems.push( filename );
                    cache.audit.elems.push( directiveNgName );
                }
                if( /A/.test( restrictValue ) ) {
                    cache.audit.attrs.push( filename );
                    cache.audit.attrs.push( directiveNgName );
                }
            }
        } else if( restrictValue ) {
            logger.warn( 'Parsing issues in ' + shortenPath( file.path ) + '. directiveNgName=' + directiveNgName + ' restrictValue=' + restrictValue, MSG_PREFIX );
        }
    } catch ( err ) {
        logger.error( 'Unable to parse ' + file.path + '\n' + err, MSG_PREFIX );
    }
};

/**
 * @param {Object} cache - cache
 * @param {File} file - *.directive.js file to check for missing dependencies
 */
module.exports.checkDeps = ( cache, file ) => {
    const MSG_PREFIX = 'audit/checkDeps: ';

    const fileName = shortenPath( normalizePath( file.path ) );

    const contents = file.contents.toString();
    let htmlStr = null;

    let ndx = contents.search( /templateUrl:/ );
    if( ndx > -1 ) {
        let contentsSub = contents.substring( ndx );
        ndx = contentsSub.search( /app\.getBaseUrlPath\(\) \+/ );
        contentsSub = contentsSub.substring( ndx + 23 );
        contentsSub = contentsSub.substring( contentsSub.search( /('|")/ ) + 1 );
        const htmlFile = contentsSub.substring( 0, contentsSub.search( /('|")/ ) );
        try {
            htmlStr = readFileSync( join( dirname( dirname( file.path ) ), htmlFile ) ).toString();
        } catch ( err ) {
            // aw-list uses a function for templateUrl. This is supported by angular, so just failing audit is not good.
            logger.warn( `Unable to parse HTML for ${fileName}\n${err}`, MSG_PREFIX );
        }
    } else {
        ndx = contents.search( /template:/ );
        if( ndx > -1 ) {
            ndx += 10;
            const quote = contents[ ndx ];
            htmlStr = contents.substring( ndx + 1, contents.indexOf( quote, ndx + 1 ) );
        }
    }

    if( !htmlStr ) {
        trace( 'No HTML string found for', fileName );
        return;
    }

    let elem = [];
    let attr = [];
    htmlParser.parse( htmlStr, {
        openElement: name => {
            elem.push( name );
        },
        attribute: ( name, value ) => {
            if( value ) {
                attr.push( name );
            }
        }
    } );

    elem = _.intersection( cache.audit.elems, elem );
    attr = _.intersection( cache.audit.attrs, attr );

    _.remove( attr, elem2 => {
        return /^(visible-when)$/.test( elem2 ); // TODO clean these up since it's our directive!
    } );

    if( elem.length > 0 || attr.length > 0 ) {
        const filePath = shortenPath( normalizePath( file.path ) );
        let msg = null;
        _.forEach( elem.concat( attr ), tag => {
            const exectedStr = '\'js/' + tag + '.directive\'';
            if( contents.search( exectedStr ) === -1 &&
                filePath.search( tag ) === -1 ) {
                if( !msg ) {
                    msg = 'Missing dependency from ' + filePath + ' to:';
                }
                msg = msg + '\n\t' + exectedStr;
            }
        } );
        if( msg ) {
            throw new Error( msg );
        }
    }
};
