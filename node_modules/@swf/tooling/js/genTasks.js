const _ = require( 'lodash' );
const { existsSync } = require( 'fs' );
const { basename, dirname } = require( 'path' );
const through = require( 'through2' );

const logger = require( './logger' );
const { addUnique, normalizePath, replaceEnvVar } = require( './util' );
const { parseSchema } = require( './schemaUtils' );

const rootDir = normalizePath( process.cwd() );
const trace = logger.createTrace( __filename );

const cache = {
    filePath2moduleJson: {},
    filePath2kitJson: {},
    filePath2siteJson: {},
    buildJson: {},
    taskFile: 'let gulp = global.gulp;\n'
};

const cacheTemp = {
    name2moduleJson: {},
    tasksAudit: [ 'auditNonModule' ],
    tasksKit: [],
    locale: [],
    siteTasks: [],
    watchTasks: []
};

/**
 * @param {Array} reqTasks - array of requested tasks
 * @return {Array} array of user tasks
 */
module.exports.genUserTasks = function genUserTasks( reqTasks ) {
    const userTasks = [];
    const taskPrefix = 'Custom_';
    let ii = 1;
    for( const reqTask of reqTasks ) {
        /**
         * Check if this task starts with '-'<BR>
         * If so: It is an 'option' and NOT a normal task. Just pass it along.
         */
        let userTask;
        if( /^-/.test( reqTask ) ) {
            userTask = reqTask;
        } else {
            userTask = `${taskPrefix}${reqTask}_${ii++}`;
            const tasksToAdd = userTasks.splice( 0 );
            tasksToAdd.push( reqTask );
            addTask( userTask, tasksToAdd );
        }
        userTasks.push( userTask );
    }
    return userTasks;
};

/**
 * @return {Object} cache
 */
module.exports.genTasks = () => {
    const errorMsgs = [];
    // Add the required tasks for all the war definitions
    _.forEach( cache.filePath2siteJson, ( siteJson, filePath ) => {
        if( siteJson && siteJson.name && siteJson.kits ) {
            const deps = [];
            const transpilers = cache.buildJson ? cache.buildJson.transpilers : null;
            if( transpilers ) {
                _.forEach( transpilers, ( value, key ) => {
                    deps.push( `${key}_transpile` );
                    cacheTemp[ `tasks${key}Transpile` ] = [];
                } );
            }

            if( /^war_/.test( basename( filePath ) ) ) {
                addTask( `war_${siteJson.name}`, deps, `return global.buildSite('${filePath}');` );
                cacheTemp.siteTasks.push( `war_${siteJson.name}` );
            }

            addTask( `site_${siteJson.name}`, deps, `return global.buildSite('${filePath}');` );
            cacheTemp.siteTasks.push( `site_${siteJson.name}` );
        } else {
            logger.error( `No site|war.json found for ${filePath}` );
        }
    } );

    // Add a mapping for the previous kit_base task
    addTask( 'kit_base', [ 'kit_tc-aw-solution', 'kit_tc-aw-framework' ] );

    const moduleName2kitDepInfo = {};
    _.forEach( cache.filePath2kitJson, ( kitJson, filePath ) => {
        if( !kitJson ) {
            logger.error( `No kit.json found for ${filePath}` );
            return; // continue;
        }

        // Group task for kits which are used by the war & actual kit builds
        const definedKitDeps = kitJson.kitDeps;
        const definedModuleDeps = [];
        _.forEach( definedKitDeps, kitDep => {
            const kitDepJson = searchObj( cache.filePath2kitJson, 'name', kitDep );
            if( !kitDepJson ) {
                if( !kitJson.ignoreMissingKits ) {
                    logger.error( `Kit dependency ${kitDep} not found` );
                }
            } else {
                // Check that the package (kit) has no dependency on a higher level package (kit)
                if( kitDepJson.level > kitJson.level ) {
                    const errorMsg = `Package '${kitJson.name}' (at level ${kitJson.level}) has dependency on package '${kitDepJson.name}' at higher level (${kitDepJson.level})`;
                    errorMsgs.push( errorMsg );
                }
                if( kitDepJson.kitDeps ) {
                    addUnique( definedKitDeps, kitDepJson.kitDeps, true ); // do not want to sort, new elements need to be at the end
                }
                if( kitDepJson.modules ) {
                    addUnique( definedModuleDeps, kitDepJson.modules );
                }
            }
        } );

        if( !kitJson.modules ) {
            logger.warn( `${filePath} missing modules array!` );
        } else {
            addUnique( definedModuleDeps, kitJson.modules );
            for( const moduleName of kitJson.modules ) {
                const moduleJson = cacheTemp.name2moduleJson[ moduleName ];
                moduleName2kitDepInfo[ moduleName ] = {
                    definedKitDeps: definedKitDeps,
                    definedModuleDeps: definedModuleDeps,
                    name: kitJson.name
                };
                if( !( moduleJson && moduleJson.type ) ) {
                    throw new Error( `Unable to locate module named ${moduleName} for kit ${kitJson.name}` );
                }
            }
        }

        if( kitJson.soaDeps ) {
            for( const soaDep of kitJson.soaDeps ) {
                if( !soaDep.match( /^[a-z0-9.]+$/i ) ) {
                    logger.error( `Unrecognized character in soa dependency ${soaDep} in ${kitJson.name} kit` );
                    logger.error( 'See http://cipgweb/tc_devdoc/dokuwiki/sandbox:activeworkspace:soajs#add_or_modify_soa_libraries' );
                }
            }
        }

        if( kitJson.zipFile ) {
            const taskName2 = `kit_${kitJson.name}`;
            addTask( taskName2, [], `return global.buildKit('${filePath}');` );
            cacheTemp.tasksKit.push( taskName2 );
        }
    } );

    // Add the required tasks for all the module definitions
    _.forEach( cache.filePath2moduleJson, ( moduleJson, filePath ) => {
        if( moduleJson ) {
            addCustomBuildTask( moduleJson, filePath );
            addAuditTask( moduleJson, filePath );
            addMainTask( moduleJson );
        } else {
            logger.error( `No module.json found for ${filePath}` );
        }
    } );

    // Finalize the task file string
    addTask( 'kit', cacheTemp.tasksKit );
    addTask( 'audit', cacheTemp.tasksAudit );
    const transpilers = cache.buildJson ? cache.buildJson.transpilers : null;
    if( transpilers ) {
        _.forEach( transpilers, ( value, key ) => {
            addTask( `${key}_transpile`, cacheTemp[ `tasks${key}Transpile` ] );
        } );
    }

    const name2kitJson = {};
    _.forEach( cache.filePath2kitJson, kitJson => name2kitJson[ kitJson.name ] = kitJson );

    for( const filePath in cache.filePath2siteJson ) {
        const siteJson = cache.filePath2siteJson[ filePath ];
        for( let ii = 0; ii < siteJson.kits.length; ii++ ) {
            const kitJson = name2kitJson[ siteJson.kits[ ii ] ];
            if( kitJson ) {
                if( kitJson.kitDeps ) {
                    for( let jj = 0; jj < kitJson.kitDeps.length; jj++ ) {
                        const kitName = kitJson.kitDeps[ jj ];
                        if( !siteJson.kits.includes( kitName ) ) {
                            siteJson.kits.push( kitName );
                        }
                    }
                }
            } else if( !siteJson.ignoreMissingKits ) {
                logger.error( `Unable to locate kit ${siteJson.kits[ ii ]} for war ${siteJson.name}` );
            }
        }
    }

    if( cacheTemp.siteTasks && cacheTemp.siteTasks.length === 1 ) {
        addTask( 'site', cacheTemp.siteTasks );
    }

    if( cacheTemp.watchTasks && cacheTemp.watchTasks.length === 1 ) {
        addTask( 'watch', cacheTemp.watchTasks );
    }

    if( errorMsgs.length > 0 ) {
        for( const ii in errorMsgs ) {
            logger.error( errorMsgs[ ii ] );
        }
        throw new Error( 'Task generation failed!' );
    }

    return cache;
};

/**
 * @param {Object} obj - object
 * @param {String} key - key
 * @param {String} value - value
 * @return {Object} value of key entry
 */
function searchObj( obj, key, value ) {
    for( const i in obj ) {
        if( obj[ i ][ key ] === value ) {
            return obj[ i ];
        }
    }
    return null;
}

/**
 * @param {Object} moduleJson - module json
 */
function addMainTask( moduleJson ) {
    const tasks = [];
    if( cacheTemp.tasksAudit.includes( `${moduleJson.name}_audit` ) ) {
        tasks.push( `${moduleJson.name}_audit` );
    }
    const transpilers = cache.buildJson ? cache.buildJson.transpilers : null;
    if( transpilers ) {
        _.forEach( transpilers, ( value, key ) => {
            if( moduleJson.type.includes( key ) &&
                cacheTemp[ `tasks${key}Transpile` ].includes( `${moduleJson.name}_${key}_transpile` ) ) {
                tasks.push( `${moduleJson.name}_${key}_transpile` );
            }
        } );
    }
    addTask( moduleJson.name, tasks );
}

/**
 * @param {String} path - file path
 * @return {Boolean} true if module should be added
 */
function processModule( path ) {
    path = normalizePath( path );
    return !/\/node_modules\//.test( path ) || process.env.SONAR_INCLUDE_ALL_KITS === 'true' && /\/afx\//.test( path );
}

/**
 * @param {Object} moduleJson - module json
 * @param {String} folder - folder path
 */
function addAuditTask( moduleJson, folder ) {
    const taskName = `${moduleJson.name}_audit`;
    const depTasks = [];
    let method = '';
    if( !moduleJson.skipAudit &&
        moduleJson.type.includes( 'native' ) ||
        moduleJson.type.includes( 'cucumber' ) ) {
        method = `return global.runAudits('${folder}');`;
        if( processModule( moduleJson.moduleDir ) ) {
            // Don't add audit test to 'audit' task list because there should be no reason to run this.
            addUnique( cacheTemp.tasksAudit, taskName );
        }
    }
    if( method ) {
        addTask( taskName, depTasks, method );
    }
}

/**
 * Add custom build task
 * @param {Object} moduleJson the moduleJson object for custom build task
 * @param {String} filePath - moduleJson file Path
 */
function addCustomBuildTask( moduleJson, filePath ) {
    const transpilers = cache.buildJson ? cache.buildJson.transpilers : null;
    if( transpilers ) {
        _.forEach( transpilers, ( transpiler, key ) => {
            const taskName = `${moduleJson.name}_${key}_transpile`;
            if( moduleJson.type.includes( key ) ) {
                const outputPath = transpiler.outputDirectory ? `'${transpiler.outputDirectory}'` : undefined;
                addTask( taskName, [], `return global.${key}('${filePath}','${rootDir}',${outputPath})` );
                addUnique( cacheTemp[ `tasks${key}Transpile` ], taskName );
            }
        } );
    }
}

/**
 * Add task definition to set of generated tasks.
 *
 * @param {String} taskName task name
 * @param {Array} depTasks array of dependendent tasks
 * @param {String} method (optional) method to invoke
 * @param {Boolean} sort - sort?
 */
function addTask( taskName, depTasks, method, sort ) {
    cache.taskFile += `gulp.task('${taskName}'`;
    if( depTasks.length > 0 ) {
        if( sort ) {
            depTasks.sort();
        }
        if( method ) {
            cache.taskFile += ',gulp.series(gulp.parallel(';
        } else {
            cache.taskFile += ',gulp.parallel(';
        }
        for( let ii = 0; ii < depTasks.length; ii++ ) {
            if( ii > 0 ) {
                cache.taskFile += ',';
            }
            cache.taskFile += `\n  '${depTasks[ ii ]}'`;
        }
        cache.taskFile += '\n)';
    }
    if( method ) {
        let functionName = taskName.replace( /[.-]/g, '_' ); // replace illegal chars for function names
        if( /^[0-9]/.test( functionName ) ) { functionName = `task_${functionName}`; }
        cache.taskFile += `,function ${functionName}(cb){\n  ${method}\n}`;
        if( depTasks.length > 0 ) { cache.taskFile += ')'; }
    } else if( depTasks.length === 0 ) {
        cache.taskFile += ',cb=>{cb();}';
    }
    cache.taskFile += ');\n\n';
}

/**
 * @return {Stream} stream
 */
module.exports.createCache = function() {
    const files = [];

    /**
     * @param {File} file - file
     * @param {Object} ignore - ignore
     * @param {Function} cbTransform - completion callback
     */
    function transform( file, ignore, cbTransform ) { // eslint-disable-line complexity
        files.push( file );
        try {
            const baseFileName = basename( file.path );
            let filePath = normalizePath( file.path );
            const folder = normalizePath( dirname( file.path ) );
            const contents = file.contents.toString();
            const issues = {
                errors: [],
                warnings: []
            };
            if( /^module\.json$/.test( baseFileName ) ) {
                filePath = dirname( filePath );
                const moduleJson = JSON.parse( file.contents );

                if( moduleJson.type && moduleJson.type.length === 1 && moduleJson.type.includes( 'native' ) ) {
                    trace( `Use of type=['native'] can be removed. It is assumed as default for ${file.path}` );
                }
                parseSchema( file, contents, issues, 'declarativeModuleSchema-1.0.0' );
                moduleJson.moduleDir = filePath;
                if( !moduleJson.name ) {
                    moduleJson.name = basename( folder );
                }
                if( !moduleJson.type ) {
                    moduleJson.type = [ 'native' ];
                }
                cache.filePath2moduleJson[ filePath ] = moduleJson;
                if( moduleJson.name ) {
                    cacheTemp.name2moduleJson[ moduleJson.name ] = moduleJson;
                }
                const hasSrcDir = moduleJson.hasOwnProperty( 'srcDir' );
                if( !hasSrcDir && ( moduleJson.type.includes( 'native' ) || moduleJson.type.includes( 'repo' ) ) ) {
                    moduleJson.srcDir = 'src';
                }
                if( moduleJson.type.includes( 'repo' ) ||
                    moduleJson.type.includes( 'native' ) && ( hasSrcDir && moduleJson.srcDir.length === 0 ) ) {
                    moduleJson.skipAudit = true; // nothing to audit (tests?)
                    moduleJson.skipTest = true; // nothing to test
                }
                if( !moduleJson.testDir &&
                    moduleJson.type.includes( 'native' ) &&
                    existsSync( `${folder}/test` ) ) {
                    moduleJson.testDir = 'test';
                }
                if( moduleJson.testDir ) {
                    moduleJson.testDir = `${folder}/${moduleJson.testDir}`;
                    if( !moduleJson.skipTest && !existsSync( moduleJson.testDir ) ) {
                        throw new Error( `Directory does not exist! - ${moduleJson.testDir}` );
                    }
                }
                if( moduleJson.siteDir ) {
                    moduleJson.siteDir = replaceEnvVar( moduleJson.siteDir );
                }
                if( moduleJson.featureDir ) {
                    moduleJson.featureDir = `${folder}/${moduleJson.featureDir}`;
                }
                if( moduleJson.propertiesDir ) {
                    moduleJson.propertiesDir = `${folder}/${moduleJson.propertiesDir}`;
                }
                if( moduleJson.jars ) {
                    // Update jar references to be absolute paths
                    for( let ii = 0; ii < moduleJson.jars.length; ii++ ) {
                        moduleJson.jars[ ii ] = `${folder}/${moduleJson.jars[ ii ]}.jar`;
                    }
                }
                if( moduleJson.srcDir ) {
                    moduleJson.srcDir = `${folder}/${moduleJson.srcDir}`;
                    if( !existsSync( moduleJson.srcDir ) ) {
                        // throw new Error( `Directory does not exist! - ${moduleJson.srcDir}` );
                        delete moduleJson.srcDir;
                    }
                }

                cbTransform();
            } else if( /^(site|war).*\.json$/.test( baseFileName ) ) {
                const siteJson = JSON.parse( file.contents );
                parseSchema( file, contents, issues, 'declarativeSiteSchema-1.0.0' );
                if( /(war).*\.json$/.test( file.path ) ) {
                    siteJson.siteDir = `${rootDir}/out/war/${siteJson.name}`;
                } else {
                    siteJson.siteDir = `${rootDir}/out/site/${siteJson.name}`;
                }
                _.forEach( cache.filePath2siteJson, ( siteJsonLp, filePathLp ) => {
                    if( siteJson.name === siteJsonLp.name ) {
                        throw new Error( `Duplicate site name for:\n\t${filePath}\n\t${filePathLp}` );
                    }
                } );
                cache.filePath2siteJson[ filePath ] = siteJson;
                cbTransform();
            } else if( /^kit.*\.json$/.test( baseFileName ) ) {
                const kitJson = JSON.parse( file.contents );
                parseSchema( file, contents, issues, 'declarativeKitSchema-1.0.0' );
                kitJson.kitDir = normalizePath( dirname( file.path ) );
                if( kitJson.srcDir ) {
                    kitJson.srcDir = `${folder}/${kitJson.srcDir}`;
                }
                cache.filePath2kitJson[ filePath ] = kitJson;
                if( !processModule( filePath ) ||
                    kitJson.modules.length === 0 ) {
                    // Skip sonar reporting if kit resides in node_modules directory or no modules
                    kitJson.skipSonar = true;
                }
                if( kitJson.kitDeps ) {
                    // Since all clasic kits have been removed and UxRefresh and afxCommon has been merged in
                    // single module as afx, we need to handle cases where consumers does not get impacted by this
                    for( let ii = 0; ii < kitJson.kitDeps.length; ii++ ) {
                        if( /afx(Common|_UxRefresh)/.test( kitJson.kitDeps[ ii ] ) ) {
                            logger.error( `${kitJson.kitDeps[ii]} has been renamed to afx, please update your kitDeps` );
                            kitJson.kitDeps[ ii ] = 'afx';
                        }
                    }
                    kitJson.kitDepsOrig = _.clone( kitJson.kitDeps );
                }
                cbTransform();
            } else if( /^tem\.properties$/.test( baseFileName ) ) {
                for( const line of logger.extractLines( file.contents ) ) {
                    const keyValue = line.split( '=' );
                    const key = keyValue[ 0 ];
                    const value = keyValue[ 1 ];
                    trace( `  tem.properties: ${key}=${value}` );
                    if( key === 'locale' ) {
                        cacheTemp.locale = value.split( ',' );
                    }
                }
                cbTransform();
            } else if( /^build.*\.json$/.test( baseFileName ) ) {
                const buildJson = JSON.parse( file.contents );
                parseSchema( file, contents, issues, 'declarativeBuildSchema-1.0.0' );
                cache.buildJson = buildJson;
                cbTransform();
            } else {
                logger.error( `Unhandled file: ${file.path}` );
                cbTransform();
            }
        } catch ( e ) {
            logger.error( `Unhandled file: ${file.path}` );
            logger.error( e );
            throw e;
        }
    }

    /**
     * @param {Function} cbFlush - completion callback
     */
    function flush( cbFlush ) {
        for( const filePath in cache.filePath2siteJson ) {
            const siteJson = cache.filePath2siteJson[ filePath ];
            if( !siteJson.properties ) { siteJson.properties = {}; }
            for( const key in cacheTemp.properties ) {
                if( !siteJson.properties.hasOwnProperty( key ) ) {
                    siteJson.properties[ key ] = cacheTemp.properties[ key ];
                }
            }
        }
        for( let ii = 0; ii < files.length; ii++ ) {
            stream.push( files[ ii ] );
        }
        stream.emit( 'end' );
        cbFlush();
    }

    const stream = through.obj( transform, flush );
    return stream;
};
