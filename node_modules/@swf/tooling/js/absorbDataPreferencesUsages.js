const yargs = require( 'yargs' );
const gulp = require( 'gulp' );
const util = require( './util' );
const tap = require( 'gulp-tap' );
const logger = require( './logger' );
const { execSync } = require( 'child_process' );
const gulpIf = require('gulp-if');
const changed = require('gulp-changed');
var through = require( 'through2' );

'use strict;'

var isCheckedOut = false;


/**
 * Logging the impacted files
 *
 * @param {Array} filesModified Array of all files that need conversion/are converted
 */
let logSummary = ( filesModified ) => {
    if( filesModified && filesModified.length > 0 ) {
        filesModified.forEach( ( fileName ) => {
            logger.info( fileName, '', true );
        } );
    }
};


/**
 * Processing of javascript files in the project scope
 *
 * @param {String} projectPath Path of the project
 * @returns {Array} Array of all files that need conversion/are converted
 */
let getValidJsFilesWithDataPreferences = ( projectPath, ignoreTestFiles ) => {
    let filesToReplaceIn = [];

    return new Promise( ( resolve, reject ) => {
        util.stream2Promise( gulp.src( [`${projectPath}/**/*.js`, `!${projectPath   }/**/*Test.js` ])
            .pipe(through.obj( ( file, encoding, callback ) => {
                    try {
                        logger.verbose( 'Checking file  ' + file.path);
                        let fileContents = ( file.contents ).toString( encoding );

                        let dataPreferences = fileContents.match( /data\.preferences/g );

                        if( dataPreferences && dataPreferences.length > 0 ) {

                            // skip files where data.preferences is being assigned by another object
                            let dataPreferencesAssignment = fileContents.match(/data\.preferences\s*=/);
                            if(dataPreferencesAssignment && dataPreferencesAssignment.length > 0) {
                                return callback();
                            }
                            filesToReplaceIn.push( file.path );

                            // skip modifications for 'dryRun'
                            if(argv._.includes( 'dryRun' )){
                                return callback();
                            }

                            let importStatement = fileContents.match(/import[^']+'js\/appCtxService';/);
                            let importName = 'appCtxSvc';

                            // does the file have appCtxService import?
                            if( importStatement && importStatement.length > 0) {
                                // if yes then extract the import variable name
                                importName = importStatement[0].match(/[^import\s][^\s]+/)[0];
                            }
                            else{
                                // else construct an import statement for appCtx
                                importStatement = `import ${importName} from 'js/appCtxService';\r\n`;
                                var pos = fileContents.indexOf('import');
                                fileContents = fileContents.substring(0, pos) + importStatement + fileContents.substring(pos);

                            }

                            const replacementString = importName + '.ctx.preferences';          // Eg. appCtxSvc.ctx.preferences

                            // replacing 'data && data.preferences' with 'appCtxSvc.ctx.preferences'
                            let dataAndDataPreferences = fileContents.match(/data[\s]*&&[\s]*data\.preferences/);
                            if( dataAndDataPreferences && dataAndDataPreferences.length > 0) {
                                fileContents = fileContents.replace( /data[\s]*&&[\s]*data\.preferences/g, replacementString );
                            }

                            // // replacing '"preferences" in data' with '"preferences" in appCtxSvc.ctx'
                            let preferencesInData = fileContents.match(/['"]preferences['"][\s]+in[\s]+data/);
                            if( preferencesInData && preferencesInData.length > 0) {
                                fileContents = fileContents.replace( /['"]preferences['"][\s]+in[\s]+data/g, `'preferences' in ${importName}.ctx` );
                            }

                            fileContents = fileContents.replace(/data\.preferences/g, replacementString)

                            if( argv.awc && argv._.includes( 'run' ) ) {
                                execSync( `dt co ${file.path}`, ( error ) => {
                                    if( error ) {
                                        logger.verbose( 'file checkout failed..' );
                                        logger.error( error );
                                    }
                                } );
                                logger.info( 'File Checked Out : ' + file.path);
                                file.contents = Buffer.from( fileContents );
                            }
                            callback( null, file );
                        }
                        else{
                            return callback();
                        }

                    } catch ( e ) {
                        logger.error( e );
                        logger.info( file.path );
                    }

                } )
            ).pipe(gulp.dest( projectPath ))
        ).then( () => {
            resolve( filesToReplaceIn );
        } ).catch( ( e ) => {
            logger.error( e );
            process.exit( 1 );
        } )
    } );
}


/**
 * Processing of ViewModel files in the project scope
 *
 * @param {String} projectPath Path of the project
 * @returns {Array} Array of all files that need conversion/are converted
 */
let getValidVMFilesWithDataPreferences = (projectPath) => {
    let filesToReplaceIn = [];

    return new Promise( ( resolve, reject ) => {
        util.stream2Promise( gulp.src( `${projectPath}/**/*ViewModel.json` )
            .pipe(through.obj( ( file, encoding, callback ) => {
                    try {
                        logger.verbose( 'Checking file  ' + file.path);
                        let fileContents = ( file.contents ).toString( encoding );
                        let fileContentsObject = JSON.parse( fileContents );

                        // No changes where data.preferences is initializing the response property of a dataprovider
                        for(const dataProvider in fileContentsObject.dataProviders) {
                            const dataProviderDetails = fileContentsObject.dataProviders[dataProvider];
                            if(dataProviderDetails.response && dataProviderDetails.response === '{{data.preferences}}') {
                                logger.info( 'Not to convert!! : ' + file.path);
                                return callback();
                            }
                        }
                        let dataPreferences = fileContents.match( /data\.preferences/g );
                        if( dataPreferences && dataPreferences.length > 0 ) {

                            // Clean up the preferences section in the viewmodel file
                            if( fileContents.match( /['"]preferences['"][\s]*:[\s]*\[[^\]]*][^,]*,/ ) ) {
                                fileContents = fileContents.replace( /['"]preferences['"][\s]*:[\s]*\[[^\]]*][^,]*,/, '' );
                            }
                            filesToReplaceIn.push( file.path );

                            // if dryRun command then do nothing and check the next file
                            if(argv._.includes( 'dryRun' )){
                                return callback();
                            }

                            if( argv.awc && argv._.includes( 'run' ) ) {
                                execSync( `dt co ${file.path}`, ( error ) => {
                                    if( error ) {
                                        logger.verbose( 'file checkout failed..' );
                                        logger.error( error );
                                    }
                                } );
                                logger.info( 'File Checked Out : ' + file.path);
                                fileContents = fileContents.replace( /data\.preferences/g, 'ctx.preferences' );
                                file.contents = Buffer.from( fileContents );
                            }
                            callback( null, file );
                        }
                        else{
                            return callback();
                        }

                    } catch ( e ) {
                        logger.error( e );
                        logger.info( file.path );
                    }

                } )
            ).pipe(gulp.dest( projectPath ))
        ).then( () => {
            resolve( filesToReplaceIn );
        } ).catch( ( e ) => {
            logger.error( e );
            process.exit( 1 );
        } )
    } );
}


/**
 * Fetches the files that need conversion based on the command options
 *
 * @param {String} projectPath Path of the project
 */
let findAndReplaceDataPreferences = async ( projectPath ) => {
    const stopwatch = new logger.Stopwatch();
    let vmFilesModified;
    let jsFilesModified;

    if( !argv.skipViewModel ) {
        vmFilesModified = await getValidVMFilesWithDataPreferences( projectPath );
    }

    if( !argv.skipJs ) {
        jsFilesModified = await getValidJsFilesWithDataPreferences( projectPath );
    }

    if(argv._.includes( 'run' )){
        logger.info( 'Below Files are modified : ' );
        logSummary( vmFilesModified );
        logSummary( jsFilesModified );
        logger.verbose( `Conversion is completed in ${stopwatch.end()}` );
    }
    else if (argv._.includes( 'dryRun' )){
        logger.info( 'The below listed files need conversion work :' );
        logSummary( vmFilesModified );
        logSummary( jsFilesModified );
    }
}


const argv = yargs
    .command( 'run' ,'Replace all valid occurrences of data.preferences with ctx.preferences', {} )
    .command( 'dryRun','List all files which will be updated', {} )
    .options( {
        projectPath: {
            alias: 'p',
            description: 'Dir path of project',
            demandOption: true,
            type: 'string'
        },
        awc: {
            alias: 'a',
            description: 'Specify if processing AW client code',
            type: 'boolean'
        },
        skipViewModel: {
            alias: 'svm',
            description: 'Skip the processing of ViewModel files',
            type: 'boolean'
        },
        skipJs: {
            alias: 'sjs',
            description: 'Skip the processing of js files',
            type: 'boolean'
        }
    } )
    .help()
    .demandCommand( 1, 'Please provide either run or dryRun command' )
    .usage('Usage: node $0 [options]')
    .example('node $0 --projectPath path_of_the_project --awc --svm')
    .alias( 'help', 'h')
    .argv;


( async () => {
    findAndReplaceDataPreferences( argv.projectPath );    // starting point for the script
} )();
