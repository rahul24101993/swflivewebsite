/* global cache */

const _ = require( 'lodash' );
const { normalizePath } = require( '../rewired/utils' );
const logger = require( './logger' );
const util = require( './util' );

const trace = logger.createTrace( __filename );
const packageJson = require( process.cwd() + '/package.json' );
/**
 * Generate the properties files necessary for sonar execution.
 * sonar properties file is saved to disk at %ROOT%/out/sonar.
 *
 * @param {String} sonarOutDir - sonar output directory
 * @return {Promise} promise
 */
module.exports = function generate( sonarOutDir ) {
    const localVars = {
        MSG_PREFIX: '  sonar: ',
        files: [],
        packageName: packageJson.name,
        packageVersion: packageJson.version,
        completedModules: []
    };

    const sonarRoot = process.env.SONAR_ROOT;
    trace( 'Sonar root:', sonarRoot );
    if( sonarRoot && cache.name2kitJson[ sonarRoot ] ) {
        logger.verbose( 'SONAR_ROOT is set to a valid kit. Processing ' + sonarRoot, localVars.MSG_PREFIX );
        return util.writeFile( sonarOutDir + '/sonar-project.properties', loadKit( sonarRoot, '' ) );
    } else if( sonarRoot && cache.name2moduleJson[ sonarRoot ] ) {
        logger.verbose( 'SONAR_ROOT is set to a valid module. Processing ' + sonarRoot, localVars.MSG_PREFIX );
        const moduleString = loadModule( sonarRoot, '' );
        if( !moduleString ) {
            logger.error( 'SONAR_ROOT set to an invalid module: ' + sonarRoot + '. Sonar cannot complete.', localVars.MSG_PREFIX );
            return Promise.resolve();
        }
        return util.writeFile( sonarOutDir + '/sonar-project.properties', moduleString );
    }

    logger.verbose( 'SONAR_ROOT is not set or is not valid. Processing all', localVars.MSG_PREFIX );

    const validKits = [];
    const kitStrings = [];
    _.forEach( cache.filePath2kitJson, kitJson => {
        if( kitJson.skipSonar ) {
            return; // continue
        }

        trace( 'Processing kit', kitJson.name );

        const prefix = kitJson.name + '-kit.';
        const kitString = loadKit( kitJson.name, prefix );
        if( kitString ) {
            util.mkdir( sonarOutDir + '/' + kitJson.name + '-kit', true );

            validKits.push( kitJson.name + '-kit' );
            kitStrings.push( kitString );
        }
    } );

    let projectName;
    let projectKey;
    if( localVars.packageName && process.env.CI_PROJECT_ID ) {
        // Support for GitLab CI (Apollo)
        projectName = localVars.packageName;
        projectKey = localVars.packageName + '_' + process.env.CI_PROJECT_ID;
    } else {
        projectName = 'Active Workspace ' + localVars.packageVersion;
        projectKey = 'awc-all' + localVars.packageVersion;
    }

    //Replace @ and / from project key
    projectKey = projectKey.replace( '@', '' ).replace( '/', '-' ).trim();

    const outputString = [
        'sonar.projectName=' + projectName,
        'sonar.projectKey=' + projectKey,
        'sonar.projectVersion=' + localVars.packageVersion,
        'sonar.modules=' + validKits.join()
    ].concat( kitStrings );

    if( process.env.SONAR_BRANCH_NAME ) {
        outputString.push( 'sonar.branch.name=' + process.env.SONAR_BRANCH_NAME );
    }

    return util.writeFile( sonarOutDir + '/sonar-project.properties', outputString.join( '\n' ) );

    /**
     * Given a kit Json object, this method will parse the modules within the kit, checking to see if they are valid.
     * @param {Object} kitJson - The kit json object to parse child modules.
     * @returns {String[]} the array of module names that are valid for this kit.
     */
    function findValidModules( kitJson ) {
        trace( 'Finding valid modules.' );
        const validModules = [];
        _.forEach( kitJson.modules, moduleName => {
            const moduleJson = cache.name2moduleJson[ moduleName ];
            if( _.some( moduleJson.type, element => {
                    return /^(repo|war)$/.test( element );
                } ) ) {
                trace( 'Module', moduleName, 'is an invalid type. Skipping.' );
                return; // continue
            }

            if( localVars.completedModules.includes( moduleJson.name ) ) {
                trace( 'Module', moduleName, 'has already been added (probably under a different kit). Skipping.' );
                return; // continue
            }

            trace( 'Found valid module:', moduleName );
            validModules.push( moduleName );
        } );
        return validModules;
    }

    /**
     * Loads the information from the give kit into sonar properties.
     * @param {String} rootKitName - the name of the kit.
     * @param {String} kitPrefix - the prefix for the sonar.properties. Generally is the kit name followed by the '-kit'
     * @return {String} the sonar-project.properties string for this kit & all child modules.
     */
    function loadKit( rootKitName, kitPrefix ) {
        trace( 'Loading kit', rootKitName );
        const kitJson = cache.name2kitJson[ rootKitName ];
        const validModules = findValidModules( kitJson );
        if( validModules.length === 0 ) {
            logger.info( `Kit ${kitJson.name} does not have any valid modules. Skipping.`, localVars.MSG_PREFIX );
            return Promise.resolve();
        }

        trace( 'Valid modules:', validModules );

        const kitCfg = [
            kitPrefix + 'sonar.projectName=' + kitJson.name + '-kit',
            kitPrefix + 'sonar.projectKey=' + kitJson.name,
            kitPrefix + 'sonar.projectVersion=' + localVars.packageVersion,
            kitPrefix + 'sonar.projectBaseDir=' + kitJson.kitDir
        ];
        kitCfg.push( kitPrefix + 'sonar.modules=' + validModules.join() );
        for( const moduleName of validModules ) {
            trace( 'Processing module', moduleName );
            const moduleString = loadModule( moduleName, kitPrefix + moduleName + '.' );
            if( moduleString ) {
                kitCfg.push( moduleString );
            }
        }
        return kitCfg.join( '\n' );
    }

    /**
     * @param {String} moduleName - the module name to load
     * @param {String} prefix - the prefix for the kit this module belongs to.
     * @return {String|null} the sonar-project.properties string for this module.
     */
    function loadModule( moduleName, prefix ) {
        trace( 'Loading module', moduleName );

        const moduleJson = cache.name2moduleJson[ moduleName ];
        if( !moduleJson ) {
            trace( 'Module', moduleName, '=does not exist. Skipping.' );
            return;
        }

        if( _.some( moduleJson.type, function( element ) {
                return /^(repo|war)$/.test( element );
            } ) ) {
            trace( 'Module', moduleName, 'is an invalid type. Skipping.' );
            return;
        }

        if( localVars.completedModules.includes( moduleJson.name ) ) {
            trace( 'Module', moduleName, 'has already been added (probably under a different kit). Skipping.' );
            return;
        }

        localVars.completedModules.push( moduleJson.name );

        const moduleCfg = [];
        moduleCfg.push( 'sonar.projectName=' + moduleJson.name );
        moduleCfg.push( 'sonar.projectKey=' + moduleJson.name );
        moduleCfg.push( 'sonar.projectVersion=' + localVars.packageVersion );
        moduleCfg.push( 'sonar.projectDescription=' + moduleJson.description );
        moduleCfg.push( 'sonar.projectBaseDir=' + moduleJson.moduleDir );

        // Src info
        let srcPaths = [ '*.json' ];
        if( moduleJson.srcDir ) {
            srcPaths.push( moduleJson.srcDir.substring( moduleJson.moduleDir.length + 1 ) + '/**' );
        }
        if( moduleJson.srcDir ) {
            srcPaths.push( moduleJson.srcDir.substring( moduleJson.moduleDir.length + 1 ) + '/**' );
        }
        moduleCfg.push( 'sonar.sources=' + moduleJson.moduleDir );
        moduleCfg.push( 'sonar.inclusions=' + srcPaths );

        if( !moduleJson.sonarExclusions ) { moduleJson.sonarExclusions = []; }
        // Exclude build JSON files & non-English i18n files
        util.addUnique( moduleJson.sonarExclusions, [
            '**/*.json'
        ] );
        moduleJson.sonarExclusions.sort();
        moduleCfg.push( 'sonar.exclusions=' + moduleJson.sonarExclusions );

        // Test class info
        if( moduleJson.testDir ) {
            moduleCfg.push( 'sonar.tests=' + moduleJson.testDir.substring( moduleJson.moduleDir.length + 1 ) );
            // Set both report path properties to support all versions of SonarQube
            // https://docs.sonarqube.org/display/PLUG/JavaScript+Coverage+Results+Import
            // SINCE SONARQUBE 6.2 WITH SONARJS 2.19+
            moduleCfg.push( 'sonar.javascript.lcov.reportPaths=' + normalizePath( `${process.cwd()}/coverage/lcov.info` ) );
            // WITH OTHER VERSIONS  (REMOVED SINCE SONARJS 4.0)
            moduleCfg.push( 'sonar.javascript.lcov.reportPath=' + normalizePath( `${process.cwd()}/lcov.info` ) );

        }

        // Exclude JSON files
        let sonarCoverageExclusions = [ '**/*.json' ];
        if( moduleJson.sonarCoverageExclusions ) {
            util.addUnique( sonarCoverageExclusions, moduleJson.sonarCoverageExclusions );
            sonarCoverageExclusions.sort();
        }
        moduleCfg.push( 'sonar.coverage.exclusions=' + sonarCoverageExclusions );

        return prefix + moduleCfg.join( '\n' + prefix );
    }
};
