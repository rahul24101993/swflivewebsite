const { isArray, mergeWith, uniq, uniqBy, sortBy } = require( 'lodash' );
const { readFile, readJson, writeJson } = require( 'fs-extra' );
const { stream2Promise, normalizePath, tapBlock } = require( './util' );
const gulp = require( 'gulp' );
const tap = require( 'gulp-tap' );

const concat = ( a, b ) => [ ...a, ...b ];

const mergeNestedArrays = function( a, b ) {
    //if array merge otherwise use standard merge behavior (newer overwrites)
    if( isArray( a ) ) {
        return concat( a, b );
    }
    return b;
};

//Can be dynamic in the future, fixed list is enough for initial story
const dependencyParsers = [ require( './audit/commandsViewModel_parser' ) ];
const dependencyDetectors = [ require( './audit/base_detector' ), require( './audit/commandsViewModel_detector' ) ];

/**
 * Get a list of all files in the folder (excluding directories). Paths will
 * be relative to the path provided.
 *
 * @param {String} path Directory to search in
 * @returns { List < String > } List of files in directory
 */
const getFileList = path => {
    const fileList = [];
    return stream2Promise( gulp.src( `${path}/**/*.*`, {
                //don't load contents, only need path
                buffer: false
            } )
            .pipe( tapBlock( file => {
                fileList.push( normalizePath( file.relative ) );
            } ) )
        )
        .then( () => fileList )
        .catch( () => [] );
};

/**
 * Module file loader. Similar to GraphQL data loader.
 *
 * Caches file contents to avoid repeated opens. Needs to be garbage collected
 * after module is audited to avoid potential memory issues.
 *
 * @param {Module} moduleJson The module this loader is for
 */
const ModuleFileLoader = function ModuleFileLoader( moduleJson ) {
    //Caches for each function
    const fileParseCache = {};
    const fileLoadCache = {};
    const fileListCache = {};

    /**
     * Load and parse a JSON file. If file does not exist an empty object will be returned
     *
     * @param {String} filePath Path relative to the module
     * @returns {Object} JSON contents of the file
     */
    this.getJson = async filePath => {
        if( !fileParseCache[ filePath ] ) {
            fileParseCache[ filePath ] = this.get( filePath )
                .then( contents => JSON.parse( contents ) )
                .catch( () => {
                    return {};
                } );
        }
        return fileParseCache[ filePath ];
    };

    /**
     * Load a file. If file does not exist an empty string will be returned.
     *
     * @param {String} filePath Path relative to the module
     * @returns {String} Contents of the file
     */
    this.get = async filePath => {
        if( !fileLoadCache[ filePath ] ) {
            fileLoadCache[ filePath ] = readFile( `${moduleJson.moduleDir}/${filePath}` )
                .catch( () => '' );
        }
        return fileLoadCache[ filePath ];
    };

    /**
     * Get a list of files in a directory
     *
     * @param {String} folderPath Path relative to the module
     * @returns {List<String>} List of files in the directory
     */
    this.getFileList = async folderPath => {
        if( !fileListCache[ folderPath ] ) {
            fileListCache[ folderPath ] = getFileList( `${moduleJson.moduleDir}/${folderPath}` );
        }
        return fileListCache[ folderPath ];
    };

    /**
     * Get the path of the module this loader is for
     *
     * @param {String} filePath Path relative to the module
     * @returns {String} Full file path
     */
    this.getPath = filePath => `${moduleJson.moduleDir}/${filePath}`;
};

/**
 * Get all of the dependencies detected in this module
 *
 * @param {ModuleFileLoader} loader Loader to use
 * @param {Object} mod Module json
 * @returns {Object} Dependencies detected
 */
const getModuleDependencies = async ( loader, mod ) => {
    const dependencyLists = await Promise.all( dependencyParsers.map( parser => parser.getDependencies( loader, mod ) ) );
    return mergeWith( {}, ...dependencyLists, mergeNestedArrays );
};

/**
 * Get everything available in this module
 *
 * @param {ModuleFileLoader} loader Loader to use
 * @param {Object} mod Module json
 * @returns {Object} Everything available in this module
 */
const getModuleIncluded = async ( loader, mod ) => {
    const dependencyLists = await Promise.all( dependencyDetectors.map( parser => parser.getIncluded( loader, mod ) ) );
    return mergeWith( {}, ...dependencyLists, mergeNestedArrays );
};

/**
 * Get the information (dependencies and included) for the given module
 *
 * @param {Object} mod The module to get info for
 * @returns {Object} The module information
 */
const getModuleInformation = async ( mod ) => {
    const loader = new ModuleFileLoader( mod );
    const moduleInfo = {
        dependencies: await getModuleDependencies( loader, mod ),
        included: await getModuleIncluded( loader, mod )
    };
    //things from external modules that are referenced - may still be in the same kit / kit deps
    moduleInfo.external = Object.keys( moduleInfo.dependencies )
        .reduce( ( acc, depName ) => {
            acc[ depName ] = moduleInfo.dependencies[ depName ]
                .filter( ( { id } ) => !moduleInfo.included[ depName ].includes( id ) );
            return acc;
        }, {} );
    //cleanup for better output
    for( const k of Object.keys( moduleInfo.included ) ) {
        moduleInfo.included[ k ] = uniq( moduleInfo.included[ k ] ).sort();
    }
    for( const x of [ 'dependencies', 'external' ] ) {
        for( const k of Object.keys( moduleInfo[ x ] ) ) {
            moduleInfo[ x ][ k ] = sortBy( moduleInfo[ x ][ k ], 'id' );
        }
    }
    return moduleInfo;
};

/**
 * Combine the module information for the modules included in this kit
 *
 * @param {Object} kit Kit json
 * @param {List<Object>} moduleInfoList List of module information
 * @returns {Object} The kit information
 */
const getKitInformation = ( kit, moduleInfoList ) => {
    const kitInfo = {};
    //get info for modules included in this kit
    const includedModuleData = moduleInfoList
        .filter( moduleData => kit.modules.includes( moduleData.module.name ) );
    kitInfo.modules = includedModuleData.reduce( ( acc, nxt ) => {
        acc[ nxt.module.name ] = nxt.info;
        return acc;
    }, {} );
    for( const p of [ 'dependencies', 'included' ] ) {
        kitInfo[ p ] = mergeWith( {}, ...includedModuleData.map( moduleData => moduleData.info[ p ] ), mergeNestedArrays );
    }
    kitInfo.external = Object.keys( kitInfo.dependencies )
        .reduce( ( acc, depName ) => {
            acc[ depName ] = kitInfo.dependencies[ depName ]
                .filter( ( { id } ) => !kitInfo.included[ depName ].includes( id ) );
            return acc;
        }, {} );
    //cleanup for better output
    for( const k of Object.keys( kitInfo.included ) ) {
        kitInfo.included[ k ] = uniq( kitInfo.included[ k ] ).sort();
    }
    for( const x of [ 'dependencies', 'external' ] ) {
        for( const k of Object.keys( kitInfo[ x ] ) ) {
            kitInfo[ x ][ k ] = sortBy( kitInfo[ x ][ k ], 'id' );
        }
    }
    return kitInfo;
};

/**
 * Get all kits availabe as dependencies of the provided kit. Recursively searches
 * kitDeps
 *
 * @param {Object} kit Kit to get deps for
 * @param {Object} name2kitJson Name to kit map
 * @returns {List<Object>} List of kits depended on
 */
const getDependentKits = ( kit, name2kitJson ) => {
    const curLevel = kit.kitDeps || [];
    const nestedDeps = curLevel.map( dep => getDependentKits( name2kitJson[ dep ], name2kitJson ) );
    return nestedDeps.reduce( concat, curLevel );
};

/**
 * Check a kit for invalid dependencies
 *
 * @param {Object} data Input data
 * @param {Kit} data.kit The kit.json that is being validated
 * @param {Object} data.info The dependency information for the kit
 * @param {Object} kitNameToInfo Name to kit dependency map
 * @param {Object} name2kitJson Name fo kit json map
 * @returns { List < Object > } The dependency violations detected
 */
const getMissingKitDeps = ( { kit, info }, kitNameToInfo, name2kitJson ) => {
    const kitDeps = getDependentKits( kit, name2kitJson );
    const depKitsIncluded = kitDeps.map( kitName => kitNameToInfo[ kitName ].included );
    const allIncluded = mergeWith( {}, ...depKitsIncluded, mergeNestedArrays );
    //only check external instead of included to save a bit of time
    const missingDeps = Object.keys( info.external )
        .reduce( ( acc, depName ) => {
            acc[ depName ] = info.external[ depName ]
                .filter( ( { id } ) => !allIncluded[ depName ].includes( id ) );
            return acc;
        }, {} );

    const outputErrors = [];
    for( const depType of Object.keys( missingDeps ) ) {
        for( const missingDep of missingDeps[ depType ] ) {
            const kitsWithDep = Object.keys( kitNameToInfo )
                .filter( kitName => kitNameToInfo[ kitName ].included[ depType ] && kitNameToInfo[ kitName ].included[ depType ].includes( missingDep.id ) );
            const modulesWithDepIncluded = kitsWithDep.map( kitName => {
                const targetInfo = kitNameToInfo[ kitName ];
                return Object.keys( targetInfo.modules )
                    .filter( mName => targetInfo.modules[ mName ].included[ depType ] && targetInfo.modules[ mName ].included[ depType ].includes( missingDep.id ) );
            } ).reduce( concat, [] );
            outputErrors.push( {
                kit: kit.name,
                type: depType,
                name: missingDep.id,
                line: missingDep.meta.line,
                file: missingDep.meta.file,
                sample: missingDep.meta.sample,
                source: kitsWithDep,
                sourceKit: kitsWithDep[ 0 ],
                sourceModule: modulesWithDepIncluded[ 0 ]
            } );
        }
    }
    return outputErrors;
};

module.exports = { getMissingKitDeps, getModuleInformation, getKitInformation };

/**
 * Allow this script to be executed directly to simplify debugging
 *
 * Usage: node build/js/dependencyCheck <path to module1> <path to module2> ...
 */
if( require.main === module ) {
    process.argv.slice( 2 ).map( async modulePath => {
        try {
            const moduleJson = await readJson( `${modulePath}/module.json` );
            moduleJson.moduleDir = modulePath;
            const moduleInfo = await getModuleInformation( moduleJson );
            await writeJson( `${process.cwd()}/out/audit/${moduleJson.name}_deps.json`, moduleInfo, {
                spaces: 2
            } );
        } catch ( e ) {
            console.log( e );
        }
    } );
}
