/**
 * This Script replaces the i18n key/ value duplicates specified in the i18StringDuplciates.json file
 */

const logger = require( '../logger' );
const path = require( 'path' );
const { pathExists, readdirSync, readJson, existsSync } = require( 'fs-extra' );
const { lstatSync, readFileSync, writeFileSync } = require( 'fs' );
const cache = require( process.cwd() + '/out/cache' );

let cacheMap = {};

const MSG_PREFIX = 'i18nReplace: ';

//const keyCountInJS = {};

/**
 * Flip the cache so it is easily indexed using a kit/module name
 */
function flipCache() {
    cacheMap.moduleName2moduleJson = {};
    cacheMap.kitName2kitJson = {};
    Object.keys( cache.filePath2moduleJson ).forEach( filePath => {
        const moduleJson = cache.filePath2moduleJson[ filePath ];
        if( moduleJson ) {
            cacheMap.moduleName2moduleJson[ moduleJson.name ] = {
                moduleDir: moduleJson.moduleDir,
                moduleJsonDir: filePath
            };
        }
    } );
    Object.keys( cache.filePath2kitJson ).forEach( filePath => {
        const kitJson = cache.filePath2kitJson[ filePath ];
        if( kitJson ) {
            cacheMap.kitName2kitJson[ kitJson.name ] = {
                kitDir: kitJson.kitDir,
                modules: kitJson.modules,
                kitDeps: kitJson.kitDeps
            };
        }
    } );
}

/**
 * Get the duplicateJson config file
 *
 * @param {String} configFile - file path to config file
 * @returns {Object} json object of config file
 */
async function getConfig( configFile ) {
    if( await pathExists( configFile ) ) {
        return readJson( configFile, { throws: false } );
    }
    return [];
}

/**
 * Write changes to specified filePath
 *
 * @param {String} filePath - path to write file to
 * @param {String} fileContents - contents to write out
 * @param {Function} checkoutFunction - function to checkout files from DMS
 */
function writeToFile( filePath, fileContents, checkoutFunction ) {
    try {
        writeFileSync( filePath, fileContents );
        //logger.info( `   +++ Updated ${filePath}` );
    } catch {
        if( checkoutFunction ) {
            let fileName = filePath;
            if( !fileName.includes( 'commandsViewModel' ) ) {
                fileName = path.basename( filePath );
            }
            checkoutFunction( fileName );
            writeToFile( filePath, fileContents, null );
        } else {
            logger.warn( `   Could not write to ${filePath}, this is likely do to source control` );
        }
    }
}

/**
 * Get the file directories of the effected modules
 *
 * @param {String} kitName the name of the current kit to change the i18n key/messages in
 * @param {Array<String>} modules optional param used when recursively finding all the effected modules
 * @returns {Array<String>} returns a list of module paths
 */
function getEffectedModules( kitName, modules ) {
    modules = modules ? modules : [];
    const kitJson = cacheMap.kitName2kitJson[ kitName ];
    if( kitJson ) {
        if( modules.length === 0 ) {
            Object.keys( cacheMap.kitName2kitJson ).forEach( kitKey => {
                const depKitJson = cacheMap.kitName2kitJson[ kitKey ];
                if( depKitJson.kitDeps && depKitJson.kitDeps.includes( kitName ) ) {
                    depKitJson.modules.forEach( moduleName => {
                        const moduleJson = cacheMap.moduleName2moduleJson[ moduleName ];
                        if( moduleJson && !modules.includes( moduleJson.moduleDir ) ) {
                            modules.push( moduleJson.moduleDir );
                        }
                    } );
                }
            } );
        }
        kitJson.modules.forEach( moduleName => {
            const moduleJson = cacheMap.moduleName2moduleJson[ moduleName ];
            if( moduleJson && !modules.includes( moduleJson.moduleDir ) ) {
                modules.push( moduleJson.moduleDir );
            }
        } );
        //modules.push( kitJson.kitDir );
        if( kitJson.kitDeps ) {
            kitJson.kitDeps.forEach( kitDep => {
                const kitDepJson = cacheMap.kitName2kitJson[ kitDep ];
                if( kitDepJson ) {
                    kitDepJson.modules.forEach( moduleName => {
                        const moduleJson = cacheMap.moduleName2moduleJson[ moduleName ];
                        if( moduleJson && !modules.includes( moduleJson.moduleDir ) ) {
                            modules.push( moduleJson.moduleDir );
                        }
                    } );
                }
            } );
        }
    }
    return modules;
}

/**
 * Read in the associated JSON files for module path
 *
 * @param {Array<String>} modules path to the module
 * @returns {Array<Object>} returns array of JSON file objects
 */
function getViewModelFilesForKit( modules ) {
    let viewModels = [];
    modules.forEach( modulePath => {
        if( existsSync( `${modulePath}/src/viewmodel` ) ) {
            try {
                let viewModelsForModule = readdirSync( `${modulePath}/src/viewmodel` ).filter( fileName => {
                    return !lstatSync( `${modulePath}/src/viewmodel/${fileName}` ).isDirectory();
                } )
                .map( fileName => {
                    const file = readFileSync( `${modulePath}/src/viewmodel/${fileName}` );
                    const fileObj = {};
                    fileObj.contents = JSON.parse( file );
                    fileObj.fileDir = `${modulePath}/src/viewmodel/${fileName}`;
                    return fileObj;
                } );
                viewModels = [ ...viewModels, ...viewModelsForModule ];
            } catch( e ) {
                logger.warn( e, MSG_PREFIX );
            }
        }
    } );
    return viewModels;
}

/**
 * Read in the associated JSON files for module path
 *
 * @param {String} modulePath path to the module
 * @returns {Array<Object>} returns array of JSON file objects
 */
function getI18nFilesForKit( modulePath ) {
    if( existsSync( `${modulePath}/src/i18n` ) ) {
        try {
            return readdirSync( `${modulePath}/src/i18n` ).filter( fileName => {
                return !lstatSync( `${modulePath}/src/i18n/${fileName}` ).isDirectory() && fileName.includes( 'Messages.json' );
            } )
            .map( fileName => {
                const file = readFileSync( `${modulePath}/src/i18n/${fileName}` );
                const fileObj = JSON.parse( file );
                fileObj.fileDir = `${modulePath}/src/i18n/${fileName}`;
                return fileObj;
            } );
        } catch( e ) {
            return [];
        }
    }
    return [];
}

/**
 * Read in the commandsViewModel for the given module path
 *
 * @param {Array<String>} modules path to the module
 * @returns {Array<Object>} returns array of JSON file objects
 */
function getCommandsViewModelForKit( modules ) {
    let commandsViewModel = [];
    modules.forEach( modulePath => {
        if( existsSync( `${modulePath}/commandsViewModel.json` ) ) {
            try {
                const file = readFileSync( `${modulePath}/commandsViewModel.json` );
                const fileObj = {};
                fileObj.contents = JSON.parse( file.toString().trim() );
                fileObj.fileDir = `${modulePath}/commandsViewModel.json`;
                commandsViewModel.push( fileObj );
            } catch( e ) {
                logger.warn( e, MSG_PREFIX );
            }
        }
    } );
    return commandsViewModel;
}

/**
 * Read in the associated viewHtml file for given module path and file name
 *
 * @param {String} modulePath path to the module
 * @param {String} fileName name of view file
 * @returns {Object} returns  file object
 */
function getViewHtmlFile( modulePath, fileName ) {
    let viewHtmlFile = null;
    if( existsSync( `${modulePath}/src/html` ) ) {
        try {
            viewHtmlFile = {};
            const file = readFileSync( `${modulePath}/src/html/${fileName}` );
            viewHtmlFile.contents = file.toString();
            viewHtmlFile.fileDir = `${modulePath}/src/html/${fileName}`;
        } catch( e ) {
            logger.warn( e, MSG_PREFIX );
        }
    }
    return viewHtmlFile;
}

/**
 * Read in the associated JavaScript files for given module path
 *
 * @param {String} modulePath path to the module
 * @returns {Array<Object>} returns array of JSON file objects
 */
function getJSFilesForKit( modulePath ) {
    if( existsSync( `${modulePath}/src/js` ) ) {
        return readdirSync( `${modulePath}/src/js` ).filter( fileName => {
            return !lstatSync( `${modulePath}/src/js/${fileName}` ).isDirectory();
        } )
        .map( fileName => {
            const file = readFileSync( `${modulePath}/src/js/${fileName}` );
            const fileObj = {};
            fileObj.contents = file.toString();
            fileObj.fileDir = `${modulePath}/src/js/${fileName}`;
            return fileObj;
        } );
    }
    return [];
}

/**
 * Read in the associated secondaryWorkareaTabs file for a given module
 *
 * @param {Array<String>} modules path to the module
 * @returns {Array<Object>} returns array of JSON file objects
 */
function getSecondaryWorkAreaTabsForKit( modules ) {
    let secondaryWorkAreaTabs = [];
    modules.forEach( modulePath => {
        if( existsSync( `${modulePath}/secondaryWorkAreaTabs.json` ) ) {
            try {
                const file = readFileSync( `${modulePath}/secondaryWorkAreaTabs.json` );
                const fileObj = {};
                fileObj.contents = JSON.parse( file.toString() );
                fileObj.fileDir = `${modulePath}/secondaryWorkAreaTabs.json`;
                secondaryWorkAreaTabs.push( fileObj );
            } catch( e ) {
                logger.warn( e, MSG_PREFIX );
            }
        }
    } );
    return secondaryWorkAreaTabs;
}

/**
 * Read in the associated states file for a given module
 *
 * @param {Array<String>} modules path to the module
 * @returns {Array<Object>} returns array of JSON file objects
 */
function getStatesForKit( modules ) {
    let states = [];
    modules.forEach( modulePath => {
        if( existsSync( `${modulePath}/states.json` ) ) {
            try {
                const file = readFileSync( `${modulePath}/states.json` );
                const fileObj = {};
                fileObj.contents = JSON.parse( file );
                fileObj.fileDir = `${modulePath}/states.json`;
                states.push( fileObj );
            } catch( e ) {
                return [];
            }
        }
    } );
    return states;
}

/**
 * Read in the associated decorators file for a given module
 *
 * @param {String} modulePath path to the module
 * @returns {Array<Object>} returns array of JSON file objects
 */
function getDecoratorsForKit( modulePath ) {
    if( existsSync( `${modulePath}/decorators.json` ) ) {
        try {
            const file = readFileSync( `${modulePath}/decorators.json` );
            const fileObj = {};
            fileObj.contents = JSON.parse( file );
            fileObj.fileDir = `${modulePath}/decorators.json`;
            return [ fileObj ];
        } catch( e ) {
            return [];
        }
    }
    return [];
}

/**
 * Get all the applicable jsFiles with localeService import
 *
 * @returns {Array<Object>} - jsfiles in codebase with localeService imports
 */
function getJSFilesInCodeBase( ) {
    const jsFiles = [];
    Object.keys( cache.filePath2moduleJson ).forEach( moduleDir => {
        if( existsSync( `${moduleDir}/src/js` ) ) {
            let jsFilesForModule = readdirSync( `${moduleDir}/src/js` ).filter( fileName => {
                return !lstatSync( `${moduleDir}/src/js/${fileName}` ).isDirectory();
            } ).map( fileName => {
                const file = readFileSync( `${moduleDir}/src/js/${fileName}` );
                const fileObj = {};
                fileObj.contents = file.toString();
                fileObj.fileDir = `${moduleDir}/src/js/${fileName}`;
                return fileObj;
            } ).filter( fileObj => {
                let localeServiceImport = /'js\/localeService'/g;
                let getLocalizedTextCall = /\.getLocalizedText/g;
                let getLoadedTextFromKeyCall = /\.getLoadedTextFromKey/g;
                let getLocalizedTextFromKeyCall = /\.getLocalizedTextFromKey/g;
                return localeServiceImport.test( fileObj.contents ) && ( getLocalizedTextCall.test( fileObj.contents ) ||
                    getLoadedTextFromKeyCall.test( fileObj.contents ) || getLocalizedTextFromKeyCall.test( fileObj.contents ) );
            } );
            jsFiles.push( ...jsFilesForModule );
        }
    } );
    return jsFiles;
}

/**
 * Traverse viewModel file looking for {{i18n.key}} value to replace
 *
 * @param {Object} obj - Object to traverse
 * @param {String} searchValue - search string to search viewModel for
 * @param {String} i18nReplacementKey - replacement value for updated {{i18n.key}}
 */
function parseViewModel( obj, searchValue, i18nReplacementKey ) {
    for( const key in obj ) {
        const value = obj[ key ];
        if( typeof value === 'object' ) {
            parseViewModel( value, searchValue, i18nReplacementKey );
        } else if( typeof value === 'string' && value === searchValue ) {
            obj[ key ] = i18nReplacementKey;
        }
    }
}

/**
 * Parse Html file for specified i18n key
 *
 * @param {Object} fileObj - view html object with contents and fileDir
 * @param {String} i18nKey - i18n key to remove
 * @param {Object} destination - specifies which file and key to replace in view files
 * @returns {Boolean} true if file contents have been changed
 */
function parseHtmlFileObj( fileObj, i18nKey, destination ) {
    const searchValue = `\\bi18n.${i18nKey}\\b`;
    const replaceValue = `i18n.${destination.i18nReplacementKey}`;
    let re = new RegExp( searchValue, 'g' );
    if( re.test( fileObj.contents ) ) {
        fileObj.contents = fileObj.contents.replace( re, replaceValue );
        return true;
    }
    return false;
}

/**
 * Recursively parse states.json for key/source i18n reference
 *
 * @param {Object} fileObj - json file object to traverse
 * @param {String} i18nKey - i18n Key to search for in key
 * @param {String} messagesFile - messages file to search for in source
 * @param {Object} destination - destination object with replacement values
 * @returns {Boolean} - true for file changed false for file unchanged
 */
function parseStatesFile( fileObj, i18nKey, messagesFile, destination ) {
    let diffed = false;
    Object.keys( fileObj ).forEach( searchKey => {
        if( fileObj[ searchKey ] && typeof fileObj[ searchKey ] === 'string' ) {
            if( searchKey === 'source' || searchKey === 'key' ) {
                if( fileObj.source === messagesFile && fileObj.key === i18nKey ) {
                    fileObj.key = destination.i18nReplacementKey;
                    fileObj.source = `/i18n/${destination.messagesFile}`;
                    diffed = true;
                }
            }
        } else if( fileObj[ searchKey ] && typeof fileObj[ searchKey ] === 'object' ) {
            diffed = diffed || parseStatesFile( fileObj[ searchKey ], i18nKey, messagesFile, destination );
        }
    } );
    return diffed;
}

/**
 * Recursively parse decorators.json for key/source i18n reference
 *
 * @param {Object} fileObj - json file object to traverse
 * @param {String} i18nKey - i18n Key to search for in key
 * @param {Object} destination - destination object with replacement values
 * @returns {Boolean} - true for file changed false for file unchanged
 */
function parseDecoratorsFile( fileObj, i18nKey, destination ) {
    let diffed = false;
    Object.keys( fileObj ).forEach( searchKey => {
        if( searchKey === 'i18n' && fileObj[ searchKey ][ i18nKey ] ) {
            delete fileObj[ searchKey ][ i18nKey ];
            fileObj[ searchKey ][ destination.i18nReplacementKey ] = [ destination.messagesFile ];
            diffed = true;
        } else if( fileObj[ searchKey ] && typeof fileObj[ searchKey ] === 'string' ) {
            if( fileObj[ searchKey ] === `{{i18n.${i18nKey}}}` ) {
                fileObj[ searchKey ] = `{{i18n.${destination.i18nReplacementKey}}}`;
                diffed = true;
            }
        } else if( fileObj[ searchKey ] && typeof fileObj[ searchKey ] === 'object' ) {
            diffed = diffed || parseDecoratorsFile( fileObj[ searchKey ], i18nKey, destination );
        }
    } );
    return diffed;
}

/**
 * Edit the references to i18n in the javascript for a given i18n key/ messagesFile
 *
 * @param {Object} jsFile - javaScript file object
 * @param {String} i18nKey - i18n Key to search for in jsFile
 * @param {String} messagesFile - messages file string to search for in jsFile
 * @param {Object} destination - destination object with replacement i18n key and messages file
 * @returns {Boolean} - if the file has been diffed return true
 */
function editReferencesInJSFile( jsFile, i18nKey, messagesFile, destination ) {
    //Search for instances of i18n.key
    //if i18n.key replace i18n.key with i18n.replacementKey
    let diffed = false;
    let searchKey = `i18n.${i18nKey}`;
    let replacementKey = `i18n.${destination.i18nReplacementKey}`;
    let reg = new RegExp( searchKey, 'g' );
    if( reg.test( jsFile.contents ) ) {
        jsFile.contents = jsFile.contents.replace( reg, replacementKey );
    }
    //Search for references of localeService/localeSvc getLocalizedtext
    let localSvcImport = /import( localeSvc| localeService|)( from|) 'js\/localeService'/g;
    //re = new RegExp( localSvcImport, 'g' );
    if( localSvcImport.test( jsFile.contents ) ) {
        let getLocalizedTextCall = /\.getLocalizedText/g;
        if( getLocalizedTextCall.test( jsFile.contents ) ) {
            let localizedTextFunctionCallWithParams = `\\.getLocalizedText\\( '${path.parse( messagesFile[ 0 ] ).name}', '${i18nKey}'`;
            let re = new RegExp( localizedTextFunctionCallWithParams, 'g' );
            if( re.test( jsFile.contents ) ) {
                let replacementVaue = `.getLocalizedText( '${destination.messagesFile}', '${destination.i18nReplacementKey}'`;
                jsFile.contents = jsFile.contents.replace( re, replacementVaue );
                diffed = true;
            }
        }
        let getLoadedTextFromKeyCall = /\.getLoadedTextFromKey/g;
        if( getLoadedTextFromKeyCall.test( jsFile.contents ) ) {
            let loadedTextFromKeyCallWithParams = `\\.getLoadedTextFromKey\\( '${path.parse( messagesFile[ 0 ] ).name}\\.${i18nKey}'`;
            let re = new RegExp( loadedTextFromKeyCallWithParams, 'g' );
            if( re.test( jsFile.contents ) ) {
                let replacementVaue = `.getLoadedTextFromKey( '${destination.messagesFile}.${destination.i18nReplacementKey}'`;
                jsFile.contents = jsFile.contents.replace( re, replacementVaue );
                diffed = true;
            }
        }
        let getLocalizedTextFromKeyCall = /\.getLocalizedTextFromKey/g;
        if( getLocalizedTextFromKeyCall.test( jsFile.contents ) ) {
            let getLocalizedTextFromKeyWithParams = `\\.getLocalizedTextFromKey\\( '${path.parse( messagesFile[ 0 ] ).name}\\.${i18nKey}'`;
            let re = new RegExp( getLocalizedTextFromKeyWithParams, 'g' );
            if( re.test( jsFile.contents ) ) {
                let replacementVaue = `.getLocalizedTextFromKey( '${destination.messagesFile}.${destination.i18nReplacementKey}'`;
                jsFile.contents = jsFile.contents.replace( re, replacementVaue );
                diffed = true;
            }
        }
    }
    return diffed;
}

/**
 * Find the references in the jsFile
 *
 * @param {Object} jsFile - javaScript file object
 * @param {String} i18nKey - i18n Key to search for in jsFile
 * @param {String} messagesFile - messages file string to search for in jsFile
 */
function findReferencesInJSFile( jsFile, i18nKey, messagesFile ) {
    /*let regexLocalTextBundle = new RegExp( `localTextBundle.${i18nKey};`, 'g' );
    let regex_LocalTextBundle = new RegExp( `_localTextBundle.${i18nKey};`, 'g' );
    let regexLocaleTextBundle = new RegExp( `localeTextBundle.${i18nKey};`, 'g' );
    let regexResource = new RegExp( `resource.${i18nKey};`, 'g' );
    let regexLocalizedMessages = new RegExp( `localizedMessages.${i18nKey};`, 'g' );
    */
    //let regexGetLocalizedText = new RegExp( `${}`, 'g' );
    //let regexSearchKeyDot = new RegExp( `.${i18nKey};`, 'g' );
    //let regexSearchKeyQuote = new RegExp( `'${i18nKey}' \\).then`, 'g' );
    //let regexSearchKey2Quote = new RegExp( `"${i18nKey}" \\).then`, 'g' );
    /*
    let regexSearchKeyDot = new RegExp( `.${i18nKey};`, 'g' );

    let messages = path.parse( messagesFile[ 0 ] ).name;
    let regexMessages = new RegExp( `${messages}`, 'g' );
    if( regexMessages.test( jsFile.contents ) && ( regexSearchKeyQuote.test( jsFile.contents ) || regexSearchKey2Quote.test( jsFile.contents ) ) ) {
        let messages_searchKey = `${messages}.${i18nKey}`;
        if( !keyCountInJS.hasOwnProperty( messages_searchKey ) ) {
            keyCountInJS[ messages_searchKey ] = [];
        }
        if( !keyCountInJS[ messages_searchKey ].includes( path.basename( jsFile.fileDir ) ) ) {
            keyCountInJS[ messages_searchKey ].push( path.basename( jsFile.fileDir ) );
        }
        //logger.info( `Found ${i18nKey} and ${messagesFile} in ${path.basename( jsFile.fileDir )}`, MSG_PREFIX );
    }
    */
}

/**
 * Write changes to i18n files
 *
 * @param {Array<Object>} i18nFiles - impacted i18n files with i18n key
 * @param {String} i18nKey - i18n key to remove
 * @param {Object} destination - destination object
 * @param {Object} report - reporting object
 * @param {String} moduleDir path to the module
 * @param {Function} checkoutFunction - function to checkout files from DMS
 */
function writeI18n( i18nFiles, i18nKey, destination, report, moduleDir, checkoutFunction ) {
    i18nFiles.forEach( i18nFile => {
        if( path.parse( i18nFile.fileDir ).name !== destination.messagesFile ) {
            reportImpactedFile( i18nFile, i18nKey, report, moduleDir );
            delete i18nFile[ i18nKey ];
            const fileDir = i18nFile.fileDir;
            delete i18nFile.fileDir;
            const fileContents = JSON.stringify( i18nFile, null, 4 );
            writeToFile( fileDir, fileContents, checkoutFunction );
        }
    } );
}

/**
 * Write changes to viewModel files
 *
 * @param {Array<Object>} viewModels - viewModels where i18n key references need to be overwritten
 * @param {String} i18nKey - i18n key to remove
 * @param {String} messagesFile - messages file to search for
 * @param {Object} destination - specifies which file and key to replace in view model files
 * @param {Object} report - reporting object
 * @param {String} moduleDir path to the module
 * @param {Function} checkoutFunction - function to checkout files from DMS
 */
function writeViewModelJson( viewModels, i18nKey, messagesFile, destination, report, moduleDir, checkoutFunction ) {
    viewModels.forEach( viewModel => {
        reportImpactedFile( viewModel, i18nKey, report, moduleDir, destination );
        const fileDir = viewModel.fileDir;
        delete viewModel.fileDir;
        if( viewModel.contents.i18n[ i18nKey ].includes( path.parse( messagesFile[ 0 ] ).name ) ) {
            delete viewModel.contents.i18n[ i18nKey ];
            parseViewModel( viewModel.contents, `{{i18n.${i18nKey}}}`, `{{i18n.${destination.i18nReplacementKey}}}` );
            viewModel.contents.i18n[ destination.i18nReplacementKey ] = [ destination.messagesFile ];
            const contents = JSON.stringify( viewModel.contents, null, 4 );
            writeToFile( fileDir, contents, checkoutFunction );
            const viewModelFileName = path.parse( fileDir ).name;
            if( viewModelFileName !== 'commandsViewModel' ) {
                const viewModelFileDir = path.dirname( path.dirname( path.dirname( fileDir ) ) );
                const modelIdx = viewModelFileName.lastIndexOf( 'Model' );
                if( modelIdx > -1 ) {
                    const viewHtmlFileName = viewModelFileName.substring( 0, modelIdx ) + '.html';
                    writeViewHtml( viewHtmlFileName, i18nKey, destination, report, viewModelFileDir, checkoutFunction );
                }
            }
        }
    } );
}

/**
 * Write changes to viewHtml file
 *
 * @param {String} viewHtmlFileName - view html file name where i18n key references need to be overwritten
 * @param {String} i18nKey - i18n key to remove
 * @param {Object} destination - specifies which key to overwrite with in view html files
 * @param {Object} report - reporting object
 * @param {String} moduleDir path to the module
 * @param {Function} checkoutFunction - function to checkout files from DMS
 */
function writeViewHtml( viewHtmlFileName, i18nKey, destination, report, moduleDir, checkoutFunction ) {
    const viewHtml = getViewHtmlFile( moduleDir, viewHtmlFileName );
    let searchValue = `\\bi18n.${i18nKey}\\b`;
    let re = new RegExp( searchValue, 'g' );
    if( viewHtml && re.test( viewHtml.contents ) && parseHtmlFileObj( viewHtml, i18nKey, destination ) ) {
        //reportImpactedFile( viewHtml, i18nKey, report, moduleDir, destination );
        writeToFile( viewHtml.fileDir, viewHtml.contents, checkoutFunction );
    }
}

/**
 *
 * @param {Array<Object>} javaScript - JavaScript file where i18n key references need to be replaced
 * @param {String} i18nKey - i18nKey to replace
 * @param {String} messagesFile - the messages file for the original key
 * @param {Object} destination - specifies which key to overwrite with in JavaScript files
 * @param {Object} report - reporting object
 * @param {String} moduleDir path to the module
 * @param {Function} checkoutFunction - function to checkout files from DMS
 */
function writeJavaScript( javaScript, i18nKey, messagesFile, destination, report, moduleDir, checkoutFunction ) {
    javaScript.forEach( jsFile => {
        if ( editReferencesInJSFile( jsFile, i18nKey, messagesFile, destination ) ) {
            writeToFile( jsFile.fileDir, jsFile.contents, checkoutFunction );
        }
        //findReferencesInJSFile( jsFile, i18nKey, messagesFile );
    } );
}

/**
 * Write changes to secondaryWorkAreaTabs.json
 *
 * @param {Array<Object>} secondaryWorkAreaTabs - secondaryWorkAreaTabs files to search for i18n key/value references in
 * @param {String} i18nKey - i18nKey to replace
 * @param {String} messagesFile - the messages file for the original key
 * @param {Object} destination - specifies which key to overwrite with in secondaryWorkAreaTabs files
 * @param {String} moduleDir path to the module
 * @param {Function} checkoutFunction - function to checkout files from DMS
 */
function writeSecondaryWorkAreaTabs( secondaryWorkAreaTabs, i18nKey, messagesFile, destination, moduleDir, checkoutFunction ) {
    secondaryWorkAreaTabs.forEach( secondaryWorkAreaTabFile => {
        let diffed = false;
        secondaryWorkAreaTabFile.contents.forEach( obj =>{
            if( obj.name && obj.name.key && obj.name.source ) {
                const sourceFile = `/i18n/${path.parse( messagesFile[ 0 ] ).name}`;
                if( obj.name.key === i18nKey && obj.name.source === sourceFile ) {
                    obj.name.key = destination.key;
                    obj.name.source = `/i18n/${destination.messagesFile}`;
                }
            }
            if( diffed ) {
                const contents = JSON.stringify( secondaryWorkAreaTabFile.contents, null, 4 );
                writeToFile( secondaryWorkAreaTabFile.fileDir, contents, checkoutFunction );
            }
        } );
    } );
}

/**
 * Write changes to states.json
 *
 * @param {Array<Object>} states - states files to search for i18n key/value references in
 * @param {String} i18nKey - i18nKey to replace
 * @param {String} messagesFile - the messages file for the original key
 * @param {Object} destination - specifies which key to overwrite with in states files
 * @param {String} moduleDir path to the module
 * @param {Function} checkoutFunction - function to checkout files from DMS
 */
function writeStates( states, i18nKey, messagesFile, destination, moduleDir, checkoutFunction ) {
    states.forEach( statesFile => {
        const searchFile = `/i18n/${path.parse( messagesFile[ 0 ] ).name}`;
        if( parseStatesFile( statesFile.contents, i18nKey, searchFile, destination ) ) {
            const contents = JSON.stringify( statesFile.contents, null, 4 );
            writeToFile( statesFile.fileDir, contents, checkoutFunction );
        }
    } );
}

/**
 * Write changes to decorators.json
 *
 * @param {Array<Object>} decorators - decorators files to search for i18n key/value references in
 * @param {String} i18nKey - i18nKey to replace
 * @param {String} messagesFile - the messages file for the original key
 * @param {Object} destination - specifies which key to overwrite with in decorators files
 * @param {String} moduleDir path to the module
 * @param {Function} checkoutFunction - function to checkout files from DMS
 */
function writeDecorators( decorators, i18nKey, messagesFile, destination, moduleDir, checkoutFunction ) {
    decorators.forEach( decoratorsFile => {
        if ( parseDecoratorsFile( decoratorsFile.contents, i18nKey, destination ) ) {
            const contents = JSON.stringify( decoratorsFile.contents, null, 4 );
            writeToFile( decoratorsFile.fileDir, contents, checkoutFunction );
        }
    } );
}


/**
 * Traverse duplicate object to find the destination
 *
 * @param {Object} obj - duplicate object
 * @returns {Object} destination object for i18n key/value
 */
function traverseDuplicate( obj ) {
    if( typeof obj === 'object' ) {
        //get first key value pair
        const objKeys = Object.keys( obj );
        return traverseDuplicate( obj[ objKeys[ 0 ] ] );
    } else if( typeof obj === 'string' ) {
        return path.parse( obj ).name;
    }
    return {};
}

/**
 * Gets the destination messages and i18n key when replacing i18n key duplicate
 *
 * @param {String} kitName the current kit that is being evaluated
 * @param {Object} duplicateJson duplicates kit locations
 * @returns {Object} returned destination
 */
function getDestination( kitName, duplicateJson ) {
    for( const kit in duplicateJson ) {
        if( kit !== kitName || Object.keys( duplicateJson ).length === 1 ) {
            const i18nReplacementKey = Object.keys( duplicateJson[ kit ] )[ 0 ];
            return { i18nReplacementKey: i18nReplacementKey, messagesFile: traverseDuplicate( duplicateJson[ kit ] ) };
        }
    }
    return {};
}

/**
 *
 * @param {*} impactedFile -
 * @param {*} i18nKey -
 * @param {*} report -
 * @param {*} moduleDir -
 * @param {*} destination -
 */
function reportImpactedFile( impactedFile, i18nKey, report, moduleDir, destination ) {
    if( destination ) {
        if( !report[ moduleDir ].hasOwnProperty( 'oldKeys' ) ) {
            report[ moduleDir ].oldKeys = [ i18nKey ];
            report[ moduleDir ].newKeys = [ destination.i18nReplacementKey ];
            report[ moduleDir ].messages = [ destination.messagesFile ];
        } else {
            report[ moduleDir ].oldKeys.push( i18nKey );
            report[ moduleDir ].newKeys.push( destination.i18nReplacementKey );
            report[ moduleDir ].messages.push( destination.messagesFile );
        }
    } else if( impactedFile.fileDir.includes( 'Messages.json' ) ) {
        if( !report[ moduleDir ].hasOwnProperty( 'deletedKeys' ) ) {
            report[ moduleDir ].deletedKeys = [ i18nKey ];
        } else {
            report[ moduleDir ].deletedKeys.push( i18nKey );
        }
    }
    if( !report[ moduleDir ].hasOwnProperty( 'impactedFiles' ) ) {
        report[ moduleDir ].impactedFiles = [ path.basename( impactedFile.fileDir ) ];
    } else if( !report[ moduleDir ].impactedFiles.includes( path.basename( impactedFile.fileDir ) ) ) {
        report[ moduleDir ].impactedFiles.push( path.basename( impactedFile.fileDir ) );
    }
}

/**
 *
 * @param {Object} report - reporting object
 */
function outputReport( report ) {
    Object.entries( report ).forEach( ( [ moduleDir, keyData ] ) => {
        let moduleName = cache.filePath2moduleJson[ moduleDir ].name;
        logger.info( `  Module: ${moduleName}`, MSG_PREFIX );
        if( keyData.deletedKeys ) {
            logger.info( `    Deleted ${keyData.deletedKeys.length} duplicate i18n keys from messages files`, MSG_PREFIX );
        }
        if( keyData.oldKeys ) {
            logger.info( `    Replaced ${keyData.oldKeys.length} i18n key references in view/viewmodel files`, MSG_PREFIX );
        }
        if( keyData.impactedFiles ) {
            logger.info( '    Below shows list of edited files', MSG_PREFIX );
            keyData.impactedFiles.forEach( fileName => {
                logger.info( `      ${fileName}`, MSG_PREFIX );
            } );
        }
    } );
}

/**
 * Process and write changes for each kit and its module files
 *
 * @param {Object} kitJson - json object for current kit
 * @param {Array} jsFiles - list of jsFiles in codebase that import localeService
 * @param {Function} checkoutFunction - function to checkout files from DMS
 * @returns {Number} amount of strings edited
 */
function processKit( kitJson, jsFiles, checkoutFunction ) {
    let count = 0;
    const report = {};
    Object.keys( kitJson.duplicates ).forEach( i18nValue => {
        const duplicateJson = kitJson.duplicates[ i18nValue ];
        //process destination file/key
        const destination = getDestination( kitJson.kitName, duplicateJson );
        let modules = getEffectedModules( kitJson.kitName );
        //replace references in viewModels update i18n files
        Object.keys( duplicateJson ).forEach( kitName => {
            if( kitName === kitJson.kitName ) {
                const duplicateForKit = duplicateJson[ kitName ];
                Object.keys( duplicateForKit ).forEach( i18nKey => {
                    const i18nKeyJson = duplicateForKit[ i18nKey ];
                    Object.entries( i18nKeyJson ).forEach( ( [ moduleDir, messagesFile ] ) => {
                        if( !report.hasOwnProperty( moduleDir ) ) {
                            report[ moduleDir ] = {};
                        }
                        const viewModelsForModule = getViewModelFilesForKit( modules ).filter( viewModel => {
                            return viewModel.contents.i18n && viewModel.contents.i18n.hasOwnProperty( i18nKey );
                        } );
                        const commandsViewModelForModule = getCommandsViewModelForKit( modules ).filter( commandsViewModel => {
                            return commandsViewModel.contents.i18n && commandsViewModel.contents.i18n.hasOwnProperty( i18nKey );
                        } );
                        const i18nFilesForModule = getI18nFilesForKit( moduleDir ).filter( i18nFile => {
                            return i18nFile.hasOwnProperty( i18nKey );
                        } );
                        const secondaryWorkAreaTabs = getSecondaryWorkAreaTabsForKit( modules );
                        const states = getStatesForKit( modules );
                        const decorators = getDecoratorsForKit( modules );
                        writeViewModelJson( [ ...viewModelsForModule, ...commandsViewModelForModule ], i18nKey, messagesFile, destination, report, moduleDir, checkoutFunction );
                        writeI18n( i18nFilesForModule, i18nKey, destination, report, moduleDir, checkoutFunction );
                        writeJavaScript( jsFiles, i18nKey, messagesFile, destination, report, moduleDir, checkoutFunction );
                        writeSecondaryWorkAreaTabs( secondaryWorkAreaTabs, i18nKey, messagesFile, destination, moduleDir, checkoutFunction );
                        writeStates( states, i18nKey, messagesFile, destination, moduleDir, checkoutFunction );
                        writeDecorators( decorators, i18nKey, messagesFile, destination, moduleDir, checkoutFunction );
                        // count += i18nFilesForModule.length;
                    } );
                } );
            }
        } );
    } );
    //outputReport( report );
    return count;
}

/**
 * Main function to run program
 *
 * @param {Object} options arguments for program
 */
async function main( options ) {
    if( !options.i18nConfigFile ) {
        let erroMsg = 'Pass the i18nConfigFile option to the script.';
        throw new Error( erroMsg );
    }
    const configJson = await getConfig( options.i18nConfigFile );
    logger.info( `Using ${options.i18nConfigFile} for configuration`, MSG_PREFIX );
    flipCache();
    const jsFiles = getJSFilesInCodeBase();
    for( const kitJson of configJson ) {
        if( !options.kitName || options.kitName && options.kitName === kitJson.kitName ) {
            logger.info( `Processing kit: ${kitJson.kitName}`, MSG_PREFIX );
            processKit( kitJson, jsFiles, options.checkoutFunction );
        }
    }
    /* Object.keys( keyCountInJS ).forEach( ( key ) => {
        logger.info( `Found ${key} in ${keyCountInJS[ key ].length} javascript file(s)` );
    } );
    util.writeFile( 'out/keysInJS.json', JSON.stringify( keyCountInJS, null, 4 ) );
    */
}

if( require.main === module ) {
    const argv = require( 'yargs' )
        .demandCommand( 0 )
        .usage( 'Usage: node $0 [options]' )
        .example( 'node $0 --i18nConfigFile i18nStringDuplicates.json' )
        .options( {
            i18nConfigFile: {
                description: 'i18n String Duplciation file generated by the audit',
                default: undefined
            }
        } )
        .argv;
    main( argv );
}
module.exports = main;

