/* eslint-disable no-implicit-globals */

const _ = require( 'lodash' );
const fse = require( 'fs-extra' );
const fs = require( 'fs' );

const util = require( '../util' );

/**
 * Calculates the duplicate i18n strings and writes them to a file
 *
 * @param {Object} cache - cache
 * @returns {Number} count - the amount of duplicate i18n strings
 */
const calculateDuplicateI18N = async function( { filePath2kitJson, name2kitJson } ) {
    let duplicatesArr = [];
    let count = 0;
    for( const [ filePath2Kit, kitJson ] of Object.entries( filePath2kitJson ) ) {
        let duplicateObject = { kitName: kitJson.name, duplicates: {}, kitDir: filePath2Kit };
        //find dups within kit
        for( let index = 0; index < kitJson.i18nFiles.length; index++ ) {
            count += getDuplicatesWithinKit( index, kitJson, duplicateObject.duplicates );
        }
        //find dups in kitDeps
        if( kitJson.kitDeps ) {
            for( const depKitName of kitJson.kitDeps ) {
                const depKitJson = name2kitJson[ depKitName ];
                if ( depKitJson && kitJson.i18nFiles.length > 0 && depKitJson.i18nFiles.length > 0 ) {
                    // outer loop kitJson
                    count += getDuplicatesInDepKit( kitJson, depKitJson, duplicateObject.duplicates );
                }
            }
        }
        if( Object.keys( duplicateObject.duplicates ).length > 0 ) {
            duplicatesArr.push( duplicateObject );
        }
    }
    util.writeFile( 'out/i18nStringDuplicates.json', JSON.stringify( duplicatesArr ) );
    return count;
};
module.exports.calculateDuplicateI18N = calculateDuplicateI18N;


/**
 * Get the i18n files for a given directory and return their messages
 *
 * @param {String} dir - directory to i18nFiles
 * @returns {Array} list of fileDir and messages of i18n files
 */
async function geti18nFiles( dir ) {
    if( await fse.pathExists( `${dir}/src/i18n` ) ) {
        return Promise.all( fs.readdirSync( `${dir}/src/i18n` ).filter( file => file.includes( 'Messages.json' ) ).map( async fileName => {
            return {
                moduleDir: dir,
                fileName: fileName,
                messages: await fse.readJson( `${dir}/src/i18n/${fileName}`, { throws: false } )
            };
        } ) );
    }
    return [];
}
module.exports.geti18nFiles = geti18nFiles;

/**
 * Get the duplicates from within a kit
 *
 * example: Kit A has two instances of "Favorites"
 *
 * @param {Number} index current index of i18nFiles[]
 * @param {Array} kitJson array of i18n files
 * @param {Object} duplicates duplicate object of key value fileDir pairs
 * @returns {Number} count the amount of duplicate i18n strings
 */
const getDuplicatesWithinKit = function( index, kitJson, duplicates ) {
    let count = 0;
    for( let i = index + 1; i < kitJson.i18nFiles.length;  i++ ) {
        count += compareI18nFiles( kitJson.i18nFiles[ index ], kitJson.i18nFiles[ i ], duplicates, kitJson, kitJson );
    }
    return count;
};

/**
 * Get the duplicates from a kit dependency
 * example: Kit A is dependent on Kit B and both have an instance of "Favorites"
 *
 * @param {Object} kitJson for current kit in iteration
 * @param {Object} depKitJson for current dependent kitJson in iteration
 * @param {Object} duplicates duplicate object of key value fileDir pairs
 * @returns {Number} count the amount of duplicate i18n strings
 */
const getDuplicatesInDepKit = function( kitJson, depKitJson, duplicates ) {
    let count = 0;
    for( const file of kitJson.i18nFiles ) {
        for( const depFile of depKitJson.i18nFiles ) {
            count += compareI18nFiles( file, depFile, duplicates, kitJson, depKitJson );
        }
    }
    return count;
};

/**
 * Traverse object and enter in data as needed
 *
 * @param {Object} obj object to added queued data to
 * @param {Array} queue the array of values to enter into the obj
 * @returns {Integer} count 0 if no duplicte is found, 1 if duplicate is found
 *
 */
const traverse = function( obj, queue ) {
    if( queue.length > 2 ) {
        const key = queue[ 0 ];
        if( !obj.hasOwnProperty( key ) ) {
            obj[ key ] = {};
        }
        queue.shift();
        return traverse( obj[ key ], queue );
    } else if( queue.length > 1 ) {
        const key = queue[ 0 ];
        if( !obj.hasOwnProperty( key ) ) {
            obj[ key ] = [];
        }
        if( !obj[ key ].includes( queue[ 1 ] ) ) {
            obj[ key ].push( queue[ 1 ] );
            return 1;
        }
    }
    return 0;
};

/**
 * Compare i18n Files and build duplicates JSON object
 *
 * @param {Object} file file from kitJson
 * @param {Object} depFile file to compare
 * @param {Object} duplicates duplicate object of key value fileDir pairs
 * @param {Object} kitJson current kitJson of the kit
 * @param {Object} depKitJson the dependent kitJson from the current kitDeps
 * @returns {Number} count the amount of duplicate i18n strings
 */
const compareI18nFiles = function( file, depFile, duplicates, kitJson, depKitJson ) {
    let count = 0;
    for( let [ key1, val1 ] of Object.entries( file.messages ) ) {
        for( let [ key2, val2 ] of Object.entries( depFile.messages ) ) {
            if( val1 === val2 ) {
                if( !duplicates.hasOwnProperty( val1 ) ) {
                    duplicates[ val1 ] = {};
                }
                let queue = [ kitJson.name, key1, file.moduleDir, file.fileName ];
                count += traverse( duplicates[ val1 ], queue );
                queue = [ depKitJson.name, key2, depFile.moduleDir, depFile.fileName ];
                count += traverse( duplicates[ val1 ], queue );
            }
        }
    }
    return count;
};
