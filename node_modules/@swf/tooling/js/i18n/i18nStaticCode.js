/* eslint-disable complexity, sonarjs/cognitive-complexity, sonarjs/no-duplicate-string */
const logger = require( '../logger' );
const { normalizePath, getLineNumber } = require( '../util' );

let _strictMode = false;
let scaCache;
let i18nCache;

const setI18NGlobalVars = function( scaCacheCopy, cacheCopy, strictModeSettingCopy ) {
    scaCache = scaCacheCopy;
    i18nCache = cacheCopy.audit.i18n;
    _strictMode = strictModeSettingCopy;
};

/**
 * Check if value is a valid i18n input for being localizable
 *
 * @param {String} propertyType - property type
 * @param {String} propertyName - property name
 * @param {String} propertyValue - value
 * @param {Array} jsonI18nKeys - list of i18n keys defined in the viewModel
 * @param {Object} issues - object containing the array of warnings and issues to add to
 */
function checkIfValidI18nValue( propertyType, propertyName, propertyValue, jsonI18nKeys, issues ) {
    if( !/^{/.test( propertyValue ) && !jsonI18nKeys.includes( propertyValue ) && !jsonI18nKeys.includes( `{{${propertyValue}}}` ) && propertyValue !== '' && propertyValue !== '*' && isNaN(
        propertyValue ) ) {
        issues.errors.push( `ViewModel object [${propertyType}] has field [${propertyName}] with a value of [${JSON.stringify( propertyValue )}], which is not localized!` );
    }
    // If it has {{i18n.xyz}}, need to check that xyz is defined in the file's i18n keys
    if( isNaN( propertyValue ) && propertyValue.includes( '{{i18n.' ) ) {
        const i18nKey = propertyValue.split( 'i18n.' )[ 1 ].replace( '}}', '' );
        if( !jsonI18nKeys.includes( i18nKey ) ) {
            issues.warnings.push( `ViewModel object [${propertyType}] has field [${propertyName}] which refers to the i18n key [${i18nKey}], which is not defined inside the viewModel's i18n object!` );
        }
    }
}

/**
 * Method to ensure any i18n supported field uses i18n
 *
 * @param {File} file - the json file
 * @param {String} contents - the file contents
 * @param {Object} issues - object containing the array of warnings and issues to add to.
 */
function ensureViewModelI18nUsage( file, contents, issues ) {
    // Only enforece in strict mode (internal)
    if( !_strictMode ) {
        return;
    }
    // If file is in whitelist, then skip
    const filePath = normalizePath( file.path ).substring( process.cwd().length + 5 );
    if( scaCache.i18nViewModelAudit.nonLocalizedValuesWhitelist.includes( filePath ) ) {
        return;
    }
    for( const dir of scaCache.i18nViewModelAudit.ignorePaths ) {
        if( filePath.includes( `${dir}/` ) ) {
            return;
        }
    }
    // Note: processViewModelI18nUsage() covers auditing the i18n object in the file. This is for properties that use the i18n object.
    const jsonContents = JSON.parse( contents );
    // Have array of keys to check against, since both {{i18n.key}} and {{key}} and key are valid references
    const jsonI18nKeys = [];
    if( jsonContents.i18n ) {
        for( const [ key, values ] of Object.entries( jsonContents.i18n ) ) {
            jsonI18nKeys.push( key );
            if( Array.isArray( values ) ) {
                for( let val of values ) {
                    val = val.replace( '.json', '' );
                    if( !/Messages$/.test( val ) && !/Constants$/.test( val ) ) {
                        issues.errors.push( `I18N defined key [${key}] has value [${val}] which does not reference a valid i18n translation file!` );
                    }
                }
            } else {
                const val = values.replace( '.json', '' );
                if( !/Messages$/.test( val ) && !/Constants$/.test( val ) ) {
                    issues.errors.push( `I18N defined key [${key}] has value [${val}] which does not reference a valid i18n translation file!` );
                }
            }
        }
    }
    // Verify that all localizable properties on commands outside the i18n obj, are localized
    if( jsonContents.messages ) {
        for( const [ messageName, message ] of Object.entries( jsonContents.messages ) ) {
            if( message.messageText ) {
                checkIfValidI18nValue( 'messages', messageName, message.messageText, jsonI18nKeys, issues );
            }
            if( message.navigationOptions ) {
                for( const option of message.navigationOptions ) {
                    if( option.text ) {
                        checkIfValidI18nValue( 'navigationOptions text', messageName, option.text, jsonI18nKeys, issues );
                    }
                }
            }
            // Message's can also be referenced in other i18n properties
            jsonI18nKeys.push( messageName );
        }
    }
    if( jsonContents.commands ) {
        for( const [ cmdId, command ] of Object.entries( jsonContents.commands ) ) {
            if( command.title ) {
                if( command.title.text ) {
                    checkIfValidI18nValue( `Command ${cmdId}`, 'title.text', command.title.text, jsonI18nKeys, issues );
                } else {
                    checkIfValidI18nValue( `Command ${cmdId}`, 'title', command.title, jsonI18nKeys, issues );
                }
            }
            if( command.description && typeof command.description === 'string' ) {
                checkIfValidI18nValue( `Command ${cmdId}`, 'description', command.description, jsonI18nKeys, issues );
            }
            if( command.description && typeof command.description === 'object' && command.description.text && typeof command.description.text === 'string' ) {
                checkIfValidI18nValue( `Command ${cmdId}`, 'description.text', command.description.text, jsonI18nKeys, issues );
            }
            if( command.selected ) {
                if( command.selected.title ) {
                    checkIfValidI18nValue( `Command ${cmdId}`, 'selected.title', command.selected.title, jsonI18nKeys, issues );
                }
                if( command.selected.description ) {
                    checkIfValidI18nValue( `Command ${cmdId}`, 'selected.description', command.selected.description, jsonI18nKeys, issues );
                }
            }
        }
    }
    if( jsonContents.data ) {
        for( const [ dataName, dataObj ] of Object.entries( jsonContents.data ) ) {
            if( dataObj ) {
                if( dataObj.displayName ) {
                    if( dataObj.displayName.text ) {
                        checkIfValidI18nValue( `Data Object ${dataName}`, 'displayName.text', dataObj.displayName.text, jsonI18nKeys, issues );
                    } else {
                        checkIfValidI18nValue( `Data Object ${dataName}`, 'displayName', dataObj.displayName, jsonI18nKeys, issues );
                    }
                }
                if( dataObj.dispValue ) {
                    checkIfValidI18nValue( `Data Object ${dataName}`, 'dispValue', dataObj.dispValue, jsonI18nKeys, issues );
                }
                if( dataObj.displaynameprop ) {
                    checkIfValidI18nValue( `Data Object ${dataName}`, 'displaynameprop', dataObj.displaynameprop, jsonI18nKeys, issues );
                }
                if( dataObj.tooltipprop ) {
                    checkIfValidI18nValue( `Data Object ${dataName}`, 'tooltipprop', dataObj.tooltipprop, jsonI18nKeys, issues );
                }
                if( dataObj.tooltip ) {
                    checkIfValidI18nValue( `Data Object ${dataName}`, 'tooltip', dataObj.tooltip, jsonI18nKeys, issues );
                }
                if( dataObj.dbValue && typeof dataObj.dbValue === 'object' && dataObj.dbValue !== null && !Array.isArray( dataObj.dbValue ) ) {
                    try {
                        for( const entry of dataObj.dbValue ) {
                            if( entry.displayName ) {
                                checkIfValidI18nValue( 'Data Object dbValue', 'displayName', entry.displayName, jsonI18nKeys, issues );
                            }
                            if( entry.propDisplayValue ) {
                                checkIfValidI18nValue( 'Data Object dbValue', 'propDisplayValue', entry.propDisplayValue, jsonI18nKeys, issues );
                            }
                            if( entry.dispValue ) {
                                checkIfValidI18nValue( 'Data Object dbValue', 'dispValue', entry.dispValue, jsonI18nKeys, issues );
                            }
                            if( entry.tooltip ) {
                                checkIfValidI18nValue( 'Data Object dbValue', 'tooltip', entry.tooltip, jsonI18nKeys, issues );
                            }
                        }
                    } catch ( err ) {
                        logger.error( err );
                    }
                } else if( dataObj.dbValue && typeof dataObj.dbValue === 'string' && dataObj.dbValue !== 'false' && dataObj.dbValue !== 'true' ) {
                    // checkIfValidI18nValue( 'Data Object', 'dbValue', dataObj.dbValue, jsonI18nKeys, issues );
                }
                if( dataObj.steps ) {
                    for( const entry of dataObj.steps ) {
                        if( entry.propertyDisplayName ) {
                            checkIfValidI18nValue( 'Steps', 'propertyDisplayName', entry.propertyDisplayName, jsonI18nKeys, issues );
                        }
                    }
                }
                if( dataObj.tiles ) {
                    for( const entry of dataObj.tiles ) {
                        if( entry.displayName ) {
                            checkIfValidI18nValue( 'Tile', 'displayName', entry.displayName, jsonI18nKeys, issues );
                        }
                    }
                }
                if( dataObj.validationCriteria ) {
                    for( const entry of dataObj.validationCriteria ) {
                        if( entry && entry.value ) {
                            checkIfValidI18nValue( 'ValidationCriteria', 'value', entry.value, jsonI18nKeys, issues );
                        }
                    }
                }
            }
        }
    }
    if( jsonContents.columnProvider ) {
        for( const [ column, props ] of Object.entries( jsonContents.messages ) ) {
            if( props.displayName ) {
                checkIfValidI18nValue( `Column ${column}`, 'displayName', props.displayName, jsonI18nKeys, issues );
            }
        }
    }
    if( jsonContents.actions ) {
        for( const [ action, props ] of Object.entries( jsonContents.actions ) ) {
            if( props.actionsMessages ) {
                for( const actionMessages of Object.entries( props.actionsMessages ) ) {
                    for( const entry of actionMessages ) {
                        if( entry.message ) {
                            checkIfValidI18nValue( `Action ${action}`, 'message', entry.message, jsonI18nKeys, issues );
                        }
                    }
                }
            }
        }
    }
    if( jsonContents.onEvent ) {
        for( const [ eventName, eventData ] of Object.entries( jsonContents.onEvent ) ) {
            if( eventData.message ) {
                checkIfValidI18nValue( `Event ${eventName}`, 'message', eventData.message, jsonI18nKeys, issues );
            }
        }
    }
}

/**
 * Validate that all i18n keys are defined in messages files, and that all messages files exist.
 *
 * @param {Object} file - file object
 * @param {String} messagesFile - the i18n messages file being referenced
 * @param {String} key - the i18n key being referenced
 * @param {Object} issues - object containing the array of warnings and issues to add to
 */
function validateI18nKeysAndFiles( file, messagesFile, key, issues ) {
    if( !i18nCache || !scaCache.i18nViewModelAudit ) {
        return;
    }
    // If file is in whitelist, then skip
    const filePath = normalizePath( file.path ).substring( process.cwd().length + 5 );
    if( scaCache.i18nViewModelAudit.nonLocalizedValuesWhitelist.includes( filePath ) ) {
        return;
    }
    for( const dir of scaCache.i18nViewModelAudit.ignorePaths ) {
        if( filePath.includes( `${dir}/` ) ) {
            return;
        }
    }
    messagesFile = messagesFile.replace( '/i18n/', '' );
    const messagesContents = i18nCache[ messagesFile ];
    if( _strictMode ) {
        if( messagesContents && !messagesContents.includes( key ) && !scaCache.i18nViewModelAudit.missingKeysWhitelist.includes( filePath ) ) {
            issues.errors.push( `The i18n key [${key}] does not exist in the messagesFile [${messagesFile}]` );
        } else if( !messagesContents && !scaCache.i18nViewModelAudit.missingMessagesWhitelist.includes( filePath ) ) {
            issues.errors.push( `The i18n messagesFile [${messagesFile}] does not exist!` );
        }
    } else {
        if( messagesContents && !messagesContents.includes( key ) ) {
            issues.errors.push( `i18n key: '${key}' is not defined in '${messagesFile}' file` );
        } else if( !messagesContents ) {
            issues.errors.push( `i18n messagesFile: '${messagesFile}' does not exist` );
        }
    }
}

/**
 * Method to process i18n dependencies found in *ViewModel.json files.
 *
 * @param {File} file - the json file
 * @param {String} contents - the file contents
 * @param {Object} issues - object containing the array of warnings and issues to add to.
 */
function processViewModelI18nUsage( file, contents, issues ) {
    if( !i18nCache || !scaCache.i18nViewModelAudit ) {
        return;
    }
    const jsonContents = JSON.parse( contents );
    if( jsonContents && jsonContents.i18n ) {
        for( const key in jsonContents.i18n ) {
            const messagesFiles = jsonContents.i18n[ key ];
            if( typeof messagesFiles !== 'string' ) {
                let isValid = true;
                let finalMessagesFile;
                for( const messagesFile of messagesFiles ) {
                    const messagesContents = i18nCache[ messagesFile ];
                    if( messagesContents && messagesContents.includes( key ) ) {
                        isValid = false;
                    }
                    finalMessagesFile = messagesFile;
                }
                if( isValid ) {
                    validateI18nKeysAndFiles( file, finalMessagesFile, key, issues );
                }
            }
        }
    }
}

/**
 * Function to recursively search a given set of keys on an object
 *
 * @param {Object} obj json object to search
 * @param {Array} arr arr
 */
function findI18nRefsInJsonObject( obj, arr ) {
    if( obj.source && obj.key ) {
        arr.push( {
            source: obj.source,
            key: obj.key
        } );
    }
    Object.keys( obj ).forEach( key => {
        if( obj[ key ] && typeof obj[ key ] === 'object' ) {
            findI18nRefsInJsonObject( obj[ key ], arr );
        }
    } );
}

/**
 * Method to process i18n dependencies found in states.json files.
 *
 * @param {Object} file - the json file
 * @param {String} contents - file contents
 * @param {Object} issues - object containing the array of warnings and issues to add to.
 */
function processStatesJsonI18nUsage( file, contents, issues ) {
    let i18nRefs = [];
    const jsonContents = JSON.parse( contents );
    findI18nRefsInJsonObject( jsonContents, i18nRefs );
    for( const i18nRef of i18nRefs ) {
        const messagesFile = i18nRef.source.replace( '/i18n/', '' );
        const key = i18nRef.key;
        validateI18nKeysAndFiles( file, messagesFile, key, issues );
    }
}

/**
 * Method to process i18n dependencies found in secondaryWorkAreaTabs.json files.
 *
 * @param {Object} file - the json file
 * @param {String} contents - file contents
 * @param {Object} issues - object containing the array of warnings and issues to add to.
 */
function processSecondaryWorkareaTabsJsonI18nUsage( file, contents, issues ) {
    let i18nRefs = [];
    const jsonContents = JSON.parse( contents );
    if ( jsonContents.secondaryWorkareaTab ) {
        for ( const swaTab of jsonContents.secondaryWorkareaTab ) {
            findI18nRefsInJsonObject( swaTab, i18nRefs );
        }
        for( const i18nRef of i18nRefs ) {
            const messagesFile = i18nRef.source.replace( '/i18n/', '' );
            const key = i18nRef.key;
            validateI18nKeysAndFiles( file, messagesFile, key, issues );
        }
    }
}

/**
 * Method to process i18n dependencies found in JavaScript files.
 *
 * @param {File} file - the JavaScript file
 * @param {Object} fileInfo - see pre_audit_prep
 * @param {Object} issues - object containing the array of warnings and issues to add to.
 */
function processJavaScriptI18nUsage( file, fileInfo, issues ) {
    const jsI18nPatterns = [
        'getLocalizedTextFromKey',
        'getLoadedTextFromKey',
        'getLocalizedText'
    ];
    if( fileInfo && fileInfo.deps.includes( 'js/localeService' ) ) {
        const contents = file.contents.toString();
        for( const pattern of jsI18nPatterns ) {
            let i18nRegExp = new RegExp( `\\.${pattern}\\(( |)`, 'g' );
            while( i18nRegExp.exec( contents ) !== null ) {
                let patternFound = i18nRegExp.lastIndex;
                const bolIdx = contents.lastIndexOf( '\n', patternFound );
                const eolIdx = contents.indexOf( '\n', patternFound );
                if( bolIdx > -1 && eolIdx > -1 && eolIdx > bolIdx ) {
                    let line = contents.substring( patternFound, eolIdx ).trim();
                    const firstQuoteIdx = line.indexOf( '\'' );
                    const lastQuoteIdx = line.lastIndexOf( '\'' );
                    if( firstQuoteIdx > -1 && lastQuoteIdx > -1 && lastQuoteIdx > firstQuoteIdx ) {
                        line = line.substring( firstQuoteIdx + 1, lastQuoteIdx ).trim();
                        const parenIdx = line.indexOf( ')' );
                        if( parenIdx > -1 ) {
                            line = line.substring( 0, parenIdx ).trim();
                        }
                        let idx;
                        if( pattern === 'getLocalizedText' ) {
                            idx = line.lastIndexOf( ',' );
                        } else {
                            idx = line.lastIndexOf( '.' );
                        }
                        const messagesFile = line.substring( 0, idx ).replace( /'/g, '' );
                        const key = line.substring( idx + 1, line.length ).replace( /'/g, '' ).trim();
                        if( key && messagesFile ) {
                            validateI18nKeysAndFiles( file, messagesFile, key, issues );
                        }
                    }
                }
            }
        }
    } else {
        return;
    }
}

/**
 * Method to process i18n dependencies found in secondaryWorkAreaTabs.json files.
 *
 * TODO: Maybe we need to incorporate the html-lint here for finding hard-coded strings, instead of it being a seperate npm cmd
 *
 * @param {Object} text - the html text
 * @param {String} txtInx - index
 * @param {String} contents - file contents
 * @param {Object} elem - element
 * @param {String} j - index
 * @param {String} viewFileName - name of the view file
 * @param {Object} issues - object containing the array of warnings and issues to add to.
 */
function processViewI18nUsage( text, txtInx, contents, elem, j, viewFileName, issues ) {
    const i18Inx = text[ txtInx ].search( 'i18n' );
    if( i18Inx === -1 ) { // not in localization
        const lineNumber = getLineNumber( contents, text[ txtInx ], 0 );
        issues.errors.push(
            '"' + text[ txtInx ] + '" in "' + elem[ j ] + '" at line number ' + lineNumber +
            ' of the file: ' + viewFileName +
            '.html should be localized' );
    }
}

module.exports = {
    ensureViewModelI18nUsage,
    processViewModelI18nUsage,
    processSecondaryWorkareaTabsJsonI18nUsage,
    processStatesJsonI18nUsage,
    setI18NGlobalVars,
    processJavaScriptI18nUsage,
    processViewI18nUsage
};
