// Copyright (c) 2021 Siemens

/**
 * @file Audits the HTML files to find hard-coded innerHTML
 */

const fse = require( 'fs-extra' );
const logger = require( '../logger' );
const { fail } = require( 'assert' );
const { spawn } = require( '../util' );
const { filter } = require( 'lodash' );

const optionsPath = [
    `${process.cwd()}/conf/staticCodeAnalysis_dev.json`,
    `${process.cwd()}/build/conf/staticCodeAnalysis_dev.json`,
    `${process.cwd()}/src/conf/staticCodeAnalysis_dev.json`,
    `${process.cwd()}/src/build/conf/staticCodeAnalysis_dev.json`,
]

// Get the staticCodeAnalysis_dev.json
let auditOptions = {};
const scaPaths = filter( optionsPath, optPath => fse.existsSync( optPath ) );
if( scaPaths && scaPaths.length ) {
    auditOptions = require( `${scaPaths[0]}` ).i18nHtmlAudit;
}

const msgPrefix = 'html-lint: ';
const npxCmd = process.platform === 'win32' && 'npx.cmd' || 'npx';
const stopwatchAll = new logger.Stopwatch();

// Ignore any file which is under an ignored folder
const ignoredFilePath = function( line ) {
    const pathArr = line.split( '/' );
    for( const folder of pathArr ) {
        if( auditOptions.ignorePaths.includes( folder ) || /sample/.test( folder ) ) {
            return true;
        }
    }
    return false;
};

// Ignore any file which is in the whitelist
const getWhitelistStatus = function( currentFile ) {
    if( auditOptions.whitelist.includes( currentFile.trim() ) ) {
        return true;
    }
    return false;
};

// The 3rd party npm package reports all innerHTML
// This function checks if the innerHTML is really a string or if it's actually i18n/dataProvider calls, or if it's code
const isActualString = function( line, hardCodedWarnLine ) {
    let tagName = hardCodedWarnLine.split( '<' )[ 1 ].split( '>' )[ 0 ];
    let innerHtml = line;
    if( innerHtml.split( '>' ).length - 1 === innerHtml.split( '>"' ).length ) {
        // If they are all inner attributes, ignore
        return false;
    }
    if ( tagName === '%' ) {
        // Don't lint hard-coded JS Code
       return false;
    }
    if( line.includes( '>' ) && line.includes( '</' ) && !line.includes( `<${tagName} ` ) && !line.includes( '</text>' ) ) {
        try {
            let splitArr = innerHtml.split( `<${tagName}>` );
            innerHtml = splitArr[ 1 ].split( '</' )[ 0 ];
        } catch ( err ) {
            // Continue
        }
    } else if( line.includes( `<${tagName} ` ) ) {
        try {
            let splitArr = innerHtml.split( '>' );
            let splitToParse;
            // Need to find correct entry, for when multiple tags exist on one line
            for( const entry of splitArr ) {
                if( entry.includes( `</${tagName}` ) ) {
                    splitToParse = entry.split( '<' );
                }
            }
            innerHtml = splitToParse[ 0 ];
        } catch ( err ) {
            // Continue
        }
    } else if( line.includes( '</text>' ) ) {
        try {
            let splitArr = innerHtml.split( '>{' );
            splitArr = splitArr[ 1 ].split( '</text>' );
            // Since the split will remove the {, have to re-add it
            innerHtml = `{${splitArr[0]}`;
        } catch ( err ) {
            // Continue
        }
    } else {
        // If it got here, likely is innerHTML on own line, so need to remove line number and trim out white-space
        innerHtml = line.split( '|' )[ 1 ].trim();
    }
    // Check if valid i18n call
    if( innerHtml.startsWith( 'i18n.' ) || line.includes( '>i18n.' ) ) {
        return false;
    }
    // Check if valid dataProvider call
    if( innerHtml.startsWith( '{' ) && innerHtml.endsWith( '}' ) || innerHtml.includes( '{{' ) ) {
        return false;
    }
    // Empty strings are fine
    if( innerHtml === '' ) {
        return false;
    }
    // Check if it's actual JSCode
    const jsTermArr = [ 'var ', 'if(', 'if (', ' += ', ' === ', ' || ', ' && ', 'for(', 'for (' ];
    for( const term of jsTermArr ) {
        if( line.includes( term ) ) {
            return false;
        }
    }
    return true;
};

// Main function to run the audit
( async () => {
    try {
        // Run the i18n html audit to an output file
        const logPath = `${process.cwd()}/out/html_allHardcodedTags.txt`;
        const errorLogPath = `${process.cwd()}/out/html_errors.txt`;
        // eslint-disable-next-line no-unused-vars
        const code = await spawn( npxCmd, [ 'i18n-lint', auditOptions.lintPath ], null, logPath, line => { return true; }, msgPrefix );
        // Read in the output
        const fileLines = fse.readFileSync( logPath ).toString().split( '\n' );
        // Itterate through to find all the errors
        let numErrors = 0;
        let errorArray = [];
        let currentFile = '';
        let newFile = true;
        let numWhitelistFiles = 0;
        let numWhitelistErrors = 0;
        for( let i = 0; i < fileLines.length; i++ ) {
            const line = fileLines[ i ];
            if( line && line.includes( '.html' ) && !line.includes( 'i18n-lint' ) ) {
                currentFile = line;
                newFile = true;
            }
            // Check and process if it's a valid hard-coded string
            if( line && line.includes( 'Hardcoded <' ) && fileLines[ i - 1 ] && fileLines[ i - 1 ].trim() !== '' && !ignoredFilePath( currentFile ) && isActualString( fileLines[ i - 1 ], line ) ) {
                const isWhitelisted = getWhitelistStatus( currentFile );
                if( newFile && isWhitelisted ) {
                    errorArray.push( currentFile + '    [WHITELISTED]' );
                    newFile = false;
                    numWhitelistFiles += 1;
                } else if( newFile ) {
                    errorArray.push( currentFile );
                    logger.error( currentFile, msgPrefix );
                    newFile = false;
                }
                const previousLineArray = fileLines[ i - 1 ].split( '|' );
                if( !isWhitelisted ) {
                    errorArray.push( `    ${previousLineArray[0].trim()}: ${previousLineArray[1].trim()}` );
                    logger.error( `    ${previousLineArray[0].trim()}: ${previousLineArray[1].trim()}`, msgPrefix );
                    numErrors += 1;
                } else {
                    errorArray.push( `    ${previousLineArray[0].trim()}: ${previousLineArray[1].trim()}` );
                    numWhitelistErrors += 1;
                }
            }
        }
        const errorToPrint = errorArray.join( '\n' );
        // Only write the log file if there are errors
        if( errorToPrint !== '' ) {
            await fse.writeFile( errorLogPath, errorToPrint.toString() );
        }
        if( numWhitelistFiles > 0 ) {
            logger.warn( `WARNING! ${numWhitelistFiles} file(s) are whitelisted to not fail the audit, but have ${numWhitelistErrors} issues! See: ${errorLogPath} for more details.`, msgPrefix );
        }
        if( numErrors > 0 && code !== 0 ) {
            logger.error( `FAILED! ${numErrors} hard-coded strings were found in html files! See: ${errorLogPath} for more details.`, msgPrefix );
            logger.error( `FAILED! Exit code = ${code}${stopwatchAll.end()}`, msgPrefix );
            process.exit( code );
        } else {
            logger.success( `Successful${stopwatchAll.end()}` );
        }
    } catch ( err ) {
        fail( `Audit failed with the following error: \n ${err}` );
    }
} )();
