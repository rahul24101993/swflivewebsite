/* eslint-disable no-undef */
/* eslint-disable require-jsdoc */
/* eslint-disable valid-jsdoc */

const fs = require( 'fs' );
const _ = require( 'lodash' );
const gulp = require( 'gulp' );
// const gulpIf = require( 'gulp-if' );
const htmlParser = require( 'html-parser' );
const buildJsonPath = `${process.cwd()}/build.json`;
const buildJson = fs.existsSync( buildJsonPath ) ? require( buildJsonPath ) : null;
const util = require( './buildUtil' );
const logger = require( './buildLogger' );
const through = require( 'through2' );

// hold all the actions in VM which will be used in view later
// categorized by module->vm->actions
/**
 * {
 *      module1: {
 *          vm1: {
 *              action1: {},
 *              action2: {},
 *              ...
 *          }
 *      }
 *      module2: {
 *          vm1: {
 *              action1: {},
 *              action2: {},
 *              ...
 *          }
 *      }
 * }
 *
 */
let ignorePaths = [ 'i18n', 'test', 'policies', 'schema', 'audit', 'module.json', 'states.json', 'kit.json' ];
let preCheck = false;
let count = 0;
let dump = 0;
let [ jsonFiles, htmlFiles, jsFiles ] = [ {}, {}, {} ];
const viewModelPopupActions = {};
const jsPopupActions = {}; // TODO
const TYPES = {
    popupRelated: /"js\/popupService"/,
    popupActionRelated: ( action ) => {
        action = action || '';
        return new RegExp( `action=("|')${action}("|')`, 'g' );
    }
};

function check( content, reg ) {
    return reg.test( content );
}

// https://regex101.com/
/**
 * Full match D:\workdir\devunits\ba1\src\thinclient\architecturemodelerjs\src\any.other.js
 * Group 1. D:\workdir\devunits\ba1\src\thinclient\architecturemodelerjs\
 * Group 2. any.other
 * Group 3. js
 */
const ModulePathAndFileNameAndExtensionReg = /(.*)src(?!.*src).*[\\/]([^\\/]+)\.([^\\/]+)/;

function getModulePathAndExtensionReg( filePath ) {
    let matched = ModulePathAndFileNameAndExtensionReg.exec( filePath );
    if( matched ) {
        return {
            module: matched[ 1 ],
            name: matched[ 2 ],
            ext: matched[ 3 ]
        };
    }
    logger.error( 'getModulePathAndExtensionReg failed for: ' + filePath );
}

const ensurePath = ( module, name ) => {
    if( !viewModelPopupActions[ module ] ) {
        viewModelPopupActions[ module ] = {};
    }
    if( !viewModelPopupActions[ module ][ name ] ) {
        viewModelPopupActions[ module ][ name ] = {};
    }
};

function processViewModel( stringContent, module, name, filePath ) {
    ensurePath( module, name );
    let modified = false;
    let jsonData = JSON.parse( stringContent.trim() );
    //popup declView deps
    let popupCompileContext = {};
    for( const action in jsonData.actions ) {
        const actionDetails = jsonData.actions[ action ];
        if( actionDetails.deps === 'js/popupService' && actionDetails.method === 'show' &&
            actionDetails.inputData && actionDetails.inputData.data ) {
            const view = actionDetails.inputData.data.declView; // optional
            // transform popup show Actions to follow our new design
            // const newPopupAction = `${action}__popupAction`;
            // override by using the same action name
            const newPopupAction = `${action}`;
            let params = actionDetails.inputData.data;
            let options = { view, ...params.options };
            // deal with locals
            if( params.locals ) {
                Object.assign( options, params.locals );
                // to deal with caption in i18n case
                params.locals.caption && ( options.preset = 'modal' );
            }
            // deal with subPanelContext
            if( params.subPanelContext ) {
                options.subPanelContext = params.subPanelContext;
            }

            // maybe null
            const outputData = actionDetails.outputData;

            // save the new action
            const old = _.cloneDeep( jsonData.actions[ action ] );
            const _new = { actionType: 'popup', inputData: { options }, outputData };
            jsonData.actions[ newPopupAction ] = _new;

            // modify the view to use the new popupAction instead of old action
            popupCompileContext[ action ] = newPopupAction;

            // register the popup view
            let details = {
                view,
                popupCompileContext
            };

            viewModelPopupActions[ module ][ name ][ action ] = details;
            console.log( `transform action from: ${JSON.stringify( old )}\n to \n ${JSON.stringify( _new )}` );
            jsonFiles[ filePath ] = true;
            modified = true;
        }
        // if( actionDetails.deps === 'js/popupService' && actionDetails.method === 'hide' ) {
        //     // backup by rename - cancel backup
        //     // jsonData.actions[ `${action}__old` ] = _.cloneDeep( jsonData.actions[ action ] );

        //     let deps = 'js/popupService';
        //     // transform popup hide Actions to follow our new design
        //     jsonData.actions[ action ] = { ...jsonData.actions[ action ], deps };
        //     jsonFiles[filePath] = true;
        //     modified = true;
        // }
    }

    //modify file contents
    return modified ? JSON.stringify( jsonData, undefined, 4 ) : stringContent;
}

const buildHtmlReg = ( elementName, actionName ) => new RegExp( `(<${elementName} [\\s\\S]*?action=")(${actionName})("[\\s\\S]*?</${elementName}>)`, 'gm' );

function processView( stringContent, transformedActions, filePath ) {
    const allActions = Object.keys( transformedActions );

    let elements = [];
    let elementName = null;
    let actionName = null;
    htmlParser.parse( stringContent, {
        openElement: ( name ) => { elementName = name; },
        attribute: ( name, value ) => {
            if( name === 'action' && allActions.indexOf( value ) > -1 ) {
                // recording the elements which need perform replacement
                actionName = value;
                elements.push( { elementName, actionName } );
            }
        }
    } );

    elements.length > 0 && ( htmlFiles[ filePath ] = true );

    // do replacement
    elements.forEach( ( { elementName, actionName } ) => {
        const { view, popupCompileContext } = transformedActions[ actionName ];
        let newAction = popupCompileContext[ actionName ];
        // let show = popupCompileContext.requireContext ? 'showWithContext({ context:{data, i18n} })' : 'show';
        // let newActionShow = `${newAction}.${show}`;

        let htmlReg = buildHtmlReg( elementName, actionName );
        stringContent = stringContent.replace( htmlReg, ( match, g1, g2, g3 ) => {
            if( match ) {
                const _new = `<aw-popup-wrapper popup="${newAction}">
                    ${g1}${newAction}${g3}
                </aw-popup-wrapper>`;
                console.log( `transform view from: ${match}\n to \n ${_new}` );

                return _new;
            }
        } );
    } );

    return stringContent;
}

function checkIgnore( path ) {
    let ignore = false;
    let segments = path.split( /\\/ );
    segments.forEach( item => {
        if( ignorePaths.indexOf( item ) > -1 ) {
            ignore = true;
            return false;
        }
    } );
    return ignore;
}

function migratePopup() {
    // go through all viewModel and view file
    return through.obj( ( file, encoding, callback ) => {
        if( file.isStream() ) {
            logger.severe( 'Cannot use streamed files' );
            return callback();
        }

        const { module, name, ext } = getModulePathAndExtensionReg( file.path ) || {};
        // not a valid file
        // or excluded
        if( !module || checkIgnore( file.path ) ) { return callback(); }
        count++;

        var content = file.contents.toString( encoding );
        if( ext === 'json' ) {
            if( check( content, TYPES.popupRelated ) ) {
                content = processViewModel( content, module, name, file.path );
                file.contents = Buffer.from( content, encoding );
                console.log( 'process file done: ', file.path );
            } else {
                logger.info( `skip ${file.path}, no popup action involved` );
                return callback();
            }
        } else if( ext === 'js' ) {
            // TODO - FUTURE
            return callback();
        } else if( ext === 'html' ) {
            // go through all actions for the same module and view/viewModel
            // "filePath": "assets/html/awPopupDraggableView.html"
            // "filePath": "assets/viewmodel/awPopupDraggableViewModel.json"

            // old way
            // <Any prop="data.box1" action="displayPopup"></Any>

            // new way
            // <AwPopupWrapper popup={actions.displayPopup__popupAction}>
            //     <Any {...getField('data.box1', fields)} action={actions.displayPopup__popupAction.show}>
            //     </Any>
            // </AwPopupWrapper>
            const relatedVMName = `${name}Model`;
            const transformedActions = viewModelPopupActions[ module ] && viewModelPopupActions[ module ][ relatedVMName ] ? viewModelPopupActions[ module ][ relatedVMName ] : null;
            const allActions = transformedActions ? Object.keys( transformedActions ) : null;
            const allActionsReg = allActions && allActions.length > 0 ? `(${allActions.join( '|' )})` : null;
            if( allActionsReg && check( content, TYPES.popupActionRelated( allActionsReg ) ) ) {
                content = processView( content, transformedActions, file.path );
                file.contents = Buffer.from( content, encoding );
                console.log( 'process file done: ', file.path );
            } else {
                logger.info( `skip ${file.path}, no popup action involved` );
                return callback();
            }
        }

        callback( null, file );
    } );
}

function report() {
    let key1 = Object.keys( jsonFiles );
    let key2 = Object.keys( htmlFiles );
    let section1 = key1.join( ' ' );
    let section2 = key2.join( ' ' );
    console.log( `\n\nReports: ${count} files processed, ${key1.length} jsonFiles and ${key2.length} htmlFiles were impacted. \n` );
    console.log( `\n\npreCheck Files: \n
    ${section1} ${section2}\n` );
    console.log( `
        jsonFiles: \n ${section1} \n
        htmlFiles: \n ${section2} \n
    ` );
    console.log( JSON.stringify( viewModelPopupActions, undefined, 4 ) );
}

/**
 * migratePopup from old usage to new usage
 *
 * @param {Object} argv input options (--sourcePath)
 */
async function main( argv ) {
    const filePath = argv.sourcePath;
    // for DMS code base, we first need to
    // 1, find all related files,  --preCheck serve this step
    // 2, check out
    // 3, transform
    preCheck = Boolean( argv.preCheck );
    if( !filePath ) {
        var errorMsg = `Pass sourcePath option to script, see following example you can pass single file relative path or multiple glob paths by comma separated.
        Example: migratePopup --sourcePath=src/**/*.json, src/**/*.html`;
        throw new Error( errorMsg );
    }
    var sourcepaths = [];
    var modulePaths = filePath.split( ',' );
    for( var modulePath in modulePaths ) {
        modulePath = modulePaths[ modulePath ].trim();
        sourcepaths.push( modulePath );
    }

    const gulpSrc = gulp.src( sourcepaths, { base: './' } )
        .pipe( migratePopup() )
        // https://stackoverflow.com/questions/51495785/nodejs-gulp-through2-limitation-to-16-files?
        // The next line handles the "consumption" of upstream pipings
        .on( 'data', ( { data, path } ) => ++dump )
        .on( 'finish', () => {
            preCheck && report();
        } )
        .on( 'error', err => console.log( 'ERR: ', err ) )
        .pipe( gulp.dest( './' ) )
        .on( 'error', err => {
            console.log( 'Migration failed, please try to check out "preCheck" files and try again! ', err );
        } );
    await util.stream2Promise( gulpSrc );
}
if( require.main === module ) {
    const argv = require( 'yargs' )
        .demandCommand( 0 )
        .usage( 'Usage: node $0 [options]' )
        .example( 'node $0 --sourcePath=src/**/uielements/src/**/*.js [--preCheck=1]' )
        .options( {
            sourcePath: {
                description: 'Relative source path/glob path of to be transformed files',
                default: undefined
            }
        } )
        .argv;
    main( argv ).catch( logger.error );
}
module.exports = main;
