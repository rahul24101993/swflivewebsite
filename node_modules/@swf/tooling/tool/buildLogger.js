/* eslint-disable no-multi-assign */

const chalk = require( 'chalk' );
const gulp = require( 'gulp' );
const path = require( 'path' );
const prettyTime = require( 'pretty-hrtime' );
const { createLogger, format, transports } = require( 'winston' );

exports.errorColor = chalk.red;
exports.warnColor = chalk.yellow;
exports.successColor = chalk.green;
exports.infoColor = chalk.green.dim;
exports.debugColor = chalk.gray;
exports.traceColor = chalk.yellow.dim;

/**
 * @param {String} filename - filename to create debug trace object
 * @param {String} suffix - suffix for trace name
 * @return {Object} trace object
 */
exports.createTrace = ( filename, suffix ) => {
    const name = path.basename( filename, '.js' ) + ( suffix || '' );
    return require( 'debug' )( name );
};

exports.nameColor = chalk.cyan;
exports.pathColor = chalk.yellow.bold;

const level = process.env.GULP_LOG_LEVEL || process.env.LOG_LEVEL || 'verbose';

// Support error objects
const enumerateErrorFormat = format( info => {
    if( info.message instanceof Error ) {
        info.message = Object.assign( {
            message: info.message.message,
            stack: info.message.stack
        }, info.message );
    } else if( info instanceof Error ) {
        return Object.assign( {
            message: info.message,
            stack: info.stack
        }, info );
    }
    return info;
} );

// Configure logger & transports
var wlogger = createLogger( {
    format: format.combine(
        enumerateErrorFormat(),
        format.timestamp( { format: 'HH:mm:ss' } ),
        format.json()
    ),
    transports: [
        new transports.File( {
            level: level,
            filename: process.cwd() + '/build.log',
            options: { flags: 'w' },
            format: format.combine(
                format.uncolorize(),
                format.printf( info => {
                    info.prefix = stripColors( info.prefix );
                    info.message = stripColors( info.message );
                    return output( info );
                } )
            )
        } ),
        new transports.Console( {
            level: level,
            format: format.combine(
                process.env.TERM === 'dumb' ? format.uncolorize() : format.colorize(),
                format.printf( info => {
                    if( process.env.TERM === 'dumb' ) {
                        info.prefix = stripColors( info.prefix );
                        info.message = stripColors( info.message );
                    } else {
                        info.timestamp = chalk.gray( info.timestamp );
                    }
                    return output( info );
                } )
            )
        } )
    ],
    exitOnError: false // do not exit on handled exceptions
} );

/**
 * @param {Object} info - info
 * @return {String} formatted string
 */
function output( info ) {
    let output = '';
    for( let line of exports.extractLines( info.message ) ) {
        line = line.replace( /^\[[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\] /, '' );
        // line = line.replace( /^.(info|debug|warn|error).: /, '' );
        output += `${output && '\n'}[${info.timestamp}] ${info.level}: ${info.prefix}${line}`;
    }
    return output;
}

// https://www.npmjs.com/package/winston#logging
exports.isErrorEnabled = wlogger.isErrorEnabled;
exports.isWarnEnabled = wlogger.isWarnEnabled;
exports.isInfoEnabled = wlogger.isInfoEnabled;
exports.isVerboseEnabled = wlogger.isVerboseEnabled;
exports.isDebugEnabled = wlogger.isDebugEnabled;
exports.isSillyEnabled = wlogger.isSillyEnabled;

exports.error = ( msg, prefix ) => logIt( 'error', prefix, exports.errorColor( msg ) );
exports.warn = ( msg, prefix ) => logIt( 'warn', prefix, exports.warnColor( msg ) );
exports.info = ( msg, prefix ) => {
    let level = 'info';
    // The following block is to support enhancing the Karma output by escalating output level.
    if( /^ERROR LOG/.test( msg ) ) {
        level = 'error';
        msg = exports.errorColor( msg );
    } else if( /^WARN LOG/.test( msg ) ) {
        level = 'warn';
        msg = exports.warnColor( msg );
    }
    logIt( level, prefix, msg );
};
exports.verbose = ( msg, prefix ) => logIt( 'verbose', prefix, exports.debugColor( msg ) );
exports.debug = ( msg, prefix ) => logIt( 'debug', prefix, exports.debugColor( msg ) );
exports.silly = ( msg, prefix ) => logIt( 'silly', prefix, exports.traceColor( msg ) );

// Legacy logger APIs which aren't standard Winston
exports.success = ( msg, prefix ) => exports.info( exports.successColor( msg ), prefix );
exports.trace = exports.silly;
exports.severe = exports.error;
exports.isTraceEnabled = exports.isSillyEnabled;

/**
 * Log message to console.
 *
 * @param {String} level - level
 * @param {undefined|null|String} prefix - prefix
 * @param {String} msg - message
 */
function logIt( level, prefix, msg ) { // eslint-disable-line no-implicit-globals
    wlogger.log( {
        level: level,
        message: msg || '',
        prefix: prefix || ''
    } );
}

/**
 * Extract lines from input content.
 *
 * @param {String} contents - input contents
 * @return {*|Array} array of lines
 */
exports.extractLines = contents => {
    return contents.toString().split( /\r?\n/ );
};

/**
 * Strip out any ANSI color escape codes.
 *
 * @param {String} input - input
 * @return {String} output w/o ANSI colors
 */
function stripColors( input ) {
    return input.toString().replace( /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, '' ); // eslint-disable-line
}

/**
 * Basic error check & reporting with the logger.
 *
 * @param {Object} err - error
 * @param {Stream|null} stream - stream [optional]
 */
exports.checkErr = ( err, stream ) => {
    if( err ) {
        exports.error( err );
        process.exit( 1 );
        if( stream ) {
            stream.emit( 'error', err );
        }
        throw err;
    }
};

/**
 * Utility method for processing the error event in a Gulp pipe.
 *
 * @param {Object} err - error message
 */
exports.pipeErrorHandler = err => {
    require( 'debug' )( 'util:pipeErrorHandler' )( err );
    exports.error( err );
    process.exit( 1 );
};

/**
 * Stop watch
 */
exports.Stopwatch = class StopWatch {
    /**
     */
    constructor() {
        this.hrstart = process.hrtime();
    }

    /**
     * End stop watch
     * @return {String} output string to append to line for stopwatch timing
     */
    end() {
        const hrend = process.hrtime( this.hrstart );
        // using same color & pretty-hrtime that gulp uses
        return chalk.magenta( ' (' + prettyTime( hrend ) + ')' );
    }
};
