// Copyright (c) 2020 Siemens
/* eslint-env node */
const jsdom = require( 'jsdom' );
const _ = require( 'lodash' );
const utils = require( '../rewired/utils' );
var { attributesToProps } = require( 'html-react-parser' );

const BaseIndent = '    ';

// DOM Node type in browser
const Node = {
    ELEMENT_NODE: 1,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11
};

const globalHigherOrderAttrs = [
    'extended-tooltip',

    'visible-when',
    'enable-when',
    'exist-when',
    'aw-click',
    'aw-right-click',
    'aw-click-options',
    'aw-class',
    'aw-enter-key',
    'aw-autofocus',
    'aw-enter',
    'aw-long-press',
    'aw-highlight-property-html',
    'aw-parse-html',
    'display-val',
    'show-when',
    'depend-on',
    'on-change'
];

/**
 * Parse view string as DOM without interpret it
 * @param {string} str view template as string
 * @returns {Element} DOM Fragement with all changes
 */
const parseView = str =>
    new jsdom.JSDOM( `<div>${str}</div>` ).window.document.body.firstChild;

/**
 * convert attribute value which presents an action
 * @param {string} str attribute value for action in HTML
 * @returns {string} action expression as string
 */
const mapAttrToAction = str => `actions.${str}`;

/**
 * convert attribute value which presents an message
 * @param {string} expr expression attribute value in HTML
 * @param {string} str attribute value for action in HTML
 * @returns {string} message expression as string
 */
const mapAttrToMessage = ( expr, str ) => expr ? `messages[${expr}]` : `messages.${str}`;

/**
 * convert attribute value which presents an grid id
 * @param {string} expr expression attribute value in HTML
 * @param {string} str attribute value for action in HTML
 * @returns {string} message expression as string
 */
const mapAttrToGrid = ( expr, str ) => expr ? `grids[${expr}]` : `grids.${str}`;

/**
 * convert expression to expression parsed by AwParse.
 * For example myVar => AwParseService.instance( 'myVar' )({ data, ctx })
 *
 * @param {string} str expression string
 * @param {object} locals local variables
 * @returns {string} expression parsed by AwParse
 */
const mapExprToAwParse = ( str, locals ) => str ? `AwParseService.instance( ${JSON.stringify( str )} )( { ${Object.keys( locals ).join( ', ' )} } )` : '';

const getCompName = ( elem ) => {
    let compName = utils.kebabCaseToPascalCase( elem.nodeName.toLowerCase() );

    let hocAttrs = globalHigherOrderAttrs.filter( ( attr ) => {
        return elem.hasAttribute( attr + '-hoc' );
    } );
    if( hocAttrs && hocAttrs.length > 0 ) {
        return utils.kebabCaseToPascalCase( compName + '-' + hocAttrs.join( '-' ) );
    }
    return compName;
};

const evaluateAttr = ( elem, currLine, context, viewDesc, ignoreList ) => {
    let index = context.index;

    const attrLenth = elem.attributes.length || 0;
    const classLength = elem.classList.length || 0;
    let isRepeatParent = context.isRepeatParent;
    if( elem.hasAttribute( 'ignoreIsRepeatParent' ) ) {
        isRepeatParent = false;
    }

    if( attrLenth + classLength > 0 || index === true ) {
        for( let i = 0; i < attrLenth; i++ ) {
            let attrVal = elem.attributes[ i ];
            if( ignoreList.indexOf( attrVal.name ) === -1 ) {
                currLine = currLine.concat( mapAttr( elem, elem.attributes[ i ], {
                    props: viewDesc,
                    isRepeatParent: isRepeatParent,
                    childExp: context.childExp,
                    parentExp: context.parentExp,
                    locals: { ...context.locals }
                }, true ) );
            }
        }

        // append react index
        if( index === true ) {
            currLine = currLine.concat( 'key={$index}' );
        }
    }

    return currLine;
};

/**
 * .
 *  This would maps the form validation related props to new format.
 *  AwPanelBody.$valid to formProp.attributes.valid
 * @param {string} str expression string
 */
const replaceFormValidation = ( str ) => {
    if( /awPanelBody\.\$valid/.test( str ) ) {
        str = str.replace( /awPanelBody\.\$valid/, 'formProp.attributes.valid' );
    }
    if( /awPanelBody\.\$dirty/.test( str ) ) {
        str = str.replace( /awPanelBody\.\$dirty/, 'formProp.attributes.dirty' );
    }
    return str;
};

const pattern = /{{(.+?)}}/g;
const parse = ( value, context ) => {
    // reset lastIndex
    pattern.lastIndex = 0;

    let result = null;
    let final = '`';
    let lastIndex = 0;
    while( ( result = pattern.exec( value ) ) !== null ) {
        final += value.substring( lastIndex, result.index );
        final += '${' + mapExprToAwParse( result[ 1 ], context ) + '}';
        lastIndex = pattern.lastIndex;
    }
    final += value.substring( lastIndex, value.length ) + '`';
    return final;
};

const isNumeric = ( input ) => {
    return input !== undefined &&
        input !== null &&
        ( typeof input === 'number' || parseInt( input, 10 ) == input );
};

/**
 * process HTML attribute to JSX attribute
 * @param {Element} node DOM node
 * @param {Attr} attr DOM attribute
 * @param {object} context attribute mapping context
 * @param {boolean} convertNameToReact if true will convert name to react OOTB attribute ( default: false )
 * @returns {Array} result as string
 */
const mapAttr = ( node, attr, context, convertNameToReact = false ) => {
    let name = attr.name;
    let value = attr.value;
    const res = [];

    if( convertNameToReact ) {
        // - Many react 'DOM attrs' are different with HTML's - Please refer to reactjs.org/docs/dom-elements.html
        //   - In some cases like 'class' and 'autocomplete' it will stll working without conversion but react
        //     will show a warning.
        //    - For some case it will not work at all without conversion here
        //
        // - Two approaches to make it work:
        //   - Write our own ReactAttrMap.
        //   - Use 3rd party like https://www.npmjs.com/package/html-react-parser

        // if React version < 16 and attribute is custom, attributesToProps returns empty object
        // if React version >=16 then it preserve custom attribute
        let attReactName = attributesToProps( {[ name ]: value } );
        name = _.isEmpty( attReactName ) ? name : Object.keys( attReactName )[ 0 ];
    }

    if( globalHigherOrderAttrs.filter( ( attr ) => attr + '-hoc' === name ).length === 1 ) {
        name = name.substring( 0, name.lastIndexOf( '-hoc' ) );
        name = _.camelCase( name );
    }

    const propDesc = context.props && context.props[ name ];
    if( propDesc ) {
        name = _.camelCase( name );
    }

    if( value ) {
        let expr = null;
        let resExpr = null;

        if( name === 'style' ) {
            // process style separately
            let styleObj = attributesToProps( { 'style': value } )["style"];
            let styleObjPropArray = [];
            for( const prop in styleObj ) {
                if( styleObj.hasOwnProperty( prop ) ) {
                    let propVal = isNumeric(styleObj[prop]) ? styleObj[prop] : '\''+styleObj[prop]+'\'';
                    styleObjPropArray.push(`${prop}: ${propVal}`);
                }
            }
            let style = 'style={{'+styleObjPropArray.join(', ')+'}}';
            res.push( style );
        } else if( name === 'extended-tooltip-context' || name === 'extended-tooltip-options' || name === 'ext-tooltip-data' ) {
            value = value.replace( /(\r\n|\n|\r)/gm, '' ).trim();
            res.push( `${_.camelCase( name )}={${mapExprToAwParse( value, context.locals )}}` );
        } else if( value.startsWith( 'i18n.' ) ) {
            // 20200810: Special logic for attr="i18n.myExpr"
            res.push( `${name}={${value}}` );
        } else if( name === 'ref' || name === 'dom-ref' ) {
            // 2021118: handle reference
            res.push( `${_.camelCase( name )}={${mapExprToAwParse( value, context.locals )}}` );
        } else {
            // value maybe in case: "{{item.region}}/{{item.Title}}"
            let matches = value.match( pattern );
            if( matches && matches.length >= 2 ) {
                expr = parse( value, context.locals );
            } else {
                // normal case
                let match = value.startsWith( '{{' ) && value.endsWith( '}}' );
                if( match ) {
                    value = replaceFormValidation( value );
                    expr = mapExprToAwParse( value.substr( 2, value.length - 4 ), context.locals );
                }
            }

            const propType = propDesc && propDesc.type;
            switch ( propType ) {
                case 'field':
                    // use of data in repeat
                    resExpr = `{...getField("${value}", fields, $index, null, null )}`;
                    if( context.isRepeatParent ) {
                        // handly for aw-repeat on field coming from props or subPanelContext...
                        if( context.parentExp.startsWith( 'props.' ) || context.parentExp.startsWith( 'subPanelContext.' ) ) {
                            resExpr = `{...${mapExprToAwParse( value, context.locals )}}`;
                        } else if( value.startsWith( context.childExp ) ) {
                            //  line is for atomic data with aw-repeat
                            resExpr = `{...getField("${value}", fields, $index, '${context.parentExp}', {${Object.keys( context.locals ).join( ', ' )}}  )}`;
                        }
                    } else if( value.startsWith( 'props.' ) || value.startsWith( 'subPanelContext.' ) ) {
                        resExpr = `{...${mapExprToAwParse( value, context.locals )}}`;
                    }
                    break;
                case 'grid':
                    resExpr = `{...${mapAttrToGrid( expr, value )}}`;
                    break;
                case 'object':
                case 'viewModelObject':
                    resExpr = `${name}={${mapExprToAwParse( value, context.locals )}}`;
                    break;
                case 'action':
                    resExpr = value.split( '.' ).length > 1 ? `${name}={${mapExprToAwParse( value, context.locals )}}` : `${name}={${mapAttrToAction( value )}}`;
                    break;
                case 'message':
                    resExpr = `${name}={${mapAttrToMessage( expr, value )}}`;
                    break;
                case 'popup':
                    resExpr = `{...${mapExprToAwParse( value, context.locals )}}`;
                    break;
                case 'string':
                default:
                    resExpr = expr ? `${name}={${expr}}` : `${name}="${value}"`;
                    break;
            }

            if( name === 'viewId' ) {
                resExpr += ` viewPath={${mapExprToAwParse( 'viewPath', context.locals )}}`;
            }

            res.push( resExpr );
        }
    }
    return res;
};

const mapChildNodes = ( elem, context ) => {
    const contents = [];
    const level = context.level || 0;
    const childLength = elem.childNodes.length;
    if( childLength > 0 ) {
        for( let i = 0; i < childLength; i++ ) {
            let childDomNode = elem.childNodes[ i ];
            let childContents = context.compileFn( childDomNode, {
                ...context,
                level: level + 1,
                // index: i,
                // assume it will be in JSX context
                isExprContext: false
            } );

            if( childContents && childContents.length > 0 ) {
                contents.push( childContents.join( '\n' ) );
            }
        }
    }
    return contents;
};

const mapExprToAwFilter = ( filterArr, setExpr, context, isExprArr ) => {
    let subContentString = '';
    for( let i = 0; i < filterArr.length; i++ ) {
        let pos = filterArr[ i ].indexOf( ':' );
        let filterExpression;
        let filterName;
        if( pos > -1 ) {
            filterExpression = filterArr[ i ].substring( pos + 1 ).trim();
            filterName = filterArr[ i ].substring( 0, pos ).trim();
        } else {
            filterName = filterArr[ i ].trim();
        }
        let base = i === 0 ? `${mapExprToAwParse( setExpr, { ...context.locals } )} ${isExprArr ? '|| [] ' : ''}` : subContentString;
        subContentString =
            `filterSer('${filterName}')(${base},${filterExpression ? filterExpression.indexOf( '.' ) > 1 ? mapExprToAwParse( filterExpression, { ...context.locals } ) : filterExpression : ''} )`;
    }
    subContentString = isExprArr ? 'Object.entries(' + `${subContentString}` + ')' : subContentString;
    return subContentString;
};

const parseExprToFilter = ( expressArr, exprText, context ) => {
    let subContent = '';
    let firstExpIndex = expressArr.indexOf( '|' );
    let lastExpIndex = expressArr.lastIndexOf( '|' );
    let filterStr;
    if( expressArr[ lastExpIndex + 2 ] === ':' ) {
        filterStr = expressArr.slice( firstExpIndex - 1, lastExpIndex + 4 ).join( ' ' ).trim();
    } else {
        filterStr = expressArr.slice( firstExpIndex - 1, lastExpIndex + 2 ).join( ' ' ).trim();
    }
    if( filterStr.startsWith( '(' ) ) { filterStr = filterStr.substr( 1, filterStr.lastIndexOf( ')' ) - 1 ); }
    let expresVal = filterStr.split( '|' );
    for( let j = 1; j < expresVal.length; j++ ) {
        let pos = expresVal[ j ].indexOf( ':' );
        let filterExpression;
        let filterName;
        if( pos > -1 ) {
            filterExpression = expresVal[ j ].substring( pos + 1 ).trim();
            filterName = expresVal[ j ].substring( 0, pos ).trim();
        } else {
            filterName = expresVal[ j ].trim();
        }
        let base = j === 1 ? `${mapExprToAwParse( expresVal[0], { ...context.locals } )}` : subContent;
        subContent =
            `filterSer('${filterName}')(${base}${filterExpression ? ',' + filterExpression : '' } )`;
    }
    exprText = exprText.replace( filterStr, subContent );

    return exprText;
};

const _getViewDeps = elem => {
    const res = {};
    let elemName = elem.nodeName.toLowerCase();
    // only aa-bb counts
    // case2: AwDefaultGroupCell-Cell multiple level slot
    if( /^\S+-\S+$/.test( elemName ) || elemName === 'cell' ) {
        const viewDep = utils.getViewDep( utils.kebabCaseToPascalCase( elem.nodeName.toLowerCase() ) );
        if( viewDep ) {
            res[ elem.nodeName ] = viewDep.import;
        }
    }

    for( let i = 0; i < elem.children.length; i++ ) {
        Object.assign( res, _getViewDeps( elem.children[ i ] ) );
    }

    return res;
};

const getHOCDeclarations = parsedView => {
    let node = parsedView;
    const isHTMLNode = ( node ) => !/^\S+-\S+$/.test( node.nodeName.toLowerCase() );
    const _getHOCDeclarations = function( node ) {
        const res = {};
        if( node.hasAttribute( 'extended-tooltip' ) ) {
            node.setAttribute( 'ext-tooltip-data', '' );
        }
        // This would give all the attr level directive applicable for HOC for a node.
        let applicableHocS = globalHigherOrderAttrs.filter( ( attr ) => {
            return node.hasAttribute( attr );
        } );

        if( applicableHocS && applicableHocS.length > 0 ) {
            // This would convert the array of attrs to pascalCase;
            applicableHocS = applicableHocS.map( ( attr ) => {
                // visible-when become 'awVisibleWhen'
                return `${utils.kebabCaseToPascalCase( attr )}`;
            } );

            let isHTMLComponent = isHTMLNode( node );
            let nodeName = !isHTMLComponent ? utils.kebabCaseToPascalCase( node.nodeName.toLowerCase() ) : node.nodeName.toLowerCase();
            let hocDeclaration = null;
            let hocImports = [];
            if( isHTMLComponent || utils.getViewDep( nodeName ) ) {
                applicableHocS.map( attr => {
                    // Import awVisibleWhen from HOC.
                    // import {awVisibleWhen} from 'js/hocCollection';
                    hocImports.push( attr );
                    //VisibleWhen(AwLink) or VisibleWhen('div') or ExtendedTooltip(VisibleWhen(AwLink))
                    hocDeclaration = hocDeclaration ? `${attr}(${hocDeclaration})` : `${attr}(${isHTMLNode( node ) ? '\'' + nodeName + '\'' : nodeName})`;
                } );
                let key = `${utils.kebabCaseToPascalCase( `${nodeName}-${applicableHocS.join( '-' )}` )}`;
                //res[ key ] = `const ${nodeName}HOC = ${hocDeclaration}`;
                res[ key ] = `const ${key} = ${hocDeclaration}`;
                res.import = hocImports;
            }
        }
        for( let i = 0; i < node.children.length; i++ ) {
            _.mergeWith( res, _getHOCDeclarations( node.children[ i ] ), function( objValue, srcValue, key ) {
                if( key === 'import' && objValue && srcValue ) {
                    return _.union( objValue, srcValue );
                }
            } );
        }
        return res;
    };

    let hocObjs = _getHOCDeclarations( node );

    let hocConstDeclaration = [];
    let hocImports = hocObjs.import;
    delete hocObjs.import;

    let declarationConstKeys = Object.keys( hocObjs );
    declarationConstKeys.map( key => {
        hocConstDeclaration.push( hocObjs[ key ] + ';' );
    } );
    return { hocImports, hocConstDeclaration };
};

const getHOCDeps = parsedView => {
    let res = [];
    const { hocImports, hocConstDeclaration } = getHOCDeclarations( parsedView );
    if( hocImports && hocImports.length > 0 ) {
        res.push( `import { ${hocImports.join( ',' )} } from 'js/hocCollection';` );
    }
    if( hocConstDeclaration ) {
        res = res.concat( hocConstDeclaration );
    }
    return res;
};
const getViewDeps = parsedView => _getViewDeps( parsedView );

module.exports = {
    BaseIndent,
    Node,
    parseView,
    mapExprToAwParse,
    mapAttrToAction,
    mapAttr,
    mapChildNodes,
    getViewDeps,
    getHOCDeps,
    getHOCDeclarations,
    mapExprToAwFilter,
    parseExprToFilter,
    getCompName,
    evaluateAttr,
    globalHigherOrderAttrs
};
