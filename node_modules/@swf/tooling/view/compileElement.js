/* eslint-disable complexity */
/* eslint-disable sonarjs/cognitive-complexity */
// Copyright (c) 2020 Siemens
/* eslint-env node */

/**
 * Element Node Compiler
 */
const {
    BaseIndent,
    Node,
    mapAttr,
    mapChildNodes,
    globalHigherOrderAttrs
} = require( './utils' );

const utils = require( '../rewired/utils' );

/**
 * Evaluate condition for current compiler
 * @param {Node} node input DOM Node
 * @param {context} context input context
 * @returns {boolean} true if condition matches
 */
const when = ( node ) => {
    return node.nodeType === Node.ELEMENT_NODE;
};

/**
 * Compile view input to JSX
 * @param {Node} node input DOM Node
 * @param {context} context input context
 * @returns {Array} compile output as string array
 */
const compile = ( node, context ) => {
    let contents = [];
    let currLine = [];

    let elem = node;
    let level = context.level !== undefined ? context.level : 0;
    let index = context.index;
    let indent = BaseIndent.repeat( level );

    const processHOC = ( node, elemName ) => {
        // This filter would provide all the hoc level attributes
        let hocAttrs = globalHigherOrderAttrs.filter( ( attr ) => {
            return node.hasAttribute( attr + '-hoc' );
        } );
        if( hocAttrs && hocAttrs.length > 0 ) {
            return utils.kebabCaseToPascalCase( elemName + '-' + hocAttrs.join( '-' ) );
        }
        return elemName;
    };

    // process tag
    let elemName = elem.nodeName.toLowerCase();
    let compiledType = null;
    let viewDesc = null;
    if( level === 0 ) {
        compiledType = 'Fragment';
        let primContents = mapChildNodes( elem, {
            ...context,
            index: false
        } );
        if( elem.childElementCount === 1 ) {
            contents = contents.concat( primContents );
        } else {
            contents.push( `${indent}<${compiledType}>` );
            contents = contents.concat( primContents );
            contents.push( `${indent}</${compiledType}>` );
        }
    } else {
        if( /^\S+-\S+$/.test( elemName ) || elemName === 'cell' ) {
            let compName = utils.kebabCaseToPascalCase( elemName );
            if( utils.getViewDep( compName ) ) {
                compiledType = processHOC( node, compName );
                viewDesc = utils.getViewDep( compName ).props;
            }
        } else {
            elemName = processHOC( node, elemName );
        }

        elemName = compiledType ? compiledType : elemName;
        currLine.push( `${indent}<${elemName}` );

        // process attribute
        const attrLenth = elem.attributes.length || 0;
        const classLength = elem.classList.length || 0;
        let isRepeatParent = context.isRepeatParent;
        if( elem.hasAttribute( 'ignoreIsRepeatParent' ) ) {
            isRepeatParent = false;
        }

        if( attrLenth + classLength > 0 || index === true ) {
            for( let i = 0; i < attrLenth; i++ ) {
                currLine = currLine.concat( mapAttr( node, elem.attributes[ i ], {
                    props: viewDesc,
                    childExp: context.childExp,
                    isRepeatParent: isRepeatParent,
                    parentExp: context.parentExp,
                    locals: { ...context.locals }
                }, true ) );
            }

            // append react index
            if( index === true ) {
                currLine = currLine.concat( 'key={$index}' );
            }
        }
        contents.push( currLine.join( ' ' ) + '>' );
        // process children
        contents = contents.concat( mapChildNodes( elem, {
            ...context,
            index: false
        } ) );
        // end tag
        contents.push( `${indent}</${elemName}>` );
    }
    return contents;
};

module.exports = {
    when,
    compile
};
