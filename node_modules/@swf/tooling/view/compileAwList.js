// Copyright (c) 2020 Siemens
/* eslint-env node */

/**
 * aw-list / aw-list-filter element Node Compiler
 */
const {
    mapAttr,
    BaseIndent,
    parseExprToFilter,
    mapExprToAwParse,
    Node,
    evaluateAttr,
    getCompName
} = require( './utils' );

const utils = require( '../rewired/utils' );

const attrToIgnore = [ 'dataprovider', 'show-check-box', 'show-context-menu', 'item-options', 'fixed-cell-height', 'is-group-list', 'use-virtual', 'show-drop-area', 'has-floating-cell-commands', 'class',
    'show-decorators'
];

/**
 * Evaluate condition for current compiler
 * @param {Node} node input DOM Node
 * @param {context} context input context
 * @returns {boolean} true if condition matches
 */
const when = ( node ) => {
    return node.nodeType === Node.ELEMENT_NODE &&
        node.nodeName === 'AW-LIST' || node.nodeName === 'AW-LIST-FILTER';
};

const mapListChildNodes = ( elem, context ) => {
    //contents = contents.concat( '<li>{( { item } ) => item.title}</li>')
    const contents = [];
    const level = context.level || 0;
    const childLength = elem.childNodes.length;
    if( childLength > 0 ) {
        for( let i = 0; i < childLength; i++ ) {
            let childDomNode = elem.childNodes[ i ];
            let indent = BaseIndent.repeat( level + 1 );

            // case: {{item.Title}}
            if( childDomNode.nodeName === '#text' && childDomNode.textContent.trim().startsWith( '{{' ) ) {
                //This is native element generate inline function for its contents
                let expression = childDomNode.textContent.trim().replace( /[{{}}]/g, '' );
                expression = expression.replace( /(\r\n|\n|\r)/gm, '' );
                const argument = expression.split( '.' ).filter( ( e, idx ) => idx === 0 || idx % 2 === 0 ).join();
                let inlineFunction = `${indent}<li>{${mapExprToAwParse( expression, { ...context.locals } )}}</li>`;
                contents.push( inlineFunction );
            } else {
                let internalNode = childDomNode.textContent.trim();
                let match = internalNode.startsWith( '{{' ) && internalNode.endsWith( '}}' );
                if( match && childDomNode.nodeName === '#text' ) {
                    // case: <li>{{item.Title}}</li> or <div> {{item.Title}} </div>
                    let expression = internalNode.replace( /[{{}}]/g, '' );
                    // <div class="aw-widgets-cellTop">{{ item.date | date : item.dateTimeFormat }}</div>
                    // const argument = expression.split( '.' ).filter( ( e, idx ) => idx === 0 || idx % 2 === 0 ).join();
                    let expressArr = expression.split( ' ' );
                    let nodeName = childDomNode.nodeName.toLowerCase();
                    let inlineFunction = '';
                    if( expressArr.includes( '|' ) ) {
                        expression = parseExprToFilter( expressArr, expression, context );
                        inlineFunction = `${indent}<${nodeName}>{${expression}}</${nodeName}>`;
                    } else {
                        inlineFunction = `${indent}<${nodeName}>{${mapExprToAwParse( expression, { ...context.locals } )}}</${nodeName}>`;
                    }
                    contents.push( inlineFunction );
                } else {
                    let childContents = context.compileFn( childDomNode, {
                        ...context,
                        level: level + 1,
                        isListParent: true,
                        isExprContext: false
                    } );

                    if( childContents && childContents.length > 0 ) {
                        contents.push( childContents.join( '\n' ) );
                    }
                }
            }
        }
    }
    return contents;
};

const validateListCheckBoxChild = ( elem ) => {
    const childLength = elem.childNodes.length;
    if( childLength > 1 ) {
        let childDomNode = elem.childNodes[ 1 ];
        //<aw-list-checkbox-item prop="item" action="filterFacetInputChanged"></aw-list-checkbox-item>
        return childDomNode && childDomNode.nodeName === 'AW-LIST-CHECKBOX-ITEM';
    }
    return false;
};

/**
 * Compile view input to target JSX
 * @param {Node} node input DOM Node
 * @param {context} context input context
 * @returns {Array} compile output as string array
 */
const compile = ( node, context ) => {
    // process indent
    let level = context.level;
    let indent = BaseIndent.repeat( level );

    let elem = node;
    let compName = utils.kebabCaseToPascalCase( elem.nodeName.toLowerCase() );

    // old way
    // <aw-list dataprovider="data.dataProviders.performSearch" show-check-box=true>
    //     </XXX>
    // </aw-list>

    // new way
    // <AwList dataprovider= {dataProviders.xxx} showCheckbox={data.showCheckbox.dbValue}>
    //      </XXX>
    // </AwList>

    let viewDesc = null;

    if( utils.getViewDep( compName ) ) {
        viewDesc = utils.getViewDep( compName ).props;
    }

    let eleName = getCompName( elem );

    let contents = [];
    let currLine = [];

    currLine.push( `${indent}<${eleName}` );

    let dataProviderName = node.getAttribute( 'dataprovider' ).split( 'dataProviders.' )[ 1 ];
    let showCheckbox = node.getAttribute( 'show-check-box' );

    if( dataProviderName ) {
        currLine.push( `dataprovider={dataProviders.${dataProviderName}}` );
    }
    if( showCheckbox ) {
        currLine.push( `showCheckbox={${showCheckbox}}` );
    }

    let showContextMenu = node.getAttribute( 'show-context-menu' );
    if( showContextMenu ) {
        currLine.push( `showContextMenu={${showContextMenu}}` );
    }

    let itemOptions = node.getAttribute( 'item-options' );
    if( itemOptions ) {
        currLine.push( `itemOptions={${itemOptions}}` );
    }

    let fixedCellHeight = node.getAttribute( 'fixed-cell-height' );
    if( fixedCellHeight ) {
        currLine.push( `fixedCellHeight={${fixedCellHeight}}` );
    }

    let isGroupList = node.getAttribute( 'is-group-list' );
    if( isGroupList ) {
        currLine.push( `isGroupList={${isGroupList}}` );
    }

    let useVirtual = node.getAttribute( 'use-virtual' );
    if( useVirtual ) {
        currLine.push( `useVirtual={${useVirtual}}` );
    }

    let showDropArea = node.getAttribute( 'show-drop-area' );
    currLine.push( `showDropArea={${showDropArea}}` );

    let showDecorators = node.getAttribute( 'show-decorators' );
    if( showDecorators ) {
        currLine.push( `showDecorators={${showDecorators}}` );
    }

    let hasFloatingCellCommands = node.getAttribute( 'has-floating-cell-commands' );
    if( hasFloatingCellCommands ) {
        currLine.push( `hasFloatingCellCommands={${hasFloatingCellCommands}}` );
    }

    let className = node.hasAttribute( 'class' ) ? node.getAttribute( 'class' ) : null;

    if( className ) {
        let val = `className="${className}"`;
        currLine.push( val );
    }

    currLine.push( 'dndHandler={props.viewModel.dndHandler}' );

    currLine = evaluateAttr( elem, currLine, context, viewDesc, attrToIgnore );

    let tagLine = currLine.join( ' ' ) + '>';

    if( validateListCheckBoxChild( elem ) ) {
        contents.push( tagLine );
        contents = contents.concat( mapListChildNodes( elem, context ) );
    } else {
        let children = mapListChildNodes( elem, { ...context, locals: { ...context.locals, item: true, index: true } } );
        // the additional layer <></> complete broken group list, only do it on condition
        let childComponents = children.length > 1 ? children.join( '\n' ) : children;

        if( isGroupList ) {
            tagLine += `{({item, index})=>{ return ${childComponents} } }`;
        } else {
            tagLine += `{({item, index})=>{ return <>${childComponents}</> } }`;
        }

        contents.push( tagLine );
    }

    // end tag
    contents.push( `${indent}</${eleName}>` );

    return contents;
};

module.exports = {
    when,
    compile
};
