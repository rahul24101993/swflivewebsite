// Copyright (c) 2020 Siemens
/* eslint-env node */

/**
 * aw-list element Node Compiler
 */
const {
    mapExprToAwParse,
    mapChildNodes,
    BaseIndent,
    getCompName,
    evaluateAttr,
    Node
} = require( './utils' );

const utils = require( '../rewired/utils' );

const attrToIgnore = [ 'hide-title', 'commands', 'anchor', 'context', 'update-active-view', 'class' ];

/**
 * Evaluate condition for current compiler
 * @param {Node} node input DOM Node
 * @param {context} context input context
 * @returns {boolean} true if condition matches
 */
const when = ( node ) => {
    return node.nodeType === Node.ELEMENT_NODE &&
        node.nodeName === 'AW-COMMAND-PANEL';
};

/**
 * Compile view input to target JSX
 * @param {Node} node input DOM Node
 * @param {context} context input context
 * @returns {Array} compile output as string array
 */
const compile = ( node, context ) => {
    // process indent
    let level = context.level;
    let indent = BaseIndent.repeat( level );
    let elem = node;

    let compName = utils.kebabCaseToPascalCase( elem.nodeName.toLowerCase() );

    let viewDesc = null;

    if( utils.getViewDep( compName ) ) {
        viewDesc = utils.getViewDep( compName ).props;
    }

    let eleName = getCompName( elem );

    let contents = [];
    let currLine = [];

    currLine.push( `${indent}<${eleName}` );

    let hideTitle = elem.hasAttribute( 'hide-title' ) ? elem.getAttribute( 'hide-title' ) : null;
    let commands = elem.hasAttribute( 'commands' ) ? elem.getAttribute( 'commands' ) : null;
    let anchor = elem.hasAttribute( 'anchor' ) ? elem.getAttribute( 'anchor' ) : null;
    let contextAttr = elem.hasAttribute( 'context' ) ? elem.getAttribute( 'context' ) : null;
    let updateHook = elem.hasAttribute( 'update-active-view' ) ? elem.getAttribute( 'update-active-view' ) : null;
    let className = elem.hasAttribute( 'class' ) ? elem.getAttribute( 'class' ) : null;

    currLine.push( 'revealAction={actions.reveal}' );
    if( hideTitle ) {
        currLine.push( `hideTitle={${hideTitle}}` );
    }
    if( commands ) {
        currLine.push( `commands={${commands}}` );
    }
    if( anchor ) {
        let match = anchor.match( /^(.*)$/ );
        if( match ) {
            const expr = match[ 1 ].trim().replace( /^::/, '' );
            anchor = `${mapExprToAwParse( expr, { ...context.locals } )}`;
        }
    }
    if( className ) {
        currLine.push( `className="${className}"` );
    }
    if( anchor ) {
        currLine.push( `anchor={${anchor}}` );
    }
    if( contextAttr ) {
        currLine.push( `context={${contextAttr}}` );
    }
    let hookValue = updateHook || '{activeView: data.activeView, dispatch: dispatch }';
    let parsedHookVal = mapExprToAwParse( hookValue, context.locals );
    currLine.push( `updateActiveView={${parsedHookVal}}` );

    currLine = evaluateAttr( elem, currLine, context, viewDesc, attrToIgnore );

    contents.push( currLine.join( ' ' ) + '>' );
    // process children
    contents = contents.concat( mapChildNodes( elem, context ) );
    // end tag
    contents.push( `${indent}</${eleName}>` );

    return contents;
};

module.exports = {
    when,
    compile
};
