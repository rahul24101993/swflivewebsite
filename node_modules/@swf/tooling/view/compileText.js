// Copyright (c) 2020 Siemens
/* eslint-env node */

/**
 * Text Node Compiler
 */
const {
    mapExprToAwParse,
    mapExprToAwFilter,
    parseExprToFilter,
    BaseIndent,
    Node
} = require( './utils' );

const _ = require( 'lodash' );

/**
 * Evaluate condition for current compiler
 * @param {Node} node input DOM Node
 * @param {context} context input context
 * @returns {boolean} true if condition matches
 */
function when( node ) {
    return node.nodeType === Node.TEXT_NODE;
}

/**
 * Compile view input to target framework format
 * NOTE: this will reformat the text for now. Need a better solution later
 * worst case we need to use { "str" } way.
 * @param {Node} node input DOM Node
 * @param {context} context input context
 * @returns {Array} compile output as string array
 */
function compile( node, context ) {
    // process indent
    let indent = BaseIndent.repeat( context.level );
    let res = [];

    // indent in text node will add noise
    const value = node.textContent.trim();

    if( value.startsWith( 'i18n.' ) ) {
        // special logic for i18n. In this case we only support full text is i18n.xxx
        res.push( indent );
        res.push( `{${value}}` );
        return [ res.join( '' ) ];
    }
    let matches = value.split( /({{.*?}})/g );

    // trim start and end space for indention
    matches = matches.filter( ( o, i ) => ( i === 0 || i === matches.length - 1 ) && o.trim() || i > 0 && i < matches.length );

    if( matches && matches.length > 0 ) {
        res.push( indent );
        for( let i = 0; i < matches.length; i++ ) {
            let str = matches[ i ];

            let match = str.match( /^{{(.*)}}$/ );
            if( match ) {
                let exprText = match[ 1 ].trim().replace( /^::/, '' );
                if( exprText ) {
                    if( context.isListParent && !context.isDefaultGroupCell ) {
                        // ( !item.props.rule_date.dbValue == "" ) ? (item.props.rule_date.dbValue | date) : ""
                        let expressArr = exprText.split( ' ' );
                        let inlineFunction = '';
                        if( expressArr.includes( '|' ) ) {
                            exprText = parseExprToFilter( expressArr, exprText, context );
                            inlineFunction = `${indent}{${exprText}}`;
                        } else {
                            inlineFunction = `${indent}{${mapExprToAwParse( exprText, { ...context.locals } )}}`;
                        }
                        res.push( inlineFunction );
                    } else {
                        let exprFilter = exprText.split( '|' );
                        if( exprFilter.length > 1 ) {
                            // <div class="aw-widgets-cellTop">{{ item.date | date : item.dateTimeFormat }}</div>
                            // filter('date')(awparse,express)
                            res.push( `{${mapExprToAwFilter( exprFilter.splice( 1 ), exprFilter[0], context, false )}}` );
                        } else {
                            res.push( `{${mapExprToAwParse( exprText, { ...context.locals } )}}` );
                        }
                    }
                    // {{data.currentEffectiveDate.dbValue ? ( data.currentEffectiveDate.dbValue | date ): data.currentEffectiveDate.propertyDisplayName}}
                    // expression like above can not eveuldate by filter directly and need support of filter in mapExprToAwParse....
                }
            } else {
                res.push( `${_.escape( str )}` );
            }
            // }
        }
        return [ res.join( '' ) ];
    }
    // return null for this case so that we don't outcome extra \n
    return null;
}

module.exports = {
    when,
    compile
};
