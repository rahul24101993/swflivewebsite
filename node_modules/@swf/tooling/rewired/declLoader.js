// Copyright (c) 2022 Siemens
/* eslint-disable complexity */

const _ = require( 'lodash' );
const path = require( 'path' );
const fs = require( 'fs' );
const compile = require( '../view/compiler' );
const { parseView } = require( '../view/utils' );
const { resolveAlias } = require( './utils' );
const { replaceAll } = require( '../js/util' );
const { getViewDeps, getHOCDeps } = require( '../view/utils' );
const { Stopwatch } = require( './perfUtils' );
const logger = require( '../js/logger' );

/**
 * main function of decl loader
 * @param {string} source input file content
 * @param {string} filePath input filePath ( only required for unit tests )
 * @returns {String} output
 */
module.exports = function loader( source, filePath ) {
    const stopwatch = new Stopwatch( 'declLoader' );
    source = typeof source !== 'string' ? JSON.stringify( source ) : source;
    const resourcePath = filePath ? filePath : this.resource.replace( /\\/g, '/' );
    const widgetName = getExportFunctionName( resourcePath );
    let jsonData = typeof source === 'string' ? JSON.parse( source.trim() ) : source;
    // compile view model
    jsonData._viewModelId = widgetName;
    jsonData._uniqueViewModelId = widgetName;
    let { method: renderFnName, deps: renderFnDep, options: renderFnOpts } = getRenderFunction( jsonData );
    renderFnOpts && ( renderFnOpts = JSON.stringify( renderFnOpts ) );
    // get all automic data
    const atomicData = [];
    // Get all deps used in viewmodel json
    const vmDeps = {};
    // then excluding render method populate actionDeps
    for( const action in jsonData.actions ) {
        if( action !== renderFnName ) {
            const actionDetails = jsonData.actions[ action ];
            if( actionDetails && actionDetails.deps ) {
                vmDeps[ actionDetails.deps ] = true;
            }
            // load popup view
            if( actionDetails.actionType === 'popup' && actionDetails.inputData && actionDetails.inputData.options && actionDetails.inputData.options.view ) {
                vmDeps[ `viewmodel/${actionDetails.inputData.options.view}ViewModel` ] = true;
            }
        }
    }
    //function deps
    for( const fn in jsonData.functions ) {
        const fnDetails = jsonData.functions[ fn ];
        if( fnDetails && fnDetails.deps ) {
            vmDeps[ fnDetails.deps ] = true;
        }
    }
    //grids deps
    for( const grid in jsonData.grids ) {
        const gridDetails = jsonData.grids[ grid ];
        if( gridDetails && gridDetails.deps ) {
            vmDeps[ gridDetails.deps ] = true;
        }
    }
    //dataproviders
    for( const dataProvider in jsonData.dataProviders ) {
        const dpDetails = jsonData.dataProviders[ dataProvider ];
        if( dpDetails.commands ) {
            for( const command in dpDetails.commands ) {
                const cmdDetails = dpDetails.commands[ command ];
                if( cmdDetails.dependencies && cmdDetails.dependencies.length > 0 ) {
                    cmdDetails.dependencies.forEach( dep => vmDeps[ dep ] = true );
                }
            }
        }
    }

    //chartProviders backward compitibility
    for( const chartProvider in jsonData.chartProviders ) {
        if( jsonData.chartProviders[ chartProvider ].loadDataAction ) {
            let actionObj = jsonData.actions[ jsonData.chartProviders[ chartProvider ].loadDataAction ];
            let newActionObj = _.mapKeys( actionObj.outputData, function( value, key ) {
                if( key.match( /chartProviders\.\w+\.chartPoints+/g ) ) {
                    return `${chartProvider}_chartPoints`;
                }
                return key;
            } );
            jsonData.actions[ jsonData.chartProviders[ chartProvider ].loadDataAction ].outputData = newActionObj;
        }
    }

    //command deps
    for( const command in jsonData.commands ) {
        const cmdDetails = jsonData.commands[ command ];
        if( cmdDetails.deps ) {
            vmDeps[ renderFnDep ] = true;
        }
    }

    // Automic Data
    for( const data in jsonData.data ) {
        const dataDetails = jsonData.data[ data ];
        if( dataDetails && dataDetails.meta ) {
            atomicData.push( data );
        }
    }

    // compile view
    const viewPath = getViewPath( resourcePath );
    let viewContent = '';
    let jsxContent = '';
    let viewDeps = [];
    let hocDeps = [];
    let parsedView;
    if( fs.existsSync( viewPath ) ) {
        if( this && this.addDependency ) {
            this.addDependency( viewPath );
        }
        viewContent = fs.readFileSync( viewPath, 'utf-8' );
        parsedView = parseView( viewContent );
        hocDeps = getHOCDeps( parsedView );
        jsxContent = compile( parsedView );
        viewDeps = getViewDeps( parsedView );
    }

    if( atomicData.length ) {
        for( const val in atomicData ) {
            let searchText = 'data.' + atomicData[ val ];
            let index = jsxContent.indexOf( searchText );
            if( index ) {
                let replaceText = 'fields.' + atomicData[ val ];
                jsxContent = replaceAll( jsxContent, searchText, replaceText );
            }
        }
    }

    // ctx processing
    // - if viewModel.ctx is defined in JSON, that will be used for useSelector
    // - if not, code below will try to scan through JSON/HTML/RenderFn JS to get all
    //   matched `ctx.xxx` and auto-generated viewModel.ctx
    if( !jsonData.ctx ) {
        let res = [];
        let valid = true;

        // scan JSON
        const vmCtxExprs = res.concat( source.match( /ctx\.\w+/g ) || [] );
        if( source.match( /ctx[ "'[,;}]/g ) ) {
            logger.silly( `ctx might not be interpolated correctly in ${resourcePath}, try to use pattern 'ctx.path', or write viewModel.ctx manually in your JSON.` );
            valid = false;
        } else {
            res = res.concat( vmCtxExprs );
        }

        // scan HTML
        const viewCtxExprs = res.concat( viewContent.match( /ctx\.\w+/g ) || [] );
        if( viewContent.match( /ctx[ "'[,;}]/g ) ) {
            logger.silly( `ctx might not be interpolated correctly in ${viewPath}, try to use pattern 'ctx.path', or write viewModel.ctx manually in your JSON.` );
            valid = false;
        } else {
            res = res.concat( viewCtxExprs );
        }

        // scan RenderFn
        if( jsonData.lifecycleHooks && jsonData.lifecycleHooks.render &&
            jsonData.actions && jsonData.actions[ jsonData.lifecycleHooks.render ] &&
            jsonData.actions[ jsonData.lifecycleHooks.render ].deps ) {
            const renderFnPath = resolveAlias( jsonData.actions[ jsonData.lifecycleHooks.render ].deps );
            const renderFnContent = fs.readFileSync( `${renderFnPath}.js`, 'utf-8' );
            const renderFnCtxExprs = res.concat( renderFnContent.match( /ctx\.\w+/g ) || [] );

            // 20200112 - skip the signature case `MyRenderFn = ( { ctx, viewModel } ) => { ... }
            if( renderFnContent.replace( '( { ctx,' ).match( /ctx[ "'[,;}]/g ) ) {
                logger.silly( `ctx might not be interpolated correctly in ${renderFnPath}.js, try to use pattern 'ctx.path', or write viewModel.ctx manually in your JSON.` );
                valid = false;
            } else {
                res = res.concat( renderFnCtxExprs );
            }
        }

        if( valid ) {
            // unique
            res = [ ...new Set( res ) ].map( v => v.replace( /^ctx\./, '' ) );

            // logger.silly( `${widgetName}: ${JSON.stringify( res )}` );

            jsonData.ctx = res.reduce( ( sum, v ) => ( {
                ...sum,
                [ v ]: {
                    type: 'object'
                }
            } ), {} );
        }
    }

    const jsonSource = JSON.stringify( jsonData, undefined, 4 );

    const ctxRefs = jsonData.ctx || {};
    const ctxImports = Object.entries( ctxRefs )
        .filter( ( [ , v ] ) => v && v.parser );
    const ctxImportString = ctxImports.map( ( [ k, { parser } ] ) => `import { ${parser.method} as ${k} } from '${parser.deps}';` ).join( '\n' );
    const ctxImportObj = `const ctxImportObj = { ${ctxImports.map( ( [ k ] ) => k ).join( ',' )} };`;

    let compiledComp = `// Compiler result to JSON file
import { createComponent } from 'js/declViewModelService';
import { registerDynImportEntry } from 'js/moduleLoader';
import AwParseService from 'js/awParseService';
import AwFilterService from 'js/awFilterService';
import { getField } from 'js/utils';
import { Fragment } from 'react';
let filterSer = AwFilterService.instance;
${_.size( viewDeps ) ? Object.values( viewDeps ).join( '\n' ) : ''}
${hocDeps.length > 0 ? hocDeps.join( '\n' ) : ''}

${ renderFnName ? `/*
render function
*/
import { ${renderFnName} } from '${renderFnDep}';
` : '' }

${ `/*
ctx imports
*/
${ctxImportString}
${ctxImportObj}
` }

${ _.size( vmDeps ) ?
        `/*
dynamic import
 */
${Object.keys( vmDeps ).map( dep => `registerDynImportEntry('${dep}', () => import('${dep}'));` ).join( '\n' )};` : ''}

/*
view model
 */
const declViewModelJson = ${jsonSource.trim()};

${ viewContent ? `/*
${viewContent}
*/
const renderFn =(props)=> {
    let subPanelContext = props.subPanelContext ;
    let { viewModel: { data, dataProviders, dispatch, conditions, selectionModels, editHandlers, chartProviders, ports  }, grids, ctx, actions, fields, messages, i18n, formProp, viewPath  } = props;
    data = {...data, dataProviders};
    if( subPanelContext && subPanelContext.fields ){
        fields = { ...fields, ...subPanelContext.fields };
    }
    let $index = null;
    return (
        ${jsxContent}
    )
};` : ''}


/*
define component
*/
const Component = createComponent( declViewModelJson, ${renderFnName ? renderFnName : 'renderFn'}, ${renderFnOpts}, ctxImportObj );

export default Component;
`;
    const output = compiledComp.trim();
    stopwatch.end();
    return output;
};

const getRenderFunction = jsonData => {
    if( jsonData.lifecycleHooks && jsonData.lifecycleHooks.render && jsonData.actions ) {
        if( jsonData.actions[ jsonData.lifecycleHooks.render ] ) {
            return jsonData.actions[ jsonData.lifecycleHooks.render ];
        }
    }

    // map with usage
    return {};
};

const getExportFunctionName = ( path ) => {
    const consistentPath = path.replace( /\\/g, '/' );
    const splits = consistentPath.split( /\//g );
    const baseName = splits[ splits.length - 1 ];
    return baseName.replace( 'ViewModel.json', '' ).trim();
};

const getViewPath = vmPath => {
    const match = vmPath.match( /(^.*)(\/|\\)viewmodel(\/|\\)(\S+)ViewModel\.json$/ );
    const basePath = match[ 1 ];
    const declName = match[ 4 ];
    return path.resolve( basePath, `./html/${declName}View.html` );
};
