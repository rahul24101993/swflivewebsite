// Copyright (c) 2022 Siemens

const { getEffectiveKitPaths, getKitCache, normalizePath, getSelectedSite, getResolvedSourcePaths, getModuleCache, getOOTBList } = require( './utils' );
const _ = require( 'lodash' );
const afxPkgJson = require( '../package.json' );
const { Stopwatch } = require( './perfUtils' );

/**
 * main function of decl loader
 * @param {string} source input file content
 * @param {boolean} AFX_UTEST env variable for unit testing
 * @returns {string} modified source as return value
 */
module.exports = function loader( source, AFX_UTEST ) {
    const stopwatch = new Stopwatch( 'configSvcLoader' );

    // Generate module regex
    const sourcePaths = getResolvedSourcePaths();

    const kitPaths = getEffectiveKitPaths();
    // get all JSONs which needs to be stitch
    // revisitme - if we want to do better later, we can add those kit.json to the watch dependency of this loader
    const kitCache = getKitCache();

    const moduleCache = getModuleCache();

    // somehow get root kit JSON path here
    const siteDef = getSelectedSite();

    const kitJson = kitCache[ siteDef.content.solutionName ];

    if( !kitJson || !kitJson.content ) {
        throw new Error( `Unable to locate solution kit named ${siteDef.content.solutionName}!` );
    }
    if( !kitJson.content.solutionDef || !kitJson.content.solutionDef.workspaces ) {
        throw new Error( `Kit ${siteDef.content.solutionName} does not have a solutionDef or solutionDef.allWorkspaces defined!` );
    }

    const configs = Object.values( kitCache ).reduce( ( sum, v ) => ( {
        ...sum,
        ...v.content.configuration
    } ), {} );

    const res = [];
    res.push( 'AFX_CONFIG_ENTRY' );
    if( AFX_UTEST ) {
        res.push( '        const { Stopwatch } = require( \'@swf/tooling/rewired/perfUtils\' );' );
        // Only needed for unit test framework since jest doesn't recognize 'require.context'
        // https://stackoverflow.com/questions/38332094/how-can-i-mock-webpacks-require-context-in-jest
        if( !require.context ) {
            require.context = ( base = '.', scanSubDirectories = false, regularExpression = /\.js$/ ) => {
                const stopwatch = new Stopwatch( 'UTEST configSvc: require.context' );
                const { readdirSync, statSync } = require( 'fs' );
                const { resolve } = require( 'path' );
                const files = {};
                const readDirectory = ( directory ) => {
                    readdirSync( directory ).forEach( ( file ) => {
                        const fullPath = resolve( directory, file );
                        if( statSync( fullPath ).isDirectory() ) {
                            if( scanSubDirectories ) {
                                readDirectory( fullPath );
                            }
                            return;
                        }
                        if( !regularExpression.test( fullPath ) ) {
                            return;
                        }

                        files[ fullPath ] = true;
                    } );
                };
                readDirectory( resolve( __dirname, base ) );

                const Module = ( file ) => {
                    return Promise.resolve( require( file ) );
                };
                Module.keys = () => Object.keys( files );
                stopwatch.end();
                return Module;
            };
            res.push( `        if( !require.context ) require.context = ${require.context.toString()}` );
            const importTestConfig = ( filePath ) => {
                const stopwatch = new Stopwatch( 'UTEST configSvc: config' );
                const { existsSync } = require( 'fs' );

                const files = {};
                if( existsSync( filePath ) ) {
                    files[ filePath ] = true;
                }
                const Module = ( file ) => {
                    return require( file ) ;
                };
                Module.keys = () => Object.keys( files );
                stopwatch.end();
                return Module;
            };
            res.push( '        const importTestConfig = ' + importTestConfig );

            const importI18nConfig = ( folderPath ) => {
                const stopwatch = new Stopwatch( 'UTEST configSvc: i18n' );
                const { readdirSync } = require( 'fs' );
                const { resolve } = require( 'path' );
                const files = {};
                const readDirectory = ( directory ) => {
                    readdirSync( directory ).forEach( ( file ) => {
                        const fullPath = resolve( directory, file );
                        files[ fullPath ] = true;
                    } );
                };
                readDirectory( folderPath );
                const Module = ( file ) => {
                    return Promise.resolve( require( file ) );
                };
                Module.keys = () => Object.keys( files );
                stopwatch.end();
                return Module;
            };
            res.push( '        const importI18nConfig = ' + importI18nConfig );
        }
    }
    res.push( '        let res = null;' );
    res.push( '        switch ( basePath ) {' );

    Object.entries( configs ).forEach( ( [ k, v ] ) => {
        /*
            const check = forceJavaScript ? null : {
                moduleName: moduleJson.name,
                file: key,
                path: [],
                uniqueDepth: config.uniqueDepth
            };
        */
        // general support for type kit -> see "1581: if( solutionName ) {" in site.js
        if( v.definition === 'kit' ) {
            if( k === 'workspace' ) {
                // revisitme - see site.js, special logic TBD
                const requiredPaths = _.map( kitPaths, ( kitPath ) => `require.context('${normalizePath( kitPath )}',true,/[\\\\/]${k}_.*\\.json$/)` );
                res.push( `            case '${k}':
                const solutionDef = ${JSON.stringify( kitJson.content.solutionDef )};
                const allKitsJson = ${JSON.stringify( kitCache )};
                const modulesJson = ${JSON.stringify( moduleCache )};
                var workspacesInfo = stitchJSON( '${k}', [
                    ${requiredPaths.join( ',\n' )}
                ], ${JSON.stringify( v )} );
                processExclusiveKits(workspacesInfo, allKitsJson, modulesJson);
                exports.add( '${k}', processWorkspaces(solutionDef, workspacesInfo));
                res = exports.getCfgCached( path );
                break;` );
            } else {
                // util.merge( output[ outputType ][ key ], kitJson[ key ] );
                res.push( `            case '${k}':
                 exports.add( '${k}', processJsonImports( '${k}', [ {
                    name: '${kitJson.path}',
                    contents: require('${normalizePath( kitJson.path )}')['${k}']
                 }] ) );
                 res = exports.getCfgCached( path );
                 break;` );
            }
        } else {
            if( k === 'typeFiles' ) {
                res.push( `            case '${k}':
                require('js/typeIconRegistry');
                res = exports.getCfg('typeFiles', false, true );
                break;` );
            } else if( k === 'commandsViewModel' ||
                k === 'secondaryWorkareaTabs' ||
                k === 'layoutSlots' ||
                k === 'navigationURLToken' ||
                k === 'syncStrategy' ||
                k === 'indicators' ||
                k === 'adapters' ||
                k === 'headerContributions' ||
                k === 'saveHandlers' ) {
                const requiredPaths = _.map( sourcePaths, ( modules, srcPath ) => `require.context('${normalizePath( srcPath )}',true,/(${modules.join( '|' )})[\\\\/]${k}\\.json$/,'lazy')` );
                res.push( `            case '${k}':
                if( !_ongoing[ basePath ] ) {
                    _ongoing[ basePath ] = stitchJSON( '${k}', [
                        ${requiredPaths.join( ',\n' )}
                    ], ${JSON.stringify( { ...v, uniqueDepth: false } )},true ).then((resp)=>{
                        exports.add( '${k}',resp  );
                        return exports.getCfgCached( path );
                    });
                }
                return _ongoing[ basePath ];
                break;` );
            } else {
                let requiredPaths;
                if( AFX_UTEST ) {
                    if( process.env.TESTED_KIT ) {
                        requiredPaths = [ `importTestConfig('${normalizePath( process.cwd() )}/out/test/${process.env.TESTED_KIT}/config/${k}.json')` ];
                    } else {
                        requiredPaths = [ `importTestConfig('${normalizePath( process.cwd() )}/out/test/config/${k}.json')` ];
                    }
                } else {
                    requiredPaths = _.map( sourcePaths, ( modules, srcPath ) => `require.context('${normalizePath( srcPath )}',true,/(${modules.join( '|' )})[\\\\/]${k}\\.json$/)` );
                }
                res.push( `            case '${k}':
                exports.add( '${k}', stitchJSON( '${k}', [
                    ${requiredPaths.join( ',\n' )}
                ], ${JSON.stringify( { ...v, uniqueDepth: false } )} ) );
                res = exports.getCfgCached( path );
                break;` );
            }
        }
    } );
    res.push( `            case 'OOTB_Verification':
        exports.add( 'OOTB_Verification', ${JSON.stringify( getOOTBList() )}  );
        res = exports.getCfgCached( path );
        break;` );
    res.push( '            default:' );
    res.push( '                // do nothing' );
    res.push( '        }' );

    // version constants
    res.push( `        if( basePath === 'versionConstants') {
            exports.add( basePath, ${JSON.stringify( getVersionConstants() )} );
            res = exports.getCfgCached( path );
        }` );

    // defaultPasteHandlerConfiguration
    // defaultDragAndDropHandlers
    // imageRepositoryConfiguration
    res.push( `        if( basePath === 'defaultPasteHandlerConfiguration' || basePath === 'defaultDragAndDropHandlers' || basePath === 'imageRepositoryConfiguration' ) {
        const solutionDef = exports.getCfgCached( 'solutionDef' );
        exports.add( basePath, solutionDef[basePath] );
        res = exports.getCfgCached( path );
    }` );

    // i18n
    // as a by-product of i18n, installedLocales is special too.
    // - installedLocales for now is only used by localeService in JS way
    // - it assumes installedLocales will be sync loaded, which is impossible
    //   in the new pattern
    let requiredPaths;
    if( AFX_UTEST ) {
        if( process.env.TESTED_KIT ) {
            requiredPaths = [ `importI18nConfig('${normalizePath( process.cwd() )}/out/test/${process.env.TESTED_KIT}/i18n')` ];
        } else {
            requiredPaths = [ `importI18nConfig('${normalizePath( process.cwd() )}/out/test/i18n')` ];
        }
    } else {
        requiredPaths = _.map( sourcePaths, ( modules, srcPath ) =>
            `require.context('${normalizePath( srcPath )}',true,/(${modules.join( '|' )})[\\\\/]src[\\\\/](assets[\\\\/])?i18n[\\\\/][^\\\\/]*\\.json$/,'lazy')` );
    }

    res.push( `        if( basePath.startsWith('LoginLocale')) {
        if( !_ongoing[ basePath ] ) {
            _ongoing[ basePath ] = processLoginLocales( basePath,[
                ${requiredPaths.join( ',' )}
            ] );
        }
        return _ongoing[ basePath ].then((LoginLocale)=>{
            exports.add( basePath, LoginLocale );
            return exports.getCfgCached( path );
        });
    }` );

    res.push( `
    if( basePath.startsWith( 'i18n' ) )
    {
        let localeCode = localStrgSvc.get( 'locale' );
        var langVal;
        if( localeCode ) {
            langVal = 'i18n' + '_' + localeCode;
            if( localeCode == 'en_US' && !basePath.includes( 'en_US' ) ) {
                langVal = 'i18n';
            }
        }
        if( basePath === langVal ) {
            if( !_ongoing[ basePath ] ) {
                _ongoing[ basePath ] = processI10n( basePath,[
                    ${requiredPaths.join( ',' )}
                ] );
            }
            return _ongoing[ basePath ].then((i18n)=>{
                exports.add( basePath, i18n );
                return exports.getCfgCached( path );
            });
        }
    }` );

    res.push( '        return res;' );

    const output = source.replace( 'AFX_CONFIG_ENTRY', res.join( '\n' ) );
    stopwatch.end();
    return output;
};

/**
 * get version constants from package.json
 *
 * @returns {Object} version constants
 */
const getVersionConstants = () => {
    const pkgJson = require( `${process.cwd()}/package.json` );
    const versionJson = {
        description: pkgJson.description,
        name: pkgJson.name,
        version: pkgJson.version,
        buildTime: new Date().toString()
    };
    versionJson.afx = {
        description: afxPkgJson.description,
        name: afxPkgJson.name,
        version: afxPkgJson.version
    };
    return versionJson;
};
