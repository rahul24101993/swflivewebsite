// Copyright (c) 2022 Siemens

const { getAliasMap, getSelectedSite, isBootstrapAliasImport, isJSImport, isConfigImport, isViewModelImport, isImageImport, isNodeTemplateImport } = require( './utils' );
const { Stopwatch } = require( './perfUtils' );
const logger = require( '../js/logger' );
const { shortenPath } = require( '../js/util' );
const path = require( 'path' );
const { existsSync } = require( 'fs' );
const { forEach } = require( 'lodash' );
const { readJsonSync } = require( 'fs-extra' );

// TODO Remove these as soon as they are fixed. Only temporarily added to avoid further regressions.
const tempExceptions = [
    'Debug',
    'js/Awp0ViewerGalleryUtils',
    'js/MarkupOnScreen3d',
    'js/MarkupViewModel',
    'js/addMeasurableAttr',
    'js/addRemoveProjectTeamMembersSvc',
    'js/associatedProcessesForMbomNodeService',
    'js/aw-default-cell.directive',
    'js/aw-icon-button.directive',
    'js/aw-list.directive',
    'viewmodel/Pca0FullScreenConfigurationViewModel',
    'js/aw-panel-section.directive',
    'js/aw-universal-viewer.controller',
    'js/bct/bct-inspector',
    'js/scheduleNavigationTreeArrangeService',
    'js/uwDirectiveHtmlPanelUtils',
    'viewmodel/AwDefaultCellContent'
];

class AliasResolvePlugin {
    constructor( { srcPaths, solutionName } ) {
        const stopwatch = new Stopwatch( 'AliasResolvePlugin' );
        this.srcPaths = srcPaths;
        this.solutionName = solutionName;
        //generate Alias map
        const data = getAliasMap( srcPaths, solutionName );
        this.aliasMap = data.aliasMap;
        this.resolveNewFile = data.resolveNewFile;
        this.bootstrapAliases = data.bootstrapAliases;
        this.siteInfo = getSelectedSite();
        this.imageLookupMap = {};
        this.populateImageAliases();
        stopwatch.end();
    }

    populateImageAliases() {
        if( process.env.FORCE_IMAGE_OPTIMIZATION !== 'false' ) {
            const imagesDirPath = path.join( process.cwd(), 'node_modules/@swf/images' );
            if( existsSync( imagesDirPath ) ) {
                const lookupJson = readJsonSync( `${imagesDirPath}/lookup.json` );
                forEach( lookupJson, ( imagePath, alias ) => {
                    this.imageLookupMap[ alias ] = path.join( imagesDirPath, imagePath );
                } );
            }
        } else {
            logger.info( 'SVG Image Optimization disabled' );
        }
    }

    resolveImageAlias( request ) {
        const context = request.context;
        const innerRequest = request.request;
        if( innerRequest.startsWith( 'image/' ) && context && context.issuer && /\.js$/.test( context.issuer ) ) {
            if( this.imageLookupMap[ innerRequest ] ) {
                return this.imageLookupMap[ innerRequest ];
            }
        }
        return null;
    }

    apply( resolver ) {
        resolver.getHook( 'resolve' ).tapAsync( 'AliasResolvePlugin', ( request, resolveContext, callback ) => {
            const stopwatch = new Stopwatch( 'AliasResolvePlugin' );
            const innerRequest = request.request;
            const imagePath = this.resolveImageAlias( request );
            if( imagePath ) {
                request = {
                    ...request,
                    request: imagePath
                };
            } else if( this.aliasMap[ innerRequest ] ) {
                request = {
                    ...request,
                    request: this.aliasMap[ innerRequest ]
                };
            } else if( isConfigImport( innerRequest ) ) {
                // https://stackoverflow.com/questions/28026428/is-it-possible-to-create-custom-resolver-in-webpack
                request = {
                    ...request,
                    request: this.aliasMap[ 'js/configEntry' ],
                    query: `?${innerRequest.replace( '/', '=' )}`
                };
            } else if( isJSImport( innerRequest ) || isViewModelImport( innerRequest ) || isImageImport( innerRequest ) || isBootstrapAliasImport( innerRequest, this.bootstrapAliases ) ||
                isNodeTemplateImport( innerRequest ) ) {
                let notFound = false;
                if( AliasResolvePlugin.isDevServer ) {
                    const alias = this.resolveNewFile( innerRequest );
                    if( alias ) {
                        this.aliasMap[ innerRequest ] = alias[ innerRequest ];
                    } else {
                        notFound = true;
                        this.aliasMap[ innerRequest ] = this.aliasMap[ 'js/mockDepsAlias' ];
                    }
                    request = {
                        ...request,
                        request: this.aliasMap[ innerRequest ]
                    };
                } else {
                    notFound = true;
                    request = {
                        ...request,
                        request: this.aliasMap[ 'js/mockDepsAlias' ]
                    };
                }
                if( notFound ) {
                    const msg = `The dependency '${innerRequest}' in '${shortenPath( request.context.issuer )}' not found.`;
                    if( !tempExceptions.includes( innerRequest ) && this.siteInfo.content.name !== 'min' ) {
                        throw new Error( msg );
                    } else {
                        logger.warn( msg );
                    }
                }
            } else if( innerRequest === 'angular' ) {
                this.aliasMap[ innerRequest ] = this.aliasMap[ 'js/mockDepsAlias' ];
                request = {
                    ...request,
                    request: this.aliasMap[ 'js/mockDepsAlias' ]
                };
            }
            const target = resolver.ensureHook( 'parsedResolve' );
            stopwatch.end();
            return resolver.doResolve( target, request, null, resolveContext, callback );
        } );
    }
}

module.exports = AliasResolvePlugin;
