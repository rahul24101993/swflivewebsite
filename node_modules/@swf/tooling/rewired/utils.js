// Copyright (c) 2022 Siemens
/* eslint-disable complexity */

const { ensureDirSync, pathExistsSync, mkdirsSync, readFileSync, readJsonSync, rmdirSync, writeJsonSync } = require( 'fs-extra' );
const glob = require( 'glob' );
const minimatch = require( 'minimatch' );
const _ = require( 'lodash' );
const { basename, dirname, extname, join, resolve, sep } = require( 'path' );
const logger = require( '../js/logger' );

const testRun = /test.js/.test( basename( process.argv[ 1 ] ) );
let imageBundles = null;

let _artifactJsonPaths;
const getArtifactPaths = srcPaths => {
    if( !_artifactJsonPaths ) {
        const fullPaths = srcPaths.map( srcPath => `${process.cwd()}/${srcPath}/**/@(kit|module|bootstrap|site_*|war_*).json` );
        _artifactJsonPaths = [];
        for( const fullPath of fullPaths ) {
            _artifactJsonPaths = _artifactJsonPaths.concat( glob.sync( fullPath ) );
        }
    }
    return _artifactJsonPaths;
};

let _buildPaths;
const getBuildRootPaths = srcPaths => {
    if( !_buildPaths ) {
        const fullPaths = srcPaths.map( srcPath => `${process.cwd()}/${srcPath}` );
        _buildPaths = {};
        for( const fullPath of fullPaths ) {
            glob.sync( fullPath ).forEach( p => _buildPaths[ p ] = true );
        }
    }
    return _buildPaths;
};

const createSiteCache = ( artifactPaths ) => {
    const siteJsonPaths = _.filter( artifactPaths, fPath => basename( fPath ).startsWith( 'site_' ) || basename( fPath ).startsWith( 'war_' ) );
    const siteJsonCache = {};
    for( const sitePath of siteJsonPaths ) {
        const key = basename( sitePath, extname( sitePath ) );
        const contents = readJsonSync( sitePath );
        if( contents ) {
            siteJsonCache[ key ] = { path: sitePath, content: contents };
        }
    }
    return siteJsonCache;
};

const createKitCache = ( srcPaths, artifactPaths ) => {
    const kitJsonPaths = _.filter( artifactPaths, fPath => fPath.endsWith( '/kit.json' ) );
    const kitJsonCache = {};
    for( const kitPath of kitJsonPaths ) {
        const contents = readJsonSync( kitPath );
        if( contents ) {
            kitJsonCache[ contents.name ] = { path: kitPath, content: contents };
        }
    }
    return kitJsonCache;
};

const createModuleCache = ( srcPaths, artifactPaths ) => {
    const moduleJsonPaths = _.filter( artifactPaths, fPath => fPath.endsWith( '/module.json' ) );
    const moduleJsonCache = {};
    for( const modulePath of moduleJsonPaths ) {
        let contents = readJsonSync( modulePath );
        if( contents ) {
            if( _buildJson.modules && _buildJson.modules[ contents.name ] ) {
                contents = _.merge( contents, _buildJson.modules[ contents.name ] );
            }
            const srcPath = dirname( modulePath );
            const pathFromSrc = extractPathFromSrc( srcPaths, srcPath );
            moduleJsonCache[ contents.name ] = { path: modulePath, srcPath, pathFromSrc, content: contents };
            let srcDir = contents.srcDir || 'src';
            if( contents.pathOffset === '.' ) {
                srcDir += '/assets'; // TODO validate this assumption
            }
            moduleJsonCache[ contents.name ].srcDir = srcDir;

            //create module to states mapping
            const statesJsonPath = join( srcPath, '/states.json' );
            if( pathExistsSync( statesJsonPath ) ) {
                const statesJsonContents = readJsonSync( statesJsonPath );
                if( statesJsonContents ) {
                    moduleJsonCache[ contents.name ].states = statesJsonContents;
                }
            }
            //create module to commands mapping
            const commandsViewModelJsonPath = join( srcPath, '/commandsViewModel.json' );
            if( pathExistsSync( commandsViewModelJsonPath ) ) {
                const commandsViewModelContents = readJsonSync( commandsViewModelJsonPath );
                if( commandsViewModelContents ) {
                    moduleJsonCache[ contents.name ].commands = commandsViewModelContents.commands;
                }
            }
        }
    }
    return moduleJsonCache;
};

const createBootstrapCache = ( srcPaths, artifactPaths ) => {
    const moduleBootstrapJsonPaths = _.filter( artifactPaths, fPath => fPath.endsWith( '/bootstrap.json' ) );
    const bootstrapJsonCache = {};
    for( const moduleBootstrapPath of moduleBootstrapJsonPaths ) {
        const contents = readJsonSync( moduleBootstrapPath );
        if( contents ) {
            const srcPath = dirname( moduleBootstrapPath );
            const pathFromSrc = extractPathFromSrc( srcPaths, srcPath );
            const moduleName = _.findKey( moduleCache, module => { return module.srcPath === srcPath; } );
            bootstrapJsonCache[ moduleName ] = { path: moduleBootstrapPath, srcPath, content: contents, pathFromSrc };
        }
    }
    return bootstrapJsonCache;
};

const findBaseKits = kitCache => {
    if( testRun ) {
        const kits = [];
        for( const name in kitCache ) {
            // const kit = kitCache[ name ].content;
            // if( !kit.skipSonar ) {
            kits.push( name );
            // }
        }
        return kits;
    }
    const siteToBuild = getSelectedSite().content;
    if( !siteToBuild.kits ) {
        throw new Error( `${siteToBuild.name} does not have kits configured` );
    }
    return siteToBuild.kits;
};

const getEffectiveKits = ( kitCache, kitNames ) => {
    let effectiveKits = [];
    for( const kitName of kitNames ) {
        if( !kitCache[ kitName ] ) {
            logger.warn( `Not able to find associated kit file for kit ${kitName}` );
        } else {
            effectiveKits.push( kitName );
            const kitContents = kitCache[ kitName ].content;
            if( kitContents.kitDeps && kitContents.kitDeps.length ) {
                if( kitName === 'afx-vis-viewer' ) {
                    // https://gitlab.industrysoftware.automation.siemens.com/Apollo/swf/-/issues/295
                    kitContents.kitDeps = _.remove( kitContents.kitDeps, 'afx' );
                }
                effectiveKits = effectiveKits.concat( getEffectiveKits( kitCache, kitContents.kitDeps ) );
            }
        }
    }
    return effectiveKits;
};
const getBootstrapJsonForModule = ( bootstrapCache, moduleName ) => {
    if( bootstrapCache[ moduleName ] ) {
        const bootstrapJsonData = bootstrapCache[ moduleName ];
        return bootstrapJsonData.content;
    }
    return {};
};

/**
 * Apply bootstrap alias to an alias
 *
 * - Use case 1:
 *   - key: soa, value: js/soa, alias: js/soa/constantsService, src: src/kernel/src/js/soa/constantsService.js
 *   - In this case, the return value will be 'soa/constansService' and point to src
 *
 * - Use case 2: ( supported in 20200901 )
 *   - key: js/awGraphService, value: js/rtMockService, alias: js/rtMockService, src: src\thinclientfx\ba\src\js\rtMockService.js
 *   - In this case, there is a possibility that we have other alias points to the same file.
 *
 * - Use case 3: ( not supported yet, will test it later )
 *   - key: kanban, value: webix/kanban/kanban, alias: ???, src: node_module/kanban/kanban.js
 *
 * @param {*} alias 'raw alias' calculated from source path
 * @param {*} moduleAliases bootstrap.config.paths
 * @returns {Array} a list of 'patched alias'. Refer to main JsDoc
 */
const applyBootstrapAlias = ( alias, moduleAliases ) => {
    const aliasList = [];
    for( const key in moduleAliases ) {
        const value = moduleAliases[ key ];
        if( alias.startsWith( value ) ) {
            aliasList.push( alias.replace( value, key ) );
        }
    }
    return aliasList;
};

// Resolve bootstrap alias
const resolveBootstrapAlias = ( innerRequest, moduleAliases ) => {
    for( const key in moduleAliases ) {
        const value = moduleAliases[ key ];
        if( innerRequest.startsWith( key ) ) {
            return innerRequest.replace( key, value );
        }
    }
    return innerRequest;
};

let aliasMap = {};

/**
 *
 * @param {String} key - key
 * @param {String} value - value
 */
function addToAliasMap( key, value ) {
    if( aliasMap[ key ] ) {
        const msg = `Duplicate alias for ${key}:\n\t${aliasMap[key]}\n\t${value}`;
        if( unitTestRun || process.env.CI !== 'true' ) {
            logger.warn( msg );
        } else {
            throw new Error( msg );
        }
        if( key === 'app' && /\bsamples\b/.test( value ) ) {
            logger.warn( msg );
            return; // skip
        }
    }
    aliasMap[ key ] = value;
}

const resolveAlias = name => aliasMap[ name ];

const generateAliasForModule = ( moduleCache, moduleAliases, moduleName, isUnitTest ) => {
    if( moduleCache[ moduleName ] ) {
        const moduleData = moduleCache[ moduleName ];

        const generateAlias = ( isUnitTest ) => {
            // js files
            const root = !isUnitTest ? moduleData.srcDir : 'test';
            const jsFiles = glob.sync( `${moduleData.srcPath}/${root}/**/*.js` );
            for( const jsFile of jsFiles ) {
                const value = jsFile.replace( /\.js?/g, '' ).trim();
                let alias = value.replace( `${moduleData.srcPath}/${root}/`, '' ).trim();
                const aliasList = applyBootstrapAlias( alias, moduleAliases );
                if( aliasList.length > 0 ) {
                    aliasList.forEach( a => {
                        addToAliasMap( a, value );
                    } );
                } else {
                    // revisitme - maybe we should remove the else? we will see...
                    addToAliasMap( alias, value );
                }
            }

            //json files
            const jsonFiles = glob.sync( `${moduleData.srcPath}/${root}/**/*.json` );
            for( const jsonFile of jsonFiles ) {
                const value = jsonFile.replace( /\.json?/g, '' ).trim();
                const key = value.replace( `${moduleData.srcPath}/${root}/`, '' ).trim();
                // generate aliases of viewmodels for backward compatibility
                // ex. CommonRootViewModel will be available as commonRootViewModel\
                if( key.includes( 'viewmodel/' ) ) {
                    const viewName = key.split( 'viewmodel/' )[ 1 ];
                    const viewNameFirstChar = viewName.charAt( 0 );
                    if( viewNameFirstChar.toUpperCase() === viewNameFirstChar ) {
                        aliasMap[ 'viewmodel/' + viewNameFirstChar.toLowerCase() + viewName.substring( 1 ) ] = value;
                    }
                    // revisitme - we can put a if condition here to only allow AbcViewModel go into deps
                    viewDeps[ viewName.replace( /ViewModel$/, '' ) ] = {
                        import: `import ${viewName.replace( /ViewModel$/, '' )} from '${key}';`,
                        props: JSON.parse( readFileSync( `${value}.json`, 'utf-8' ) ).props || {}
                    };
                }

                // support alias like policies/xxxObjectPropertyPolicy
                const aliasList1 = applyBootstrapAlias( key, moduleAliases );
                // support alias like policies/xxxPropertyPolicy.json
                const alias2 = jsonFile.replace( `${moduleData.srcPath}/${root}/`, '' ).trim();
                const aliasList2 = applyBootstrapAlias( alias2, moduleAliases );

                if( aliasList1.length > 0 || aliasList2.length > 0 ) {
                    aliasList1.forEach( a => aliasMap[ a ] = value );
                    aliasList2.forEach( a => aliasMap[ a ] = value );
                } else {
                    // support alias like policies/xxxPropertyPolicy.json
                    aliasMap[ alias2 ] = value;
                    // support alias like policies/xxxObjectPropertyPolicy
                    aliasMap[ key ] = value;
                }
            }

            //nodeTemplate html
            if( pathExistsSync( `${moduleData.srcPath}/${root}/nodeTemplates` ) ) {
                const nodeTemplateFiles = glob.sync( `${moduleData.srcPath}/${root}/nodeTemplates/*.html` );
                for( const ntFile of nodeTemplateFiles ) {
                    const value = ntFile.replace( /\.html?/, '' ).trim();
                    let alias = value.replace( `${moduleData.srcPath}/${root}/`, '' ).trim();
                    addToAliasMap( alias, ntFile );
                }
            }

            // Grab configuration json files needed for testing
            if( isUnitTest ) {
                const configJsonFiles = glob.sync( `${moduleData.srcPath}/*.json` );
                for( const jsonFile of configJsonFiles ) {
                    const value = jsonFile.replace( /\.json?/g, '' ).trim();
                    const key = value.replace( `${moduleData.srcPath}/`, '' ).trim();
                    if( key.includes( 'typeProperties' ) ||
                        key.includes( 'states' ) ||
                        key.includes( 'hosting' ) ||
                        key.includes( 'paste' ) ||
                        key.includes( 'testdatamaster' ) ) {
                        let alias = `/config/${moduleData.pathFromSrc}/${key}`;
                        addToAliasMap( alias, value );
                    }
                }
            }

            //image Files
            const imageFiles = glob.sync( `${moduleData.srcPath}/${root}/@(image|images)/**/*` );
            for( const imageFile of imageFiles ) {
                const value = imageFile.replace( /\.*?/g, '' ).trim();
                const key = value.replace( `${moduleData.srcPath}/${root}/`, '' ).trim();
                aliasMap[ key ] = value;
                imageAlias.add( key );
            }
        };

        if( isUnitTest ) {
            generateAlias( isUnitTest );
        }
        generateAlias();
    }

    return aliasMap;
};

const getAllModuleNonThemeScssFiles = ( effectiveModules, moduleCache ) => {
    //logger.debug( ` ... excluding SCSS ${scssToExclude.map( x => logger.nameColor( x ) ).join( ',' )}`, localVars.MSG_PREFIX );
    const sources = [
        '_*.scss',
        '*.css'
    ];

    const ignoreSources = [
        '_module.scss',
        '*+(overlay|theme|Theme).*css'
    ];

    let moduleCssFiles = [];
    for( const moduleName of effectiveModules ) {
        const moduleData = moduleCache[ moduleName ];
        const scssFiles = glob.sync( `${moduleData.srcPath}/${moduleData.srcDir}/{${sources.join( ',' )}}`, {
            ignore: [ `${moduleData.srcPath}/${moduleData.srcDir}/{${ignoreSources.join( ',' )}}` ]
        } );
        for( const file of scssFiles ) {
            moduleCssFiles.push( file );
        }
    }

    let moveTcWidgetsFirst = ( a, b ) => {
        if( a.endsWith( '_tcWidgets.scss' ) ) {
            return -1;
        }
        if( b.endsWith( '_tcWidgets.scss' ) ) {
            return 1;
        }
        return a.localeCompare( b );
    };

    // logger.debug( ` ... including partial SCSS ${sortedImports.map( x => logger.nameColor( x ) ).join( ',' )}`, localVars.MSG_PREFIX );
    // logger.verbose( ` ... generated module SCSS${stopwatch.end()}`, localVars.MSG_PREFIX );
    return moduleCssFiles.sort( moveTcWidgetsFirst );
};

const getAllModuleThemeScssFiles = ( effectiveModules, moduleCache ) => {
    const moduleThemeScssFiles = [];
    for( const moduleName of effectiveModules ) {
        const moduleData = moduleCache[ moduleName ];
        // Loop through all module.json files content and see if they mention any consumer theme files entry
        if( moduleData.content && moduleData.content.themeExtensions ) {
            for( const themeExtension of moduleData.content.themeExtensions ) {
                const themeExtensionName = themeExtension.startsWith( '_' ) ? themeExtension : '_' + themeExtension;
                moduleThemeScssFiles.push( `${moduleData.srcPath}/${moduleData.srcDir}/${themeExtensionName}.scss` );
            }
        }
    }
    return moduleThemeScssFiles;
};

/**
 * Method to extract all commands in a given module
 * @param {Array} commandsList - list of comamnds in the given module
 * @param {Object} moduleData
 * @returns {Array} - updated commands list after processing the current module 
 */
const getCommandsList = ( commandsList, moduleData ) => {
    if( moduleData.commands ) { return commandsList.concat( Object.keys( moduleData.commands ) ); }
    return commandsList;
};

/**
 * Method to extract all locations in a given module
 * @param {Array} locationsList - list of locations in the given module
 * @param {Object} moduleData 
 * @returns {Array} updated locations list after processing the current module
 */
const getLocationsList = ( locationsList, moduleData ) => {
    if( moduleData.states ) { return locationsList.concat( Object.keys( moduleData.states ) ); }
    return locationsList;
};

/**
 * Method to extract all scss file names (excluding main.scss and which do not start with _) in a given module
 * @param {Array} themeWhiteList - list of scss files in the given module
 * @param {Object} moduleData 
 * @returns {Array} updated themes list after processing the current module
 */
const getThemeWhiteList = ( themeWhiteList,  moduleData ) => {
    const scssFilesExtension = '*.scss';
    const scssFilePaths = glob.sync( `${moduleData.srcPath}/${moduleData.srcDir}/${scssFilesExtension}` );
    const scssFileNames = scssFilePaths.map( filePath => basename( filePath ) );
    scssFileNames.forEach( filename => {
        if( extname( filename ) === '.scss' && filename.charAt( 0 ) !== '_' ) {
            const name_of_theme = filename.replace( '.scss', '' );
            if( themeWhiteList.indexOf( name_of_theme ) === -1 && name_of_theme !== 'main' ) {
                themeWhiteList.push( name_of_theme );
            }
        }
    } );
    return themeWhiteList;
};

/**
 * Method to retrieve info about commands, locations and themes for OOTB modules
 * @returns {Object} OOTB_Verification object
 */
const getOOTBList = () => {
    let commandsList = [];
    let locationsList = [];
    let themeWhiteList = [];

    for( const moduleName of effectiveModules ) {
        const moduleData = moduleCache[ moduleName ];
        if( moduleData && moduleData.content.OOTB ) {
            commandsList = getCommandsList( commandsList, moduleData );
            locationsList = getLocationsList( locationsList, moduleData );
            themeWhiteList = getThemeWhiteList( themeWhiteList, moduleData );
        }
    }

    return {
        commands: commandsList,
        locations: locationsList,
        themes: themeWhiteList
    };
};

const isBootstrapAliasImport = ( innerRequest, moduleAliases ) => {
    // Check if requesting via a bootstap alias
    let bootstrapAliasImport = false;
    for( const alias in moduleAliases ) {
        // There are two possibilities to use alias
        // ex. "app" alias use as "app" or "soa" alias use as "soa/xxx"
        if( alias === innerRequest || innerRequest.startsWith( alias + '/' ) ) {
            bootstrapAliasImport = true;
            break;
        }
    }
    return bootstrapAliasImport;
};

const isJSImport = ( innerRequest ) => {
    return innerRequest.startsWith( 'js/' );
};

const isConfigImport = ( innerRequest ) => {
    return innerRequest.startsWith( 'config/' );
};

const isViewModelImport = ( innerRequest ) => {
    return innerRequest.startsWith( 'viewmodel/' );
};

const isImageImport = ( innerRequest ) => {
    return innerRequest.startsWith( 'image/' ) || innerRequest.startsWith( 'images/' );
};

const isNodeTemplateImport = ( innerRequest ) => {
    return innerRequest.startsWith( 'nodeTemplates/' );
};

const resolveNewFile = ( innerRequest, effectiveModules, moduleCache, bootstrapAliases ) => {
    const fileName = innerRequest.replace( /^[\S]*\//g, '' );
    let alias = null;
    if( isImageImport( innerRequest ) ) {
        for( const moduleName of effectiveModules ) {
            const moduleData = moduleCache[ moduleName ];
            if( moduleData ) {
                const imageFiles = glob.sync( `${moduleData.srcPath}/${moduleData.srcDir}/@(image|images)/**/*` );
                for( const imageFilePath of imageFiles ) {
                    if( imageFilePath.endsWith( `/${fileName}` ) ) {
                        alias = {};
                        alias[ innerRequest ] = imageFilePath;
                        imageAlias.add( innerRequest );
                        return false;
                    }
                }
            }
            if( alias && alias[ innerRequest ] ) {
                return false;
            }
        }
    } else if( isViewModelImport( innerRequest ) ) {
        //viewModel import
        for( const moduleName of effectiveModules ) {
            const moduleData = moduleCache[ moduleName ];
            if( moduleData ) {
                const vmFiles = glob.sync( `${moduleData.srcPath}/${moduleData.srcDir}/viewmodel/*.json` );
                for( const vmFilePath of vmFiles ) {
                    if( vmFilePath.endsWith( `/${fileName}.json` ) ) {
                        alias = {};
                        alias[ innerRequest ] = vmFilePath;
                        return false;
                    }
                }
            }
            if( alias && alias[ innerRequest ] ) {
                return false;
            }
        }
    } else if( isJSImport( innerRequest ) ) {
        for( const moduleName of effectiveModules ) {
            const moduleData = moduleCache[ moduleName ];
            if( moduleData ) {
                const jsFiles = glob.sync( `${moduleData.srcPath}/${moduleData.srcDir}/js/**/*.js` );
                for( const jsFilePath of jsFiles ) {
                    if( jsFilePath.endsWith( `/${fileName}.js` ) ) {
                        alias = {};
                        alias[ innerRequest ] = jsFilePath;
                        return false;
                    }
                }
            }
            if( alias && alias[ innerRequest ] ) {
                return false;
            }
        }
    } else if( isBootstrapAliasImport( innerRequest, bootstrapAliases ) ) {
        for( const moduleName of effectiveModules ) {
            const moduleData = moduleCache[ moduleName ];
            if( moduleData ) {
                const jsFiles = glob.sync( `${moduleData.srcPath}/${moduleData.srcDir}/js/**/*.js` );
                const resolvedInnerRequest = resolveBootstrapAlias( innerRequest, bootstrapAliases );
                for( const jsFilePath of jsFiles ) {
                    if( jsFilePath.endsWith( `/${resolvedInnerRequest}.js` ) ) {
                        alias = {};
                        alias[ innerRequest ] = jsFilePath;
                        return false;
                    }
                }
            }
            if( alias && alias[ innerRequest ] ) {
                return false;
            }
        }
    } else if( isNodeTemplateImport( innerRequest ) ) {
        for( const moduleName of effectiveModules ) {
            const moduleData = moduleCache[ moduleName ];
            if( moduleData && pathExistsSync( `${moduleData.srcPath}/${moduleData.srcDir}/nodeTemplates` ) ) {
                const ntFiles = glob.sync( `${moduleData.srcPath}/${moduleData.srcDir}/nodeTemplates/*.html` );
                for( const ntFilePath of ntFiles ) {
                    if( ntFilePath.endsWith( `/${fileName}.html` ) ) {
                        alias = {};
                        alias[ innerRequest ] = ntFilePath;
                        return false;
                    }
                }
            }
            if( alias && alias[ innerRequest ] ) {
                return false;
            }
        }
    }
    return alias;
};

const buildPathCache = {};
const moduleCache = {};
const kitCache = {};
const bootstrapCache = {};
const effectiveBootstrapCache = {};
const viewDeps = {};

const siteCache = {};
let modulePathNames = [];
let moduleScssFiles = [];
let moduleThemeFiles = [];
let effectiveKits = [];
let effectiveKitPaths = [];
let effectiveModules = [];

const getEffectiveBootstrapCache = () => effectiveBootstrapCache;

const getSiteCache = () => siteCache;

const getBuildPathCache = () => buildPathCache;

const getKitCache = () => kitCache;

const getEffectiveModules = () => effectiveModules;

const getEffectiveKitNames = () => effectiveKits;

const getEffectiveKitPaths = () => effectiveKitPaths;

const getEffectiveAlias = () => aliasMap;

const getModuleCache = () => moduleCache;

const getModuleScssFiles = () => moduleScssFiles;

const getThemeScssFiles = () => moduleThemeFiles;

const getViewDep = elemName => viewDeps[ elemName ];

const getImageAlias = () => imageAlias;

const imageAlias = new Set();

let sourcePaths = null;

let unitTestRun = false;

/**
 * Given a module or kit recursively grab the kits needed to run tests for that module
 * @param {Object} kitCache - the kitCache object for all kits
 * @param {String} kitName - the name of the kit to find dep kits for
 * @returns {Array} - array of dep kits
 */
const getKitDep = ( kitCache, kitName ) => {
    const kits = [];
    // These lines are needed because of kit dependecy issues.. these will be removed when those are cleaned up
    if( kitName === 'tc-aw-framework' ) {
        kits.push( 'search' );
    } else if( kitName === 'programPlanning' || kitName === 'schedulemanager' ) {
        kits.push( 'programPlanning', 'schedulemanager' );
    } else if( kitName === 'qualityactionmgmt' ) {
        kits.push( 'apqpprogrammgt', 'capa' );
    }

    if( kitName !== 'afx' ) {
        kits.push( kitName );
        if( kitCache[ kitName ].content.kitDeps && kitCache[ kitName ].content.kitDeps.length > 0 ) {
            for( const depKitName of kitCache[ kitName ].content.kitDeps ) {
                kits.push( ...getKitDep( kitCache, depKitName ) );
            }
        }
    }
    return kits;
};

/**
 * Given a module or kit recursively grab the kits needed to run tests for that module
 * @param {Object} kitCache - the kitCache object for all kits
 * @param {Object} moduleCache - the moduleCache object for all kits
 * @returns {Array} - array of kits to be tested
 */
const getTestedKits = ( kitCache, moduleCache ) => {
    const testedKits = [];
    const testedModule = process.env.TESTED_MODULE;
    const testedKit = process.env.TESTED_KIT;
    if( testedModule && moduleCache[ testedModule ] ) {
        for( const kitName of Object.keys( kitCache ) ) {
            const kitContent = kitCache[ kitName ].content;
            if( kitContent.modules && kitContent.modules.includes( testedModule ) ) {
                testedKits.push( ...getKitDep( kitCache, kitName ) );
            }
        }
    } else if( testedKit && kitCache[ testedKit ] ) {
        testedKits.push( ...getKitDep( kitCache, testedKit ) );
    }
    return testedKits;
};

const getAliasMap = ( srcPaths, isUnitTest ) => {
    unitTestRun = isUnitTest;

    /**
     * Algo
     * 1. Get All artifacts like site_*.json, kit.json and module.json
     * 2. Read All site_* files
     * 3. Read kits property from site_*.json file by filtering site_*.json files with solution name
     * 4. Get all Kits and effective modules from those kits
     * 5. Generate Alias map of js and viewmodel files in those modules
     */
    sourcePaths = srcPaths;
    const artifactPaths = getArtifactPaths( srcPaths );
    Object.assign( buildPathCache, getBuildRootPaths( srcPaths ) );
    if( _.isEmpty( siteCache ) ) {
        Object.assign( siteCache, createSiteCache( artifactPaths ) );
    }
    if( _.isEmpty( kitCache ) ) {
        Object.assign( kitCache, createKitCache( srcPaths, artifactPaths ) );
    }
    if( _.isEmpty( moduleCache ) ) {
        Object.assign( moduleCache, createModuleCache( srcPaths, artifactPaths ) );
    }
    Object.assign( bootstrapCache, createBootstrapCache( srcPaths, artifactPaths ) );

    let testedKits = isUnitTest ? getTestedKits( kitCache, moduleCache ) : [];
    testedKits = [ ...new Set( testedKits ) ];
    const baseKits = findBaseKits( kitCache );
    effectiveKits = getEffectiveKits( kitCache, baseKits );
    // remove duplicates
    effectiveKits = [ ...new Set( effectiveKits ) ];
    //revisiteme:we need different getAliasMap function or some adjustment here
    //for unit test flow as it is not dependant on any solution
    for( const kitName of effectiveKits ) {
        if( testedKits.length > 0 && testedKits.includes( kitName ) || testedKits.length === 0 ) {
            const effectiveKit = kitCache[ kitName ].content;
            if( effectiveKit.modules ) {
                modulePathNames = modulePathNames.concat( effectiveKit.modules.map( m => {
                    if( !moduleCache[ m ] ) {
                        throw new Error( `Module "${m}" not found` );
                    }
                    if( effectiveKit.OOTB ) {
                        moduleCache[ m ].content.OOTB = true;
                    }
                    moduleCache[ m ].srcPath.replace( /^.*[\\/]([^\\/]*)$/, '$1' );
                } ) );
                effectiveModules = effectiveModules.concat( effectiveKit.modules );
            }
        }
    }
    //remove duplicate modules
    effectiveModules = [ ...new Set( effectiveModules ) ];

    // get effective kit path
    for( const kitName of effectiveKits ) {
        const kitPath = kitCache[ kitName ].path;
        effectiveKitPaths.push( kitPath.replace( /[\\/]kit\.json$/, '' ) );
    }
    effectiveKitPaths = [ ...new Set( effectiveKitPaths ) ];

    // Get bootstrap module aliases
    let bootstrapAliases = {};
    for( const moduleName of effectiveModules ) {
        if( bootstrapCache[ moduleName ] ) {
            const bootstrapData = bootstrapCache[ moduleName ];

            //bootstrap.json
            if( bootstrapData.content && bootstrapData.content.config && bootstrapData.content.config.paths ) {
                Object.assign( bootstrapAliases, bootstrapData.content.config.paths );
            }
        }
    }

    for( const effModule of effectiveModules ) {
        aliasMap = Object.assign( aliasMap, generateAliasForModule( moduleCache, bootstrapAliases, effModule, isUnitTest ) );
        merge( effectiveBootstrapCache, getBootstrapJsonForModule( bootstrapCache, effModule ) );
    }

    if( !testRun ) {
        //Populate src image aliases
        const buildJson = getBuildJson();
        const pathToReplace = `${process.cwd().replace( /\\/g, '/' )}/${buildJson.imageDir.replace( /\/image$/, '' )}/`;
        const srcImageFiles = glob.sync( resolve( `${process.cwd()}/${buildJson.imageDir}/**/*` ) );
        for( const imageFile of srcImageFiles ) {
            const key = imageFile.replace( pathToReplace, '' ).trim();
            aliasMap[ key ] = imageFile;
            imageAlias.add( key );
        }

        //Populate ModuleCssFiles
        moduleScssFiles = getAllModuleNonThemeScssFiles( effectiveModules, moduleCache );
        moduleThemeFiles = getAllModuleThemeScssFiles( effectiveModules, moduleCache );
    }
    return { aliasMap, resolveNewFile: ( innerRequest ) => resolveNewFile( innerRequest, effectiveModules, moduleCache, bootstrapAliases ), bootstrapAliases };
};

const getSelectedSite = () => {
    const buildJson = getBuildJson();
    const artifactPaths = getArtifactPaths( buildJson.srcPaths );
    if( _.isEmpty( siteCache ) ) {
        Object.assign( siteCache, createSiteCache( artifactPaths ) );
    }
    if( _.isEmpty( kitCache ) ) {
        Object.assign( kitCache, createKitCache( buildJson.srcPaths, artifactPaths ) );
    }
    if( _.isEmpty( moduleCache ) ) {
        Object.assign( moduleCache, createModuleCache( buildJson.srcPaths, artifactPaths ) );
    }
    if( _.isEmpty( siteCache ) && !_.isEmpty( kitCache ) ) {
        // For the case of no sites file, create a kit with ALL kits.
        const site = {
            name: 'all',
            solutionName: '',
            kits: []
        };
        for( const name in kitCache ) {
            const kit = kitCache[ name ].content;
            if( kit.solutionDef ) {
                if( site.solutionName ) {
                    throw new Error( 'Multiple kits found with solutionDef. You must define a site.json.' );
                }
                site.solutionName = kit.name;
            }
            if( kit.name !== 'afx' ) { // don't include gaps in the scenario of no site definition
                site.kits.push( kit.name );
            }
        }
        if( !site.solutionName ) {
            if( testRun ) {
                site.solutionName = 'test';
                kitCache.test = {
                    path: normalizePath( join( process.cwd(), 'out/test/kit.json' ) ),
                    content: {
                        name: 'test',
                        solutionName: 'test',
                        kits: [
                            'afxSansGaps'
                        ],
                        assetsDir: 'assets',
                        solutionDef: {
                            solutionId: 'test',
                            brandName: 'test',
                            solutionName: 'test',
                            solutionVersion: '1.0',
                            browserTitle: 'test',
                            companyName: 'test',
                            copyrightText: 'Copyright © 2021 Siemens',
                            solutionWar: 'test',
                            workspaces: []
                        }
                    }
                };
                ensureDirSync( dirname( kitCache.test.path ) );
                writeJsonSync( kitCache.test.path, kitCache.test.content );
            } else {
                throw new Error( 'No kit found with solutionDef. This is a requirement for a site.' );
            }
        }

        siteCache.all = { content: site };
    }
    let siteDef = {};
    const sites = Object.keys( siteCache );
    if( sites && sites.length ) {
        if( !testRun &&
            sites.length > 1 ) {
            const selectedSiteName = process.env.SITE;
            if( !selectedSiteName ) {
                sites.sort();
                throw new Error( `Multiple sites found, set SITE environment variable to build the site\nAvailable sites: \n\t${sites.join( '\n\t' )}` );
            }
            siteDef = siteCache[ selectedSiteName ];
        } else {
            siteDef = siteCache[ sites[ 0 ] ];
        }
    }
    if( !siteDef.content.solutionName ) {
        throw new Error( `Missing the mandatory attribute solutionName in ${siteDef.content.name}.json!!!` );
    }
    return siteDef;
};

let _buildJson;
const getBuildJson = () => {
    if( !_buildJson ) {
        const buildJsonPath = join( process.cwd(), 'build.json' );
        if( pathExistsSync( buildJsonPath ) ) {
            _buildJson = readJsonSync( buildJsonPath );
        }
        if( !_buildJson ) {
            _buildJson = {};
        }
        if( !_buildJson.imageDir ) {
            _buildJson.imageDir = 'node_modules/@swf/core/src/image';
        }
    }
    return _buildJson;
};

const getRequiredSoa = () => {
    let requiredSoa = [];
    for( const kitName of effectiveKits ) {
        const effectiveKit = kitCache[ kitName ].content;
        if( effectiveKit.soaDeps ) {
            requiredSoa = requiredSoa.concat( effectiveKit.soaDeps );
        }
    }
    // return unique
    return [ ...new Set( requiredSoa ) ];
};

const findWebpackPlugin = ( plugins, pluginName ) =>
    plugins.find( plugin => plugin.constructor.name === pluginName );

const afxSassLoader = { loader: resolve( __dirname, './afxSassLoader.js' ) };

/**
 * This API adds passed fileRegex config to the file-loader configuration's exclude array.
 * @param {Object} config the webpack config which will be mutated
 * @param {regex} fileRegex The file regex which needs to be added to file-loader config
 * @returns {Object} the updated webpack config
 */
const addExcludeFileTypeToFileLoader = ( config, fileRegex ) => {
    const loaders = config.module.rules.find( rule => Array.isArray( rule.oneOf ) ).oneOf;
    for( const usedLoader of loaders ) {
        if( usedLoader.loader && usedLoader.loader.includes( 'file-loader' ) ) {
            usedLoader.exclude && usedLoader.exclude.push( fileRegex );
        }
    }
    return config;
};

const customizeSassLoader = ( config, cssFolderPath ) => {
    const loaders = config.module.rules.find( rule => Array.isArray( rule.oneOf ) ).oneOf;
    for( const loader of loaders ) {
        let isSass = false;
        let sassIndex;
        for( const index in loader.use ) {
            const usedLoader = loader.use[ index ];
            if( usedLoader.loader && usedLoader.loader.includes( 'sass-loader' ) ) {
                usedLoader.options.implementation = require( 'sass' );
                isSass = true;
                sassIndex = parseInt( index ); //index comes as string ,- works but + doesnt
                if( !usedLoader.options ) { usedLoader.options = {}; }
                usedLoader.options.sassOptions = {
                    includePaths: [ cssFolderPath ]
                };
            }
        }
        if( isSass && !loader.use.includes( afxSassLoader ) ) {
            // pre sass loader
            loader.use.push( afxSassLoader );
            // post sass loader
            loader.use.splice( sassIndex - 1, 0, afxSassLoader );
        }
    }
    return config;
};

const removeES5BabelLoader = ( config ) => {
    const loaders = config.module.rules.find( rule => Array.isArray( rule.oneOf ) ).oneOf;
    let isESBabel = false;
    let babelLoader;
    for( const loader of loaders ) {
        const regexStr = loader.test;
        if( String( regexStr ) === String( /\.(js|mjs)$/ ) && loader.loader === require.resolve( 'babel-loader' ) ) {
            isESBabel = true;
            babelLoader = loader;
        }
    }

    if( isESBabel ) {
        loaders.splice( loaders.indexOf( babelLoader ), 1 );
    }

    return config;
};

/**
 * Replace all instances of a given string within a larger string.
 *
 * @param {String} input - input string to replace content
 * @param {String} toFind - string to locate
 * @param {String} toReplace - string to replace
 * @return {String} modified string
 */
const replaceAll = ( input, toFind, toReplace ) => {
    let output = input;
    if( output.indexOf( toFind ) > -1 ) {
        output = output.split( toFind ).join( toReplace );
    }
    return output;
};

const getResolvedSourcePaths = () => {
    let resolvedPaths = [];
    let resolvePathsWithModules = {};
    if( sourcePaths ) {
        const searchPaths = sourcePaths.map( srcPath => join( process.cwd(), srcPath ) );
        for( const searchPath of searchPaths ) {
            const resPath = glob.sync( searchPath );
            if( resPath && resPath.length ) {
                resolvedPaths = resolvedPaths.concat( resPath );
            }
        }
        const effectiveModules = [];
        for( const kitName of effectiveKits ) {
            const effectiveKit = kitCache[ kitName ].content;
            if( effectiveKit ) {
                const kitModuleNames = effectiveKit.modules;
                if( kitModuleNames ) {
                    kitModuleNames.forEach( kitModule => moduleCache[ kitModule ] && effectiveModules.push( moduleCache[ kitModule ] ) );
                }
            }
        }
        for( const searchPath of resolvedPaths ) {
            for( const effModule of effectiveModules ) {
                if( effModule && effModule.pathFromSrc &&
                    effModule.srcPath === `${searchPath}/${effModule.pathFromSrc}` ) {
                    if( !resolvePathsWithModules[ searchPath ] ) {
                        resolvePathsWithModules[ searchPath ] = {};
                    }
                    // use map here to avoid duplication
                    resolvePathsWithModules[ searchPath ][ effModule.pathFromSrc.replace( /[\\/]/g, '[\\\\/]' ) ] = true;
                }
            }
        }

        // convert map back to array to not impact the contract
        for( const k in resolvePathsWithModules ) {
            resolvePathsWithModules[ k ] = Object.keys( resolvePathsWithModules[ k ] );
        }
    }
    return resolvePathsWithModules;
};

/**
 * Normalize the path by using forward slashes instead of back slashes.
 *
 * @param {String} inputPath - input file path
 * @return {String} normalized file path
 */
const normalizePath = inputPath => {
    return replaceAll( inputPath, sep, '/' );
};

const cwd = normalizePath( process.cwd() ) + '/';
const extractPathFromSrc = ( srcPaths, srcPath ) => {
    srcPath = srcPath.replace( cwd, '' );
    for( const srcPattern of srcPaths ) {
        // Ensure that this source path pattern applies to the source path.
        // It might not if another later one does.
        if( minimatch( srcPath, `${srcPattern}/**` ) ) {
            if( /(@\(|\*)/.test( srcPattern ) ) {
                let resolvedPattern = '';
                let matchedElemsCount = 0;
                const srcPatternElems = srcPattern.split( '/' );
                for( const srcPatternElem of srcPatternElems ) {
                    if( srcPatternElem === '*' ) {
                        matchedElemsCount++;
                        resolvedPattern = `${resolvedPattern}${srcPath.split( '/' )[0]}/`;
                    } else if( srcPatternElem.startsWith( '@(' ) ) {
                        const pathPattern = /@\((.*)\)/.exec( srcPatternElem );
                        for( const pathPatternElem of pathPattern[ 1 ].split( '|' ) ) {
                            if( srcPath.startsWith( `${resolvedPattern}${pathPatternElem}/` ) ) {
                                matchedElemsCount++;
                                resolvedPattern = `${resolvedPattern}${pathPatternElem}/`;
                                break;
                            }
                        }
                    } else if( !resolvedPattern && srcPath.startsWith( `${srcPatternElem}/` ) ||
                        resolvedPattern && srcPath.startsWith( `${resolvedPattern}${srcPatternElem}/` ) ) {
                        matchedElemsCount++;
                        resolvedPattern += `${srcPatternElem}/`;
                    }
                    // FIXME doesn't support wildcard with text (i.e. 'xyx*')
                    // FIXME doesn't support variable depth wildcard (i.e. '**')
                }
                if( matchedElemsCount === srcPatternElems.length &&
                    srcPath.startsWith( `${resolvedPattern}` ) ) {
                    srcPath = srcPath.replace( `${resolvedPattern}`, '' );
                    logger.debug( `${srcPath} found in ${resolvedPattern}` );
                    break;
                }
            } else if( srcPath.startsWith( srcPattern ) ) {
                srcPath = srcPath.replace( srcPattern + '/', '' );
                logger.debug( `${srcPath} found in ${srcPattern}` );
                break;
            }
        }
    }
    return srcPath;
};

/**
 * @param {Object} objValue - destination object
 * @param {Object} srcValue source object
 * @return {Object|undefined} modified destination object
 */
function mergeCustomizer( objValue, srcValue ) {
    if( _.isArray( objValue ) ) {
        return objValue.concat( srcValue );
    }
}

/**
 * @param {Object} obj1 object 1
 * @param {Object} obj2 object 2
 * @param {Object|null} check - optional checker object
 * @param {Number|null} depth - depth of merge
 * @type {module.exports.merge}
 */
function merge( obj1, obj2, check, depth ) {
    if( !depth ) { depth = 1; }
    if( _.isNull( obj2 ) ) {
        // nothing to merge
    } else if( _.isNull( obj1 ) ) {
        // logger.error( 'Null object to merge!' );
    } else if( _.isArray( obj1 ) && _.isArray( obj2 ) ) {
        for( let element of obj2 ) {
            // If there was a 'identity' test for the elements, we might be able to merge objects in the array.
            if( !obj1.includes( element ) ) {
                obj1.push( _.cloneDeep( element ) );
            }
        }
    } else if( _.isObject( obj1 ) && _.isObject( obj2 ) ) {
        if( !check ) {
            _.mergeWith( obj1, obj2, mergeCustomizer );
        } else {
            for( const [ key, field ] of Object.entries( obj2 ) ) {
                if( obj1.hasOwnProperty( key ) ) {
                    if( check ) {
                        check.path.push( key );
                        if( check.uniqueDepth !== undefined &&
                            check.uniqueDepth === depth &&
                            !check.path.includes( 'i18n' ) ) {
                            throw new Error( 'Name conflict in ' + check.file + '.json path=' + check.join( '.' ) + ' for module ' + check.moduleName + ' (2nd occurrence)!' );
                        }
                    }
                    module.exports.merge( obj1[ key ], field, check, depth + 1 );
                    if( check ) { check.path.pop(); }
                } else {
                    obj1[ key ] = _.cloneDeep( field );
                }
            }
        }
    } else if( _.isArray( obj1 ) || _.isArray( obj2 ) ) {
        throw new Error( 'Invalid array merge!' );
    } else if( _.isObject( obj1 ) || _.isObject( obj2 ) ) {
        throw new Error( 'Invalid object merge!' );
    }
}

/**
 * convert 'aw-button' to 'AwButton'
 * @param {string} name  name like 'AwButton'
 * @returns {string} name like 'aw-button'
 */
const kebabCaseToPascalCase = name =>
    name.replace( /^./, name[ 0 ].toUpperCase() ).replace( /-(.)/g, ( fullMatch, firstMatch ) => firstMatch.toUpperCase() );

/**
 * convert 'AwButton' to 'aw-button'
 * @param {string} name name like 'AwButton'
 * @returns {string} name like 'aw-button'
 */
const pascalCaseToKebabCase = name =>
    name.replace( /^./, name[ 0 ].toLowerCase() ).replace( /([A-Z])/g, ( fullMatch, firstMatch ) => `-${firstMatch.toLowerCase()}` );

const getEntryHtmlInfo = () => {
    const entryHtmlInfo = {
        filename: '',
        template: ''
    };
    const siteInfo = getSelectedSite();
    const kit = kitCache[ siteInfo.content.solutionName ];

    if( kit && kit.content && kit.content.solutionDef.bundler && kit.content.solutionDef.bundler.entryFiles ) {
        const fileName = kit.content.solutionDef.bundler.entryFiles[ 0 ];
        // Search the associated modules for the index html
        for( const moduleName of kit.content.modules ) {
            const moduleData = moduleCache[ moduleName ];
            const srcPath = join( moduleData.srcPath, moduleData.content.srcDir || 'src', fileName );
            if( pathExistsSync( srcPath ) ) {
                entryHtmlInfo.template = srcPath;
                entryHtmlInfo.filename = fileName;
                break;
            }
        }
    } else {
        const entryHtmlFile = normalizePath( join( kit.path.split( 'kit.json' )[ 0 ], 'src/index.html' ) );
        entryHtmlInfo.template = entryHtmlFile;
        entryHtmlInfo.filename = 'index.html';
    }
    return entryHtmlInfo;
};

const createTestDirs = () => {
    let testOutDir;
    const testedKitName = process.env.TESTED_KIT;
    if( testedKitName ) {
        testOutDir = resolve( `${process.cwd()}/out/test/${testedKitName}` );
    } else {
        testOutDir = resolve( `${process.cwd()}/out/test` );
    }
    rmdirAndCreate( `${testOutDir}/viewmodel` );
    rmdirAndCreate( `${testOutDir}/js` );
    rmdirAndCreate( `${testOutDir}/config` );
    rmdirAndCreate( `${testOutDir}/i18n` );

    return testOutDir;
};

const rmdirAndCreate = path => {
    if( pathExistsSync( path ) ) {
        logger.info( `Removing ${path}` );
        rmdirSync( path, { recursive: true } );
    }
    logger.info( `Creating ${path}` );
    mkdirsSync( path );
};

const getCustomImageBundles = () => {
    let customBundles = {};
    const imageAliasData = [ ...getImageAlias() ];
    const kitCache = getKitCache();
    const siteDef = getSelectedSite();
    const kitJson = kitCache[ siteDef.content.solutionName ];
    const bundles = kitJson.content.solutionDef.imageBundles;
    let isLazyLoadDisabled = false;

    for( const bundleName in bundles ) {
        bundles[ bundleName ].forEach( imageId => {
            if( imageId === '*' ) {
                //If the flag is already set to true, that means a bundle definition is already configured
                //to be the default one. Break the build if duplicate default entries are found.
                if( isLazyLoadDisabled ) {
                    throw new Error( `${bundleName} Duplicate entry found for default image bundle. A solution is restricted to have only ONE default image bundle` );
                }
                isLazyLoadDisabled = bundleName;
            } else if( !imageId.startsWith( 'image/' ) ) {
                const toSearch = `image/${imageId}`;
                const ids = _.filter( imageAliasData, entry => entry.startsWith( toSearch ) );
                ids.forEach( id => {
                    if( customBundles[ id ] ) {
                        logger.warn( `${imageId} is included in multiple bundles. ${imageId} is included in ${customBundles[ id ]}` );
                    } else {
                        customBundles[ id ] = bundleName;
                    }
                } );
            } else {
                if( customBundles[ imageId ] ) {
                    logger.warn( `${imageId} is included in multiple bundles. ${imageId} is included in ${customBundles[ imageId ]}` );
                } else {
                    customBundles[ imageId ] = bundleName;
                }
            }
        } );
    }
    return { customBundles, isLazyLoadDisabled };
};

const getChunkName = ( name, issuer ) => {
    const fileName = `image/${name}.svg`;
    if( !imageBundles ) {
        imageBundles = getCustomImageBundles();
    }
    if( /(\.scss|\.css)$/.test( issuer.userRequest ) ) {
        return 'cssImageBundle';
    }

    if( /^image[\\/]type\S+/.test( fileName ) === false ) {
        let chunkname = imageBundles.isLazyLoadDisabled ? imageBundles.isLazyLoadDisabled : false;
        if( imageBundles.customBundles[ fileName ] ) {
            chunkname = imageBundles.customBundles[ fileName ];
        }
        return chunkname;
    }
    return false;
};

module.exports = {
    getViewDep,
    getKitCache,
    getBuildPathCache,
    getRequiredSoa,
    getAliasMap,
    getBuildJson,
    findBaseKits,
    findWebpackPlugin,
    normalizePath,
    getSelectedSite,
    getResolvedSourcePaths,
    customizeSassLoader,
    getModuleScssFiles,
    getThemeScssFiles,
    getEffectiveBootstrapCache,
    kebabCaseToPascalCase,
    pascalCaseToKebabCase,
    isBootstrapAliasImport,
    isJSImport,
    isConfigImport,
    isViewModelImport,
    isImageImport,
    isNodeTemplateImport,
    getEntryHtmlInfo,
    getEffectiveModules,
    getEffectiveKitNames,
    getOOTBList,
    getEffectiveKits,
    getEffectiveKitPaths,
    getEffectiveAlias,
    getModuleCache,
    resolveAlias,
    removeES5BabelLoader,
    addExcludeFileTypeToFileLoader,
    getImageAlias,
    createTestDirs,
    getSiteCache,
    getChunkName
};
