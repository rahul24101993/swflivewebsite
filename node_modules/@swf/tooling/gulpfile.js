/* eslint-env amd, es6, node */
/* eslint-disable no-multi-assign */

const _ = require( 'lodash' );
const { existsSync } = require( 'fs' );
const gulp = global.gulp = require( 'gulp' );
const { basename, dirname } = require( 'path' );

// https://github.com/gulpjs/undertaker-forward-reference
const FwdRef = require( 'undertaker-forward-reference' );
gulp.registry( new FwdRef() );

const logger = require( './js/logger' );
const util = require( './js/util' );

const trace = logger.createTrace( __filename );

process.env.DRAFT = util.isEnvFlagEnabled( 'DRAFT', 'true' );

trace( 'process.cwd()=' + process.cwd() );
trace( '__dirname=' + __dirname );
trace( 'process.env.ROOT=' + process.env.ROOT );

for( const name of [
    'audit',
    'optional',
    'sonar'
] ) {
    let filePath;
    if( existsSync( __dirname + '/gulpfile_' + name + '.js' ) ) {
        filePath = __dirname + '/gulpfile_' + name + '.js';
    } else if( existsSync( process.cwd() + '/gulpfile_' + name + '.js' ) ) {
        filePath = process.cwd() + '/gulpfile_' + name + '.js';
    } else if( existsSync( process.cwd() + '/src/gulpfile_' + name + '.js' ) ) {
        filePath = process.cwd() + '/src/gulpfile_' + name + '.js';
    }
    if( filePath ) {
        require( filePath );
    }
}

// Load all module.json files
const cacheJsonPath = process.cwd() + '/out/cache.json';
global.cache = existsSync( cacheJsonPath ) && require( cacheJsonPath ) || {};

/**
 * Load custom gulp scripts through build.json
 * 1. Find build.json at root folder
 * 2. If exists then read it and load gulp file mentioned in it
 */
const buildJsonPath = `${process.cwd()}/build.json`;
const buildJson = existsSync( buildJsonPath ) ? require( buildJsonPath ) : null;
if( buildJson ) {
    const transpilers = buildJson.transpilers;
    if( transpilers ) {
        for( const [ key, value ] of Object.entries( transpilers ) ) {
            const parentModule = module.parent;
            if( parentModule ) {
                parentModule.require( `${value.packageName}/build/gulpfile_${key}.js` );
            } else {
                logger.error( `Not able to load ${value.packageName}/build/gulpfile_${key}.js` );
            }
        }
    }
}
global.cache.buildJson = buildJson || {};
global.cache.task = {};

// Requires the root module.js file
if( existsSync( process.cwd() + '/out/generatedTasks.js' ) ) {
    require( process.cwd() + '/out/generatedTasks' );
}

// ---------- Jenkins support tasks ----------//

let cacheLoadedPromise;
let cacheLoadedResolve;

/**
 */
global.cacheLoaded = async function() {
    // Ensure this is run only once
    if( cacheLoadedPromise ) { return cacheLoadedPromise; }
    cacheLoadedPromise = new Promise( resolve => { cacheLoadedResolve = resolve; } );

    await updateGlobalCache();
    // logger.info( 'loaded', 'cache: ' );

    cacheLoadedResolve();
};

/**
 * Update the global cache
 *
 * @return {Promise} Promise that is resolved when the global cache is updated
 */
async function updateGlobalCache() {
    global.cache.configurations = {};
    global.cache.name2kitJson = {};
    for( const kitJson of Object.values( global.cache.filePath2kitJson ) ) {
        global.cache.name2kitJson[ kitJson.name ] = kitJson;
        if( kitJson.configuration ) {
            _.merge( global.cache.configurations, kitJson.configuration );
        }
    }

    const srcDirModuleJson = [];
    const srcDirKitJson = [];
    for( const [ name, value ] of Object.entries( global.cache.configurations ) ) {
        const array = value.definition === 'module' ? srcDirModuleJson : srcDirKitJson;
        if( value.multiple ) {
            array.push( name + '*.json' );
        } else {
            array.push( name + '.json' );
        }
    }

    global.cache.name2moduleJson = {};
    const promises = [];
    for( const [ filePath, kitJson ] of Object.entries( global.cache.filePath2kitJson ) ) {
        promises.push( util.stream2Promise( gulp.src( srcDirKitJson, { cwd: dirname( filePath ), allowEmpty: true } )
            .pipe( util.tapBlock( file => {
                const fileName = basename( file.path, '.json' );
                try {
                    const data = JSON.parse( file.contents.toString() );
                    if( /^workspace/.test( fileName ) ) {
                        if( !kitJson.workspace ) {
                            kitJson.workspace = {};
                        }
                        kitJson.workspace[ data.workspaceId ] = data;
                    } else {
                        kitJson[ fileName ] = data;
                    }
                } catch ( e ) {
                    logger.error( 'Unable to parse: ' + file.path );
                    throw e;
                }
            } ) ) ) );
    }

    for( const [ filePath, moduleJson ] of Object.entries( global.cache.filePath2moduleJson ) ) {
        global.cache.name2moduleJson[ moduleJson.name ] = moduleJson;
        promises.push( util.stream2Promise( gulp.src( srcDirModuleJson, { cwd: filePath, allowEmpty: true } )
            .pipe( util.tapBlock( file => {
                try {
                    const data = JSON.parse( file.contents.toString() );
                    const fileName = basename( file.path, '.json' );
                    moduleJson[ fileName ] = data;
                } catch ( e ) {
                    logger.error( `Unable to parse: ${file.path}` );
                    throw e;
                }
            } ) ) ) );
    }

    await Promise.all( promises ).catch( logger.pipeErrorHandler );
}

// Clean temporary files from unit
gulp.task( 'clean', () => {
    return util.del( [
        'out',
        'target*', // 'cucumber' run output
        'rerun*.txt', // 'cucumber' run output
        'ImpactedFiles*', // 'cucumber cp-coverage' output
        'ImpactedFunctions*', // 'cucumber cp-coverage' output
        'coverage', // 'cucumber cp-coverage' output
        'Coverage_Log', // Code Coverage output
        '.sonar', // sonar output
        'cobertura.ser', // sonar output
        'src/**/.sonar', // sonar project directories
        'src/**/sonar',
        'npm*.log'
    ] ).catch( logger.pipeErrorHandler );
} );
