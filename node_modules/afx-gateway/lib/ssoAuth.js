const fs = require( 'fs' );
const path = require( 'path' );
const _ = require( 'lodash' );
const express = require( 'express' );
const requestPromise = require( 'request-promise' );
const ssoUtil = require( __dirname + '/ssoUtil' );

// definition for SSOAuthenticator
/** Is sso app token key */
const IS_TCSSO_APP_TOKEN = 'IS_TCSSO_APP_TOKEN';

/** TCSSO LOCALE key */
const TCSSO_LOCALE = 'TCSSO_LOCALE';

/** TCSSO SESSION KEY key */
const TCSSO_SESSION_KEY = 'TCSSO_SESSION_KEY';

/** TCSSO APP USER ID key */
const TCSSO_APP_USER_ID = 'TCSSO_APP_USER_ID';

/** The initialLoginPage */
const INITIAL_LOGIN_PAGE = 'initialLoginPage';

/** The TcSS Login Redirect URI */
const TCSS_LOGIN_REDIRECT_URI = '/weblogin/login_redirect';

/** The TcSS signOut URI */
const TCSS_LOGOUT_URI = '/weblogin/logoutandchallenge';

/** The flag used to identify an SSO login by AW */
const AW_SSO_LOGIN_FLAG = '/AWSSOLogin';

/** tcSSO login SOA response error message. */
const msgNoProperLoginSSOResponse = 'This isn\'t a proper loginSSO SOA response!';

/** tcSSO login tcServerErrorMessage error message. */
const msgTCServerErrorMessage = 'Failure returned from TC server. Please contact your System Administrator.\n\n';

const SC_OK = 200;
const SC_MOVED_TEMPORARILY = 302;
const SC_SEE_OTHER = 303;
const SC_INTERNAL_SERVER_ERROR = 500;

/** restore the session variables */
let m_SessionVars = {};

/** SSO App ID */
let m_ssoAppId = '';

/** SSO Login URL */
let m_ssoLoginURL = '';

/** SSO signOut URL */
let m_ssoLogoutURL = '';

/** SSO redirect request method */
let m_ssoRedirectMethod = '';

/** SSO Query Params */
let m_ssoQueryParams = '';

/** SSO no applets flag. Default is true */
let m_isSSONoApplets = true;

/**
 * Base assets path
 */
let m_baseUrlPath = '';

/**
 * Init the ssoAuth, get the variables from option.
 * or read the configuration file because these variable should be set in tem installation
 *
 * @param {object} app get from expressServer
 * @param {object} options the object set in expressServer.
 * @param {String} siteDir the parent dir of assets.
 */
exports.init = function( app, options, siteDir ) {
    if( options.tcSSOAppID === '' || options.tcSSOURL === '' ) {
        return;
    }
    m_SessionVars = options;
    m_SessionVars.tcSSOEnabled = true;
    m_SessionVars.tcSSORedirectMethod = '';
    m_SessionVars.tcSSOLogoutURL = '';

    m_ssoAppId = options.tcSSOAppID;
    m_ssoLoginURL = options.tcSSOURL;

    // use the middle ware to get the request.body in sso request
    app.use( express.urlencoded( { extended: true } ) );
    app.use( '/getSessionVars', exports.getSessionVars );

    let assetsDir = siteDir + '/assets';
    if( !fs.existsSync( assetsDir ) && fs.existsSync( path.dirname( assetsDir ) ) ) {
        // handle optimized/non-draft builds
        fs.readdirSync( path.dirname( assetsDir ) ).forEach( function( filename ) {
            if( /^assets/.test( filename ) ) {
                assetsDir = path.dirname( assetsDir ) + '/' + filename;
            }
        } );
    }
    m_baseUrlPath = assetsDir;
};

/**
 * handle the getSessionVars back end.
 *
 * @param {object} req the request.
 * @param {object} res the response.
 * @param {object} options the variables setting for sso
 */
exports.getSessionVars = function( req, res ) {
        _.forEach( m_SessionVars, ( value, name ) => {
            if( typeof value !== 'string' ) {
                m_SessionVars[ name ] = value.toString();
            }
        } );
        res.set( 'Content-Type', 'application/json' );
        res.status( 200 ).send( JSON.stringify( m_SessionVars ) );
};

/**
 * handle the sso login redirect process from sso server.
 *
 * @param {object} req the request.
 * @param {object} res the response.
 */
exports.awSSOLoginService = function( req, res ) {
    processSSOAuthResponse( req, res );
};

/**
 * handle the sso login process.
 *
 * @param {object} req the request.
 * @param {object} res the response.
 */
exports.ssoPerformLoginPage = function( req, res ) {
    exports.ssoPerformLogin( req, res, null );
};

/**
 * handle the sso logout process.
 *
 * @param {object} req the request.
 * @param {object} res the response.
 */
exports.ssoPerformLogoutPage = function( req, res ) {
    // If undefined signOut URL, do what we do today.
    if( m_ssoLogoutURL === null || m_ssoLogoutURL === '' ) {
        // DEBUG( 'Performing redirect to TcSS for logout...' );
        let logoutHtml = buildLogoutHTML( req );
        res.set( 'Cache-Control', 'no-cache, no-store' );
        res.set( 'Content-Type', 'text/html; charset=UTF-8' );
        res.send( logoutHtml );
    }else{ // Otherwise redirect to the defined URL.
        res.redirect( encodeURI( m_ssoLogoutURL ) );
    }
};

/**
 * Displays error message to user, and then redirects to TcSS.
 *
 * @param {object} req The Request.
 * @param {object} res The response.
 * @param {String} exMessage The exception containing the error.
 */
exports.ssoPerformLogin = function( req, res, exMessage ) {
    let loginHtml = buildLoginHTML( req, exMessage );
    res.set( 'Cache-Control', 'no-cache, no-store' );
    res.set( 'Content-Type', 'text/html; charset=UTF-8' );
    res.send( loginHtml );
};
// exports.isSSOEnabled = function() {
//     return m_isSSOEnabled;
// };

/**
 * build the login form html
 *
 * @param {object} req The Request.
 * @param {String} exMessage The exception containing the error.
 * @return {String} HTML page string
 */
let buildLoginHTML = function( req, exMessage ) {
    let queryBuilder = '';
    let params = req.params;
    if( m_ssoQueryParams !== null && !m_ssoQueryParams === '' ) {
        queryBuilder += m_ssoQueryParams;
    }
    if( params !== null ) {
        Object.keys( params ).forEach( key  => {
            // csrf cookie is not used by AW during performLogin and performSignOut and prevents re-login after sign-out
            if( !key.toLowerCase() === 'csrf_form' ) {
                let value = params( key );
                if( value !== null && value.length > 0 ) {
                    if( queryBuilder.length === 0 ) {
                        queryBuilder += '?';
                    }else{
                        queryBuilder += '&';
                    }
                    // Only the first value will be supported during performLogin and performSignOut
                    // There is no forseable need to support multiple values in these cases
                    // Encode parameter to prevent path-based XSS
                    let encodedKey = encodeURIComponent( key );
                    let encodedValue = '';
                    if( Array.isArray( value ) ) {
                        encodedValue = encodeURIComponent( value[0] );
                    }else{
                        encodedValue = encodeURIComponent( value );
                    }
                    queryBuilder +=  encodedKey + '=' + encodedValue;
                }
            }
        } );
    }

    let ssoPageHTML = ssoUtil.getSSOFormPageHTML( exMessage );
    let encodedLocationStr = 'var location = encodeURIComponent( window.location.pathname + window.location.search + window.location.hash );';
    ssoPageHTML = ssoPageHTML.replace( '{{encodedLocation}}', encodedLocationStr );

    ssoPageHTML = ssoPageHTML.replace( '{{cssMain}}', m_baseUrlPath + '/main.css' );
    ssoPageHTML = ssoPageHTML.replace( '{{cssTheme}}', m_baseUrlPath + '/ui-lightTheme.css' );
    ssoPageHTML = ssoPageHTML.replace( '{{ssobackground}}', m_baseUrlPath + '/images/ssobackground.jpg' );
    ssoPageHTML = ssoPageHTML.replace( '{{ssoRedirectMethod}}', 'POST' );

    let ssoRedirectURL = m_ssoLoginURL + TCSS_LOGIN_REDIRECT_URI + queryBuilder;
    ssoPageHTML = ssoPageHTML.replace( '{{ssoLoginRedirectURL}}', ssoRedirectURL );

    let hiddenInputsFromParameters = '';
    if( params !== null ) {
        if( m_ssoRedirectMethod.toLowerCase() === 'get' ) {
            Object.keys( params ).forEach( key  => {
                // csrf cookie is not used by AW during performLogin and performSignOut and prevents re-login after sign-out
                if( !key.toLowerCase() === 'csrf_form' ) {
                    let value = params( key );
                    if( value !== null && value.length > 0 ) {
                        if( Array.isArray( value ) ) {
                            hiddenInputsFromParameters += '<input type=hidden name=" + key + " value=" + value[0] + "> ' + '\n';
                        }else{
                            hiddenInputsFromParameters += '<input type=hidden name=" + key + " value=" + value + "> ' + '\n';
                        }
                    }
                }
            } );
        }
    }
    ssoPageHTML = ssoPageHTML.replace( '{{hiddenInputsFromParameters}}', hiddenInputsFromParameters );
    ssoPageHTML = ssoPageHTML.replace( '{{ssoAppId}}', m_ssoAppId );
    ssoPageHTML = ssoPageHTML.replace( '{{ssoURI}}', AW_SSO_LOGIN_FLAG );
    ssoPageHTML = ssoPageHTML.replace( '{{isSSONoApplets}}', m_isSSONoApplets );
    return ssoPageHTML;
};

/**
 * build the log out form html
 *
 * @param {object} req The Request.
 * @return {String} HTML page string
 */
let buildLogoutHTML = function( req ) {
    let queryBuilder = '';
    let params = req.params;
    if( m_ssoQueryParams !== null && !m_ssoQueryParams === '' ) {
        queryBuilder += m_ssoQueryParams;
    }
    if( params !== null ) {
        Object.keys( params ).forEach( key  => {
            // csrf cookie is not used by AW during performLogin and performSignOut and prevents re-login after sign-out
            if( !key.toLowerCase() === 'csrf_form' ) {
                let value = params( key );
                if( value !== null && value.length > 0 ) {
                    if( queryBuilder.length === 0 ) {
                        queryBuilder += '?';
                    }else{
                        queryBuilder += '&';
                    }
                    // Only the first value will be supported during performLogin and performSignOut
                    // There is no forseable need to support multiple values in these cases
                    // Encode parameter to prevent path-based XSS
                    let encodedKey = encodeURIComponent( key );
                    let encodedValue = '';
                    if( Array.isArray( value ) ) {
                        encodedValue = encodeURIComponent( value[0] );
                    }else{
                        encodedValue = encodeURIComponent( value );
                    }
                    queryBuilder +=  encodedKey + '=' + encodedValue;
                }
            }
        } );
    }

    let ssoPageHTML = ssoUtil.getSSOFormPageHTML( null );
    let encodedLocationStr = 'var location = encodeURIComponent( window.location.pathname + window.location.search + window.location.hash );';
    ssoPageHTML = ssoPageHTML.replace( '{{encodedLocation}}', encodedLocationStr );

    ssoPageHTML = ssoPageHTML.replace( '{{cssMain}}', '"' + m_baseUrlPath + '/main.css"' );
    ssoPageHTML = ssoPageHTML.replace( '{{cssTheme}}', '"' + m_baseUrlPath + '/ui-darkTheme.css"' );
    ssoPageHTML = ssoPageHTML.replace( '{{ssobackground}}', '"' + m_baseUrlPath + '/images/ssobackground.jpg"' );
    ssoPageHTML = ssoPageHTML.replace( '{{ssoRedirectMethod}}', 'POST' );

    let ssoRedirectURL = m_ssoLoginURL + TCSS_LOGOUT_URI + queryBuilder;
    ssoPageHTML = ssoPageHTML.replace( '{{ssoLoginRedirectURL}}', ssoRedirectURL );

    let hiddenInputsFromParameters = '';
    ssoPageHTML = ssoPageHTML.replace( '{{hiddenInputsFromParameters}}', hiddenInputsFromParameters );
    ssoPageHTML = ssoPageHTML.replace( '{{ssoAppId}}', m_ssoAppId );
    ssoPageHTML = ssoPageHTML.replace( '{{ssoURI}}', req.path );
    ssoPageHTML = ssoPageHTML.replace( '{{isSSONoApplets}}', m_isSSONoApplets );
    return ssoPageHTML;
};

/**
 * Query the session from SOA and redirect to previous page
 *
 * @param {object} request The Request of AW.
 * @param {object} response The response of AW.
 */
let processSSOAuthResponse = function( request, response ) {
    let isTcSSOAppToken = false;
    let tcSSOLocale = '';
    let tcSSOSessionKey = '';
    let tcSSOAppUserID = '';
    let initialLoginPage = '';
    let parameters = request.body;


    let contentType = request.headers['content-type'];
    if ( contentType === 'application/x-www-form-urlencoded' ) {
        if( parameters.hasOwnProperty( IS_TCSSO_APP_TOKEN ) ) {
            let isTcSSOAppTokenStr = parameters[IS_TCSSO_APP_TOKEN];
            if( isTcSSOAppTokenStr !== null && isTcSSOAppTokenStr !== '' ) {
                isTcSSOAppToken = isTcSSOAppTokenStr.toLowerCase() === 'true';
            }
        }
        if( parameters.hasOwnProperty( TCSSO_LOCALE ) ) {
            tcSSOLocale = parameters[TCSSO_LOCALE];
        }
        if( parameters.hasOwnProperty( TCSSO_SESSION_KEY ) ) {
            tcSSOSessionKey = parameters[TCSSO_SESSION_KEY];
        }
        if( parameters.hasOwnProperty( TCSSO_APP_USER_ID ) ) {
            tcSSOAppUserID = parameters[TCSSO_APP_USER_ID];
        }
        if( parameters.hasOwnProperty( INITIAL_LOGIN_PAGE ) ) {
            initialLoginPage = parameters[INITIAL_LOGIN_PAGE];
            if( initialLoginPage !== null && !initialLoginPage !== '' ) {
                initialLoginPage = decodeURIComponent( initialLoginPage );
            }
        }

        if( isTcSSOAppToken ) {
            ssoUtil.updateDiscriminator();

            //query the session from tc/JsonRestServices/Core-2008-06-Session/loginSSO
            var options = getLoginSSOPostOption( request, tcSSOAppUserID, tcSSOSessionKey, tcSSOLocale );

            try{
                requestPromise( options )
                    .then( function( SOAResponse ) {
                        let errorMessage = msgTCServerErrorMessage;
                        if( SOAResponse.statusCode === SC_OK || SOAResponse.statusCode === SC_MOVED_TEMPORARILY ) {
                            let responseData = SOAResponse.body;
                            // console.log( 'Body: ' + JSON.stringify( responseData ) );

                            if( responseData !== null &&  responseData !== '' ) {
                                var resObj = null;
                                try{
                                    resObj = JSON.parse( responseData );
                                }catch( ex ) {
                                    exports.ssoPerformLogin( request, response, 'Response parsing failure:' + ex.toString() );
                                    return false;
                                }

                                if( resObj ) {
                                    let qName = resObj[ '.QName' ] || '';
                                    if( qName.includes( 'InvalidCredentialsException' ) ) {
                                        // redirect and display error in login page
                                        let ExMsg = resObj.hasOwnProperty( 'message' ) ? resObj.message : '';
                                        exports.ssoPerformLogin( request, response, ExMsg );
                                    } else if( qName.includes( 'InvalidUserException' ) ||
                                        qName.includes( 'ServiceException' ) ||
                                        qName.includes( 'InternalServerException' ) ) {
                                        // send excpetion error to response
                                        let ExMsg = resObj.hasOwnProperty( 'message' ) ? resObj.message : '';
                                        let errMsg = msgTCServerErrorMessage + ExMsg;
                                        response.status( SC_SEE_OTHER ).send( errMsg );
                                    } else {
                                        /**
                                         * Get JSESSIONID from SOA response.
                                         */
                                        var cookieArray = SOAResponse.headers[ 'set-cookie' ];

                                        if( !_.isEmpty( cookieArray ) ) {
                                            var cookies = cookieArray[ 0 ].split( ';' );
                                            var isRedirected = false;
                                            _.forEach( cookies, function( crumb ) {
                                                crumb = _.trim( crumb );

                                                if( _.startsWith( crumb, 'JSESSIONID' ) ) {
                                                    var ndx = crumb.lastIndexOf( '=' );
                                                    var jSessionID = crumb.substring( ndx + 1 );

                                                    //or we need to update all the header from SOAresponse

                                                    //set the cookie with session in AW response so can redirect into AW without login
                                                    response.cookie( 'JSESSIONID', jSessionID, { path: '/', httpOnly: true } );
                                                    try{
                                                        isRedirected = redirectToAWClient( request, response, initialLoginPage, tcSSOLocale );
                                                    } catch( ex ) {
                                                        errorMessage = ex.toString();
                                                    }
                                                    //return this loop
                                                    return;
                                                }
                                            } );
                                            if( isRedirected === true ) {
                                                //return this response handle process because it has been redirect to AW page
                                                return;
                                            }
                                        }
                                    }
                                }
                            }
                            // if parsing the soa response failed , display another error
                            errorMessage = msgNoProperLoginSSOResponse;
                        }
                        errorMessage += 'HTTP Status code is: ' + SOAResponse.statusCode + '\n';
                        errorMessage += 'TC URL attempting to be connected to is:' + options.uri + '\n';
                        response.status( SC_SEE_OTHER ).send( errorMessage );
                    } );
            } catch ( ex ) {
                // send internal server error message
                response.status( SC_INTERNAL_SERVER_ERROR ).send( ex.toString() );
            }
        }
    }
};

/**
 * redirect to AW page
 *
 * @param {object} request The Request of AW.
 * @param {object} response The response of AW.
 * @param {String} initialLoginPage The init login page of AW.
 * @param {String} tcSSOLocale The locale setting of AW.
 * @return {boolean} is Redirect or not
 */
let redirectToAWClient = function( request, response, initialLoginPage, tcSSOLocale ) {
    // redirect to where they were
    let redirectSuccess = false;
    try{
        let url = decodeURIComponent( initialLoginPage );
        let origQuery = {};
        let origPath = url;
        let origContextPath = '/';
        let origPathQueryObj = getURLPathAndQuery( url );
        if( origPathQueryObj.hasOwnProperty( 'path' ) ) {
            origPath = origPathQueryObj.path;
        } else if( origPathQueryObj.hasOwnProperty( 'query' ) ) {
            origQuery = origPathQueryObj.query;
        } else if( origPathQueryObj.hasOwnProperty( 'contextPath' ) ) {
            origContextPath = origPathQueryObj.contextPath;
        }
        let path = origPath;
        if( path.endsWith( '/reauth' ) ) {
            path = path.replace( '/reauth', '' );
        } else if ( path.endsWith( '/auth' ) ) {
            path = path.replace( '/auth', '' );
        }
        url = path === '' ? origContextPath : path;
        if( tcSSOLocale !== null && tcSSOLocale !== '' ) {
            origQuery.locale = tcSSOLocale;
        }

        let queryStr = '';
        _.forEach( origQuery, ( value, name ) => {
            if( queryStr !== '' ) {
                queryStr += '&';
            }
            queryStr += name.toString() + '=' + value.toString();
        } );

        if( queryStr !== '' ) {
            url = url + '?' + queryStr;
        }
        response.redirect( encodeURI( url ) );
        redirectSuccess = true;
    } catch ( ex ) {
        throw ex;
    }
    return redirectSuccess;
};

/**
 * Builds the Login SSO Post Option to connect to the SOA loginSSO service.
 *
 * @param {Object} request The http servlet request.
 * @param {String} tcSSOAppUserID The user ID.
 * @param {String} tcSSOSessionKey The sso token.
 * @param {String} tcSSOLocale The locale.
 * @return {Object} The Post Option Objcet to be given to an http.request call.
*/
let getLoginSSOPostOption = function( request, tcSSOAppUserID, tcSSOSessionKey, tcSSOLocale ) {
    let formJsonStr = JSON.stringify( buildLoginSSOJsonObj( tcSSOAppUserID, tcSSOSessionKey, tcSSOLocale, ssoUtil.getDiscriminator() ) );
    let soaURL = ssoUtil.buildSOAUrl( request, '/tc/JsonRestServices/Core-2008-06-Session/loginSSO' );
    let headsObj = {
        'content-type':'application/json; charset=UTF-8',
        'content-Length' : Buffer.byteLength( formJsonStr ),
        'Log-Correlation-ID':'AuthenticationFilter'
    };

    let postOption = {
        method: 'POST',
        uri: soaURL,
        form: formJsonStr,
        headers: headsObj,
        json: false,
        resolveWithFullResponse: true
    };
    return postOption;
};

/**
 * Builds the JSON Object for invoking SOA's loginSSO call.
 *
 * @param {String} tcSSOAppUserID The TC user ID.
 * @param {String} tcSSOSessionKey The SSO token.
 * @param {String} tcSSOLocale The locale.
 * @param {String} sessionDiscriminator The session discriminator.
 * @return {Object} A JSON formatted Object.
 */

let buildLoginSSOJsonObj = function( tcSSOAppUserID, tcSSOSessionKey, tcSSOLocale, sessionDiscriminator ) {
    let state = ssoUtil.soaState( ssoUtil.getCLIENT_ID(), ssoUtil.getClientVersion(), 'AuthenticationFilter', true );
    let header = ssoUtil.soaHeader( state, ssoUtil.soaPolicy() );
    let body = ssoUtil.soaLoginSSOBody( tcSSOAppUserID, tcSSOSessionKey, tcSSOSessionKey, '', '', tcSSOLocale, sessionDiscriminator );
    let soaRequest = ssoUtil.soaRequest( header, body );
    return soaRequest;
};

/**
 * get the path and parameters string from input URL
 * @param {String} url initial login page
 * @return {Object} the object with URL Path and Query
 */
let getURLPathAndQuery = function( url ) {
    let obj = {
        path:url,
        contextPath:'',
        query: {}
    };
    if( url ) {
        let reg = new RegExp( '[?#]', 'g' );
        reg.test( url );
        let lastIndx = reg.lastIndex;
        if( lastIndx > 0 ) {
            let tmpPath = url.substring( 0, lastIndx - 1 );
            if( tmpPath.endsWith( '/' ) ) {
                obj.path = tmpPath.substring( 0, tmpPath.length - 1 );
                obj.contextPath = '/';
            } else {
                obj.path = tmpPath;
            }
            let tmpQueryStr = url.substring( lastIndx );
            let tempQuery = {};
            try{
                tmpQueryStr.split( '&' ).forEach( param => {
                    var part = param.split( '=' );
                    // ignore the csrf_form when redirect to AW
                    if( part[0] !== 'csrf_form' ) {
                        tempQuery[ part[0] ] = part[1];
                    }
                } );
            } catch ( ex ) {
                // LOG the parsing error?
                // just throw it.
                throw ex;
            }

            obj.query = tempQuery;
        }
    }
    return obj;
};
