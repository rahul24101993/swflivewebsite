"use strict";
/** @packageDocumentation @reactapi @module react_hooks */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var core_1 = require("@uirouter/core");
var components_1 = require("../components");
var useDeepObjectDiff_1 = require("./useDeepObjectDiff");
var useParentView_1 = require("./useParentView");
var useRouter_1 = require("./useRouter");
/** @hidden */
exports.IncorrectStateNameTypeError = "The state name passed to useSref must be a string.";
/** @hidden Gets all StateDeclarations that are registered in the StateRegistry. */
function useListOfAllStates(router) {
    var initial = react_1.useMemo(function () { return router.stateRegistry.get(); }, []);
    var _a = react_1.useState(initial), states = _a[0], setStates = _a[1];
    react_1.useEffect(function () { return router.stateRegistry.onStatesChanged(function () { return setStates(router.stateRegistry.get()); }); }, []);
    return states;
}
/** @hidden Gets the StateDeclaration that this sref targets */
function useTargetState(router, stateName, relative) {
    // Whenever any states are added/removed from the registry, get the target state again
    var allStates = useListOfAllStates(router);
    return react_1.useMemo(function () {
        return router.stateRegistry.get(stateName, relative);
    }, [router, stateName, relative, allStates]);
}
/**
 * A hook to create a link to a state.
 *
 * This hook returns link (anchor tag) props for a given state reference.
 * The resulting props can be spread onto an anchor tag.
 *
 * The props returned from this hook are:
 *
 * - `href`: the browser URL of the referenced state
 * - `onClick`: a mouse event handler that will active the referenced state
 *
 * Example:
 * ```jsx
 * function HomeLink() {
 *   const sref = useSref('home');
 *   return <a {...sref}>Home</a>
 * }
 * ```
 *
 * Example:
 * ```jsx
 * function UserLink({ userId, username }) {
 *   const sref = useSref('users.user', { userId: userId });
 *   return <a {...sref}>{username}</a>
 * }
 * ```
 *
 * The `onClick` handler falls back to native browser behavior (does not initiate a state transition) when:
 *
 * - the user Ctrl+Click / Alt+Click / Meta+Click / Shift+Click
 * - the underlying tag (e.g.: anchor tag) has a 'target' attribute, such as `<a target="_blank">Open in new window</a>`
 * - preventDefault has been called on the event, e.g.: `<a onClick={e => e.preventDefault()}>no-op</a>`
 *
 * @param stateName The name of the state to link to
 * @param params Any parameter values
 * @param options Transition options used when the onClick handler fires.
 */
function useSref(stateName, params, options) {
    if (params === void 0) { params = {}; }
    if (options === void 0) { options = {}; }
    if (!core_1.isString(stateName)) {
        throw new Error(exports.IncorrectStateNameTypeError);
    }
    var router = useRouter_1.useRouter();
    // memoize the params object until the nested values actually change so they can be used as deps
    var paramsMemo = react_1.useMemo(function () { return params; }, [useDeepObjectDiff_1.useDeepObjectDiff(params)]);
    var relative = useParentView_1.useParentView().context.name;
    var optionsMemo = react_1.useMemo(function () { return (__assign({ relative: relative, inherit: true }, options)); }, [relative, options]);
    var targetState = useTargetState(router, stateName, relative);
    // Update href when the target StateDeclaration changes (in case the the state definition itself changes)
    // This is necessary to handle things like future states
    var href = react_1.useMemo(function () {
        return router.stateService.href(stateName, paramsMemo, optionsMemo);
    }, [router, stateName, paramsMemo, optionsMemo, targetState]);
    var onClick = react_1.useCallback(function (e) {
        var _a, _b;
        var targetAttr = (_b = (_a = e.target) === null || _a === void 0 ? void 0 : _a.attributes) === null || _b === void 0 ? void 0 : _b.target;
        var modifierKey = e.button >= 1 || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey;
        if (!e.defaultPrevented && targetAttr == null && !modifierKey) {
            e.preventDefault();
            router.stateService.go(stateName, paramsMemo, optionsMemo);
        }
    }, [router, stateName, paramsMemo, optionsMemo]);
    // Participate in any parent UISrefActive
    var parentUISrefActiveAddStateInfo = react_1.useContext(components_1.UISrefActiveContext);
    react_1.useEffect(function () {
        return parentUISrefActiveAddStateInfo(targetState && targetState.name, paramsMemo);
    }, [targetState, paramsMemo]);
    return { onClick: onClick, href: href };
}
exports.useSref = useSref;
//# sourceMappingURL=useSref.js.map