{
  "version": 3,
  "file": "useStableCallback.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/react/hooks/useStableCallback.ts"
  ],
  "names": [],
  "mappings": ";AAAA,0DAA0D;;AAE1D,+BAA4C;AAE5C;;;;;;;;;;;;;;;GAeG;AAEH,SAAgB,iBAAiB,CAAqB,gBAAmB;IACvE,IAAM,GAAG,GAAG,cAAM,CAAI,gBAAgB,CAAC,CAAC;IACxC,GAAG,CAAC,OAAO,GAAG,gBAAgB,CAAC;IAC/B,IAAM,QAAQ,GAAG,mBAAW,CAAC;QAC3B,OAAO,GAAG,CAAC,OAAO,IAAI,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IAC3D,CAAC,EAAE,EAAE,CAAC,CAAC;IACP,OAAQ,QAAyB,CAAC;AACpC,CAAC;AAPD,8CAOC",
  "sourcesContent": [
    "/** @packageDocumentation @internal @module react_hooks */\n\nimport { useCallback, useRef } from 'react';\n\n/**\n * Returns a stabilized callback reference which delegates to the most recent unstable callback\n *\n * This is similar to useCallback, but allows unstableCallback to access the most recent values from the closure.\n * This can be useful if the callback is being stored long term, such as in the Transition Hook registry.\n *\n * Example:\n * ```jsx\n * const latestValueFromProps = props.value\n * const transitionHook = useStableCallback(() => console.log(latestValueFromProps));\n * useEffect(() => {\n *   const deregister = transitionService.onBefore({ exiting: 'someState' }, transitionHook);\n *   return () => deregister();\n * }, []);\n * ```\n */\n\nexport function useStableCallback<T extends Function>(unstableCallback: T): T {\n  const ref = useRef<T>(unstableCallback);\n  ref.current = unstableCallback;\n  const callback = useCallback(function () {\n    return ref.current && ref.current.apply(this, arguments);\n  }, []);\n  return (callback as unknown) as T;\n}\n"
  ]
}